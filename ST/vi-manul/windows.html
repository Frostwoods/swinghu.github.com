<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>VIM: windows</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>WINDOWS</h2>
<pre>
<b class="vimtag">*<a name="windows.txt">windows.txt</a>*</b>   For Vim version 6.4.  最后更新: 2005年3月21日


                  VIM  参 考 手 册    作者: Bram Moolenaar
                                      <code class="vim">译者</code>: Dasn
                                      VCD主页: http://vimcdoc.sf.net


使用多个窗口和缓冲区进行编辑                            <b class="vimtag">*<a name="windows">windows</a>*</b> <b class="vimtag">*<a name="buffers">buffers</a>*</b>

本章我们看一下操作多个窗口和缓冲区的命令。另外有些命令在操作多个窗口的时候不同
于单个窗口，这些命令也会在本章被介绍。

一些基本的内容在用户手册的第 7、8 两个章节里 |<a href="usr_07.html#usr_07.txt">usr_07.txt</a>| |<a href="usr_08.html#usr_08.txt">usr_08.txt</a>|
已经介绍过了。

1.  简介                                        |<a href="windows.html#windows-intro">windows-intro</a>|
2.  启动 Vim                                    |<a href="windows.html#windows-starting">windows-starting</a>|
3.  打开和关闭一个窗口                          |<a href="windows.html#opening-window">opening-window</a>|
4.  把光标移动到另一个窗口                      |<a href="windows.html#window-move-cursor">window-move-cursor</a>|
5.  窗口的移动                                  |<a href="windows.html#window-moving">window-moving</a>|
6.  改变窗口的大小                              |<a href="windows.html#window-resize">window-resize</a>|
7.  参数和缓冲区的列表命令                      |<a href="windows.html#buffer-list">buffer-list</a>|
8.  在所有的缓冲区和窗口里执行命令              |<a href="windows.html#list-repeat">list-repeat</a>|
9.  当前光标处的标记和文件名                    |<a href="windows.html#window-tag">window-tag</a>|
10. 预览窗口                                    |<a href="windows.html#preview-window">preview-window</a>|
11. 使用隐藏的缓冲区                            |<a href="windows.html#buffer-hidden">buffer-hidden</a>|
12. 特殊类型的缓冲区                            |<a href="windows.html#special-buffers">special-buffers</a>|

<code class="special">{Vi 没有这些命令}</code>
<code class="special">{如果在编译时没有加入 |<a href="various.html#+windows">+windows</a>|，则不能使用多个窗口}</code>
<code class="special">{如果在编译时没有加入 |<a href="various.html#+vertsplit">+vertsplit</a>|，则不能垂直分割窗口}</code>

</pre><hr class="doubleline" /><pre>
<h4>1. 简介                                                 <b class="vimtag">*<a name="windows-intro">windows-intro</a>*</b></h4>
"窗口"被用来查看缓冲区里的内容。你可以用多个窗口观察同一个缓冲区，也可以用
多个窗口观察不同的缓冲区。

"缓冲区"是一块内存区域，里面存储着正在编辑的文件。如果没有把缓冲区里的文件存
盘，那么原始文件不会被更改。

缓冲区的状态可以是下述三种情况之一：

                                                        <b class="vimtag">*<a name="active-buffer">active-buffer</a>*</b>
激活：    缓冲区的内容显示在一个窗口里。如果该缓冲区是针对某一个文件创建的，那
          么该文件已经被读入缓冲区。如果缓冲区被更改过，其内容便会与原文件不同。
                                                        <b class="vimtag">*<a name="hidden-buffer">hidden-buffer</a>*</b>
隐藏：    缓冲区的内容不被显示。如果该缓冲区是针对某一个文件创建的，那么该文件
          已经被读入缓冲区。其实它与激活状态一样，只是你看不见它。
                                                        <b class="vimtag">*<a name="inactive-buffer">inactive-buffer</a>*</b>
非激活：  缓冲区的内容不被显示，也不包含任何数据。文件一旦被装入，与该缓冲区相
          关的选项会被记住。这些选项可以包括 |<a href="starting.html#viminfo">viminfo</a>| 文件里的一些标记，但是
          这种缓冲区不能包含文本。

用一个表来说明：

<code class="section">状态            在窗口显示      文件装载        用 ":buffers" 命令 </code>
<code class="section">                                                  显示 </code>
激活              yes            yes              'a'
隐藏              no             yes              'h'
非激活            no             no               ' '

<code class="note">备注</code>: 所有的 <code class="keystroke">CTRL-W</code> 命令都可以用 |<a href="windows.html#:wincmd">:wincmd</a>| 执行，当我们不能在正常模式下输入命
令，或者输入不方便时可以试一下。

</pre><hr class="doubleline" /><pre>
<h4>2. 启动 Vim                                             <b class="vimtag">*<a name="windows-starting">windows-starting</a>*</b></h4>
在默认情况下，与 Vi 类似， Vim 启动后只打开一个窗口。

参数 "-o" 和 "-O" 可以让 Vim 为参数列表里的每一个文件打开一个窗口。参数 "-o"
水平分割窗口；参数 "-O" 垂直分割窗口。如果 "-o" 和 "-O" 都用了，那么最后一个参
数决定分割的方向。例如，下面的例子打开三个水平分割的窗口：
<code class="example">        vim -o file1 file2 file3</code>
<code class="example"></code>
参数 "-oN" ，这里的 N 是一个十进制数，用这个参数可以打开 N 个水平分割的窗口。
如果文件名的个数多于窗口数目，则只打开 N 个窗口，这样有一些文件就得不到窗口来
显示。如果指定的窗口数多于文件的个数，那么后面的几个窗口会编辑空的缓冲区。同样，
"-ON"  打开 N 个垂直分割的窗口，相应的规则与 "-oN" 相同。

如果你打开了很多的文件，每个窗口都会便得很小。你可能需要设置 'winheight' 和
'winwidth' 选项来创建一个适合工作的环境。

Buf/Win Enter/Leave 等自动命令 |<a href="autocmd.html#autocommand">autocommand</a>| 不会在打开窗口或读取文件时运行，
只有在真正进入缓冲后才会执行。

                                                        <b class="vimtag">*<a name="status-line">status-line</a>*</b>
状态栏用来分割窗口。选项 'laststatus' 用来设置在什么时候最后一个窗口可以有状态
栏：
        'laststatus' = 0        不要状态栏
        'laststatus' = 1        窗口数多于一个的时候
        'laststatus' = 2        总是显示状态栏

你可以通过设置 'statusline' 选项来改变状态栏的内容。

通常状态栏用反色显示。你可以通过修改 'highlight' 选项中的 's' 字符来改变。例如，
"sb" 设置为粗体字。如果没有启用状态栏加亮 ("sn")， 那么字符 '^' 表示当前窗口，
字符 '=' 表示其它窗口。如果支持鼠标，并且已经通过设置 'mouse' 选项使之启动，那
么你可以用鼠标拖动状态栏以改变窗口的大小。

<code class="note">备注</code>: 如果你想让状态栏以反色显示，但是没有效果。查看一下 'highlight' 选项是否包
含了 "si"。在 3.0 版本里，这意味着反转（invert）状态栏，但是现在应该使用 "sr"，
反转（reverse）状态栏，因为 "si" 现在表示斜体（italic）！如果你的终端不支持斜
体，那么状态栏还是会以反色显示；这种问题只会出现在支持斜体字的 termcap 终端上。

</pre><hr class="doubleline" /><pre>
<h4>3. 打开和关闭一个窗口                                   <b class="vimtag">*<a name="opening-window">opening-window</a>*</b> <b class="vimtag">*<a name="E36">E36</a>*</b></h4>
<code class="keystroke">CTRL-W</code> s                                                <b class="vimtag">*<a name="CTRL-W_s">CTRL-W_s</a>*</b>
<code class="keystroke">CTRL-W</code> S                                                <b class="vimtag">*<a name="CTRL-W_S">CTRL-W_S</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-S</code>                                           <b class="vimtag">*<a name="CTRL-W_CTRL-S">CTRL-W_CTRL-S</a>*</b>
:[N]sp[lit] [++opt] [+cmd]                              <b class="vimtag">*<a name=":sp">:sp</a>*</b> <b class="vimtag">*<a name=":split">:split</a>*</b>
                把当前窗口分割成两个，结果是两个窗口显示同一个文件。新打开的窗
                口高度为 N（默认值是当前窗口高度的一半）。减少当前窗口的高度，
                空出地方给新的窗口（如果你设置了 'equalalways' 选项，并且
                'eadirection' 没有设置为 "hor" 的话，其它窗口也被影响）。
                <code class="note">备注</code>: <code class="keystroke">CTRL-S</code> 不是在所有的终端都能使用，并且可能导致不能继续输
                入，遇到这种情况，用 <code class="keystroke">CTRL-Q</code> 继续。参见 |<a href="editing.html#++opt">++opt</a>| 和 |<a href="editing.html#+cmd">+cmd</a>|。

<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-V</code>                                           <b class="vimtag">*<a name="CTRL-W_CTRL-V">CTRL-W_CTRL-V</a>*</b>
<code class="keystroke">CTRL-W</code> v                                                <b class="vimtag">*<a name="CTRL-W_v">CTRL-W_v</a>*</b>
:[N]vs[plit] [++opt] [+cmd] [file]                      <b class="vimtag">*<a name=":vs">:vs</a>*</b> <b class="vimtag">*<a name=":vsplit">:vsplit</a>*</b>
                与 |<a href="windows.html#:split">:split</a>| 类似，但垂直分割窗口。如果打开了 'equalalways' 选
                项，并且选项 'eadirection' 没有设置为 "ver" ，窗口会被均匀地
                水平铺开，除非你指定了窗口的宽度。
                <code class="note">备注</code>: 在其它地方 <code class="keystroke">CTRL-Q</code> 与 <code class="keystroke">CTRL-V</code>，但是在这里不是！

<code class="keystroke">CTRL-W</code> n                                                <b class="vimtag">*<a name="CTRL-W_n">CTRL-W_n</a>*</b>
<code class="keystroke">CTRL-W</code> CTRL_N                                           <b class="vimtag">*<a name="CTRL-W_CTRL-N">CTRL-W_CTRL-N</a>*</b>
:[N]new [++opt] [+cmd]                                  <b class="vimtag">*<a name=":new">:new</a>*</b>
                创建一个新窗口并且开始编辑一个空文件。新窗口的高度为 N （默认
                值为现存高度的一半）。减少当前窗口的高度，为新窗口留出空间（如
                果你打开了 'equalalways' 选项，并且 'eadirection' 没有设置为
                "hor"，其它窗口也会被影响）。
                参见：|<a href="editing.html#++opt">++opt</a>| and |<a href="editing.html#+cmd">+cmd</a>|。
                如果设置了 'fileformats' 选项，那么新缓冲区会使用该值；如果
                'fileformats' 为空，那么使用当前缓冲区的 'fileformat' 值。这个
                值可以被 |<a href="editing.html#++opt">++opt</a>| 参数覆盖。
                自动命令以如下顺序被执行：
                1. 在当前窗口执行 WinLeave
                2. 在新窗口里执行 WinEnter
                3. 在当前缓冲区执行 BufLeave
                4. 在新缓冲区执行 BufEnter
                这跟先执行 ":split" ，再执行一个 ":e" 命令的效果差不多。

:[N]vne[w] [++opt] [+cmd] [file]                        <b class="vimtag">*<a name=":vne">:vne</a>*</b> <b class="vimtag">*<a name=":vnew">:vnew</a>*</b>
                与 |<a href="windows.html#:new">:new</a>| 命令相似，但是它垂直分割窗口，如果打开了
                'equalalways' 选项，并且选项 'eadirection' 没有设置为 "ver" ，
                窗口会被均匀地水平铺开，除非你指定了窗口的宽度。

:[N]new [++opt] [+cmd] <code class="special">{file}</code>
:[N]sp[lit] [++opt] [+cmd] <code class="special">{file}</code>                       <b class="vimtag">*<a name=":split_f">:split_f</a>*</b>
                创建一个新的窗口，并且开始编辑文件 <code class="special">{file}</code>。 如果使用了 [+cmd]
                参数，文件加载完毕后会执行命令 |<a href="editing.html#+cmd">+cmd</a>| 。
                也参见：|<a href="editing.html#++opt">++opt</a>|。
                新窗口的高度为 N （默认值为现存高度的一半）。减少当前窗口的高
                度，为新窗口留出空间（如果你打开了 'equalalways' 选项，其它
                窗口也会被影响）。

:[N]sv[iew] [++opt] [+cmd] <code class="special">{file}</code>               <b class="vimtag">*<a name=":sv">:sv</a>*</b> <b class="vimtag">*<a name=":sview">:sview</a>*</b> <b class="vimtag">*<a name="splitview">splitview</a>*</b>
                与 ":split" 命令相同，但是会给缓冲区设置 'readonly' 。

:[N]sf[ind] [++opt] [+cmd] <code class="special">{file}</code>               <b class="vimtag">*<a name=":sf">:sf</a>*</b> <b class="vimtag">*<a name=":sfind">:sfind</a>*</b> <b class="vimtag">*<a name="splitfind">splitfind</a>*</b>
                与 ":split" 命令相同，但是会在 'path' 里寻找 <code class="special">{file}</code>。如果找不
                到，就不会分割窗口。

<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-^</code>                                   <b class="vimtag">*<a name="CTRL-W_CTRL-^">CTRL-W_CTRL-^</a>*</b> <b class="vimtag">*<a name="CTRL-W_^">CTRL-W_^</a>*</b>
<code class="keystroke">CTRL-W</code> ^        执行 ":split #" 命令，把窗口分成两个，并且编辑备选文件。如果
                指定了计数器，就变成了 ":split #N"，分割窗口，并且编辑缓冲区 N 。

<code class="note">注意</code> 'splitbelow' 和 'splitright' 选项会影响新窗口的位置。

                                                <b class="vimtag">*<a name=":vert">:vert</a>*</b> <b class="vimtag">*<a name=":vertical">:vertical</a>*</b>
:vert[ical] <code class="special">{cmd}</code>
                执行 <code class="special">{cmd}</code> 。如果包含一个分割窗口的命令，那么将垂直分割窗口。

:lefta[bove] <code class="special">{cmd}</code>                              <b class="vimtag">*<a name=":lefta">:lefta</a>*</b> <b class="vimtag">*<a name=":leftabove">:leftabove</a>*</b>
:abo[veleft] <code class="special">{cmd}</code>                              <b class="vimtag">*<a name=":abo">:abo</a>*</b> <b class="vimtag">*<a name=":aboveleft">:aboveleft</a>*</b>
                执行 <code class="special">{cmd}</code> 。如果包含一个分割窗口的命令，那么将从当前窗口的左
                （垂直分割）或者上方（水平分割）分割窗口，而忽略 'splitbelow'
                和 'splitright' 的设置。

:rightb[elow] <code class="special">{cmd}</code>                             <b class="vimtag">*<a name=":rightb">:rightb</a>*</b> <b class="vimtag">*<a name=":rightbelow">:rightbelow</a>*</b>
:bel[owright] <code class="special">{cmd}</code>                             <b class="vimtag">*<a name=":bel">:bel</a>*</b> <b class="vimtag">*<a name=":belowright">:belowright</a>*</b>
                执行 <code class="special">{cmd}</code> 。 如果包含一个分割窗口的命令，那么将从当前窗口的右
                （垂直分割）或者下方（水平分割）分割窗口，而忽略 'splitbelow'
                和 'splitright' 的设置。

                                                <b class="vimtag">*<a name=":topleft">:topleft</a>*</b> <b class="vimtag">*<a name="E442">E442</a>*</b>
:to[pleft] <code class="special">{cmd}</code>
                执行 <code class="special">{cmd}</code> 。如果包含一个分割窗口的命令，那么该窗口出现在顶部，
                并且占据最大宽度。当垂直分割窗口时，窗口出现在最左边，并且占据
                最大高度。

                                                <b class="vimtag">*<a name=":botright">:botright</a>*</b>
:bo[tright] <code class="special">{cmd}</code>
                执行 <code class="special">{cmd}</code> 。如果包含一个分割窗口的命令，那么该窗口出现在底部，
                并且占据最大宽度。当垂直分割窗口时，窗口出现在最右边，并且占据
                最大高度。

这些修饰符可以结合使用来打开一个垂直分割的并且占据最大高度的窗口：
<code class="example">        :vertical topleft edit tags</code>
在 Vim 窗口最左边打开一个垂直分割的、最大高度的窗口，用来编辑 tags 文件。


关闭一个窗口
</pre><hr class="singleline" /><pre>

<code class="keystroke">CTRL-W</code> q                                                <b class="vimtag">*<a name="CTRL-W_q">CTRL-W_q</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-Q</code>                                           <b class="vimtag">*<a name="CTRL-W_CTRL-Q">CTRL-W_CTRL-Q</a>*</b>
:q[uit]         退出当前窗口。如果退出的是最后一个窗口（不包括帮助窗口），就会
                退出 Vim 。
                如果设置了 'hidden' 并且只有此一个窗口监视当前缓冲区，那么该缓
                冲区被隐藏。
                如果没有设置 'hidden'，并且只有当前这一个窗口监视该缓冲区，而
                且缓冲区被修改了，那么该命令不会成功。
                （<code class="note">注意</code>： <code class="keystroke">CTRL-Q</code> 不是在所有的终端下都好用）

:q[uit]!        退出当前窗口。如果这是缓冲区的最后一个窗口，那么对于此缓冲区的
                改动将全部丢失。如果退出的是最后一个窗口（不包括帮助窗口），就
                会退出 Vim 。缓冲区里的全部内容将丢失。即使设置了 'hidden' 选项
                也是如此。

<code class="keystroke">CTRL-W</code> c                                        <b class="vimtag">*<a name="CTRL-W_c">CTRL-W_c</a>*</b> <b class="vimtag">*<a name=":clo">:clo</a>*</b> <b class="vimtag">*<a name=":close">:close</a>*</b>
:clo[se][!]     关闭当前窗口。如果设置了 'hidden' ，或者改动了缓冲区但是命令里
                用了[!]，缓冲区会被隐藏。（除非还有一个窗口在编辑该缓冲区）。
                该命令在下述情况下会失败：                      <b class="vimtag">*<a name="E444">E444</a>*</b>
                - 只剩下最后一个窗口的时候。
                - 当 'hidden' 没有设置， 也没有用 [!] ，并且缓冲区也已经被修改，
                  而且也没有其它窗口监视该缓冲区的时候。对缓冲区的改动既不写入
                  文件，也不会丢失，所以这是个"安全"的命令。

<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-C</code>                                           <b class="vimtag">*<a name="CTRL-W_CTRL-C">CTRL-W_CTRL-C</a>*</b>
                你可能想用 <code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-C</code> 关闭当前窗口，但是这不行，因为 <code class="keystroke">CTRL-C</code>
                会撤消整个命令。

                                                        <b class="vimtag">*<a name=":hide">:hide</a>*</b>
:hid[e]         退出当前窗口，除非这是屏幕上的最后一个窗口。缓冲区被隐藏起来（
                除非还有另一个窗口正在编辑它，或者 'bufhidden' 设置为 "unload"
                或 "delete"）。 'hidden' 的值和这个命令没有一点关系。
                对缓冲区的改动既不写入文件，也不会丢失，所以这是个"安全"的命
                令。

:hid[e] <code class="special">{cmd}</code>   执行 <code class="special">{cmd}</code> 并设置 'hidden' 选项。<code class="special">{cmd}</code> 执行完毕后，先前的
                'hidden' 选项会被恢复。
                例如：
<code class="example">                    :hide edit Makefile</code>
                这条命令编辑 "Makefile" 文件，并且如果当前缓冲区有改动的话，隐
                藏之。

<code class="keystroke">CTRL-W</code> o                                                <b class="vimtag">*<a name="CTRL-W_o">CTRL-W_o</a>*</b> <b class="vimtag">*<a name="E445">E445</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-O</code>                                   <b class="vimtag">*<a name="CTRL-W_CTRL-O">CTRL-W_CTRL-O</a>*</b> <b class="vimtag">*<a name=":on">:on</a>*</b> <b class="vimtag">*<a name=":only">:only</a>*</b>
:on[ly][!]      使当前窗口成为屏幕上唯一的窗口。其它窗口都关闭。
                如果设置了 'hidden' 选项，被关闭窗口里的所有缓冲区变成隐藏。
                如果没有设置 'hidden' ，但是设置了 'autowrite' 选项，那么已经
                更改的缓冲区被写入文件。否则，那些包含被修改过的缓冲区的窗口不
                能被关闭，除非使用 [!] 强制关闭。于是缓冲区转入隐藏状态，对缓
                冲区的改动也不会丢失。

</pre><hr class="doubleline" /><pre>
<h4>4. 把光标移动到另一个窗口                       <b class="vimtag">*<a name="window-move-cursor">window-move-cursor</a>*</b></h4>
<code class="keystroke">CTRL-W</code> <code class="special">&lt;Down&gt;</code>                                   <b class="vimtag">*<a name="CTRL-W_%3CDown%3E">CTRL-W_&lt;Down&gt;</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-J</code>                                   <b class="vimtag">*<a name="CTRL-W_CTRL-J">CTRL-W_CTRL-J</a>*</b> <b class="vimtag">*<a name="CTRL-W_j">CTRL-W_j</a>*</b>
<code class="keystroke">CTRL-W</code> j        把光标向下移动 N 个窗口。用光标的位置在两个窗口之间做出选择。

<code class="keystroke">CTRL-W</code> <code class="special">&lt;Up&gt;</code>                                     <b class="vimtag">*<a name="CTRL-W_%3CUp%3E">CTRL-W_&lt;Up&gt;</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-K</code>                                   <b class="vimtag">*<a name="CTRL-W_CTRL-K">CTRL-W_CTRL-K</a>*</b> <b class="vimtag">*<a name="CTRL-W_k">CTRL-W_k</a>*</b>
<code class="keystroke">CTRL-W</code> k        把光标向上移动 N 个窗口。用光标的位置在两个窗口之间做出选择。

<code class="keystroke">CTRL-W</code> <code class="special">&lt;Left&gt;</code>                                   <b class="vimtag">*<a name="CTRL-W_%3CLeft%3E">CTRL-W_&lt;Left&gt;</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-H</code>                                   <b class="vimtag">*<a name="CTRL-W_CTRL-H">CTRL-W_CTRL-H</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="special">&lt;BS&gt;</code>                                     <b class="vimtag">*<a name="CTRL-W_%3CBS%3E">CTRL-W_&lt;BS&gt;</a>*</b> <b class="vimtag">*<a name="CTRL-W_h">CTRL-W_h</a>*</b>
<code class="keystroke">CTRL-W</code> h        把光标向左移动 N 个窗口。用光标的位置在两个窗口之间做出选择。

<code class="keystroke">CTRL-W</code> <code class="special">&lt;Right&gt;</code>                                  <b class="vimtag">*<a name="CTRL-W_%3CRight%3E">CTRL-W_&lt;Right&gt;</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-L</code>                                   <b class="vimtag">*<a name="CTRL-W_CTRL-L">CTRL-W_CTRL-L</a>*</b> <b class="vimtag">*<a name="CTRL-W_l">CTRL-W_l</a>*</b>
<code class="keystroke">CTRL-W</code> l        把光标向左移动 N 个窗口。  用光标的位置在两个窗口之间做出选择。

<code class="keystroke">CTRL-W</code> w                                        <b class="vimtag">*<a name="CTRL-W_w">CTRL-W_w</a>*</b> <b class="vimtag">*<a name="CTRL-W_CTRL-W">CTRL-W_CTRL-W</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-W</code>   如果没有添加计数器，则将光标移动到当前窗口的右/下方的窗口。如
                果右下方没有窗口，就移动到左上角的窗口。要是添加了计数器，就移
                动到第 N 个窗口（从左上方到右下方依次计数）。窗口号码可以通过
                |<a href="eval.html#bufwinnr()">bufwinnr()</a>| 和 |<a href="eval.html#winnr()">winnr()</a>| 来获得。

                                                <b class="vimtag">*<a name="CTRL-W_W">CTRL-W_W</a>*</b>
<code class="keystroke">CTRL-W</code> W        如果没有添加计数器，则将光标移动到当前窗口的左/上方的窗口。如
                果左上方没有窗口，就移动到右下角的窗口。要是添加了计数器，就移
                动到第 N 个窗口（从左上方到右下方依次计数）。

<code class="keystroke">CTRL-W</code> t                                        <b class="vimtag">*<a name="CTRL-W_t">CTRL-W_t</a>*</b> <b class="vimtag">*<a name="CTRL-W_CTRL-T">CTRL-W_CTRL-T</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-T</code>   把光标移动到左上角的窗口。

<code class="keystroke">CTRL-W</code> b                                        <b class="vimtag">*<a name="CTRL-W_b">CTRL-W_b</a>*</b> <b class="vimtag">*<a name="CTRL-W_CTRL-B">CTRL-W_CTRL-B</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-B</code>   把光标移动到右下角的窗口。

<code class="keystroke">CTRL-W</code> p                                        <b class="vimtag">*<a name="CTRL-W_p">CTRL-W_p</a>*</b> <b class="vimtag">*<a name="CTRL-W_CTRL-P">CTRL-W_CTRL-P</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-P</code>   移动到前一个 (previous)（上次访问的）窗口。

                                                <b class="vimtag">*<a name="CTRL-W_P">CTRL-W_P</a>*</b> <b class="vimtag">*<a name="E441">E441</a>*</b>
<code class="keystroke">CTRL-W</code> P        移动到前一个窗口。如果没有前一个窗口就会出错。
                <code class="special">{如果编译时没有加入 |<a href="various.html#+quickfix">+quickfix</a>| 则不可用}</code>

在"可视"模式（Visual）下，如果窗口编辑的是同一个缓冲区，则光标所选择的区域会
被保留；如果不是同一个缓冲区，则终止"可视"模式。

                                                <b class="vimtag">*<a name=":winc">:winc</a>*</b> <b class="vimtag">*<a name=":wincmd">:wincmd</a>*</b>
这些命令也可以用 ":wincmd" 来执行：

:<code class="special">[count]</code>winc[md] <code class="special">{arg}</code>
                与 <code class="keystroke">CTRL-W</code> <code class="special">[count]</code> <code class="special">{arg}</code> 相同。例如：
<code class="example">                        :wincmd j</code>
                把光标移动到当前窗口下面的窗口。
                这个命令在普通模式不可用的时候（比如在 |<a href="autocmd.html#CursorHold">CursorHold</a>| 自动命
                令执行的时候），或者在启用普通模式不方便时，特别好用。
                计数器也可以是一个窗口号码。例如:
<code class="example">                        :exe nr . "wincmd w"</code>
                这会切换到窗口 "nr"。

</pre><hr class="doubleline" /><pre>
<h4>5. 窗口的移动                                   <b class="vimtag">*<a name="window-moving">window-moving</a>*</b></h4>
<code class="keystroke">CTRL-W</code> r                                <b class="vimtag">*<a name="CTRL-W_r">CTRL-W_r</a>*</b> <b class="vimtag">*<a name="CTRL-W_CTRL-R">CTRL-W_CTRL-R</a>*</b> <b class="vimtag">*<a name="E443">E443</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-R</code>   向右下方向移动窗口。第一个窗口变成第二个，第二个变成第三个……
                最后一个变成第一个。光标保留在相同窗口里。
                本操作只能移动同行或同列的窗口。

                                                <b class="vimtag">*<a name="CTRL-W_R">CTRL-W_R</a>*</b>
<code class="keystroke">CTRL-W</code> R        向左上方向移动窗口。第一个窗口变成第二个，第二个变成第三个……
                最后一个变成第一个。光标保留在相同窗口里。
                本操作只能移动同行或同列的窗口。

<code class="keystroke">CTRL-W</code> x                                        <b class="vimtag">*<a name="CTRL-W_x">CTRL-W_x</a>*</b> <b class="vimtag">*<a name="CTRL-W_CTRL-X">CTRL-W_CTRL-X</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-X</code>   若没有计数器：交换当前窗口与下一个窗口。如果没有下一个窗口，则
                与前一个窗口交换。
                若有计数器：交换当前窗口与第 N 个窗口（第一个窗口为 1 ）。
                光标被放置在另一个窗口里。
                如果既有垂直分割又有水平分割，那么只能与当前窗口同行或者同列的
                窗口进行交换。

下面的几个命令可以被用来改变窗口的布局。例如，<code class="keystroke">CTRL-W</code> K 可以把两个垂直分割的窗
口变成水平分割的窗口。<code class="keystroke">CTRL-W</code> H 则正好相反。

                                                <b class="vimtag">*<a name="CTRL-W_K">CTRL-W_K</a>*</b>
<code class="keystroke">CTRL-W</code> K        把当前窗口放到最顶端，并且是最大宽度。这很像在关闭当前窗口之后，
                再用 ":topleft split" 打开一个新的窗口，不过新窗口只包含当前窗
                口的内容。

                                                <b class="vimtag">*<a name="CTRL-W_J">CTRL-W_J</a>*</b>
<code class="keystroke">CTRL-W</code> J        把当前窗口放到最底部，并且是最大宽度。这很像在关闭当前窗口之后，
                再用 ":botright split" 打开一个新的窗口，不过新窗口只包含当前
                窗口的内容。

                                                <b class="vimtag">*<a name="CTRL-W_H">CTRL-W_H</a>*</b>
<code class="keystroke">CTRL-W</code> H        把当前窗口放到最左边，并且是最大高度。这很像在关闭当前窗口之后，
                再用 ":vert topleft split" 打开一个新的窗口，不过新窗口只包含
                当前窗口的内容。
                <code class="special">{如果编译时没有加入 +vertsplit 属性则不可用}</code>

                                                <b class="vimtag">*<a name="CTRL-W_L">CTRL-W_L</a>*</b>
<code class="keystroke">CTRL-W</code> L        把当前窗口放到最右边，并且是最大高度。这很像在关闭当前窗口之后，
                再用 ":vert botright split" 打开一个新的窗口，不过新窗口只包含
                当前窗口的内容。
                <code class="special">{如果编译时没有加入 +vertsplit 属性则不可用}</code>

</pre><hr class="doubleline" /><pre>
<h4>6. 改变窗口的大小                                       <b class="vimtag">*<a name="window-resize">window-resize</a>*</b></h4>
                                                <b class="vimtag">*<a name="CTRL-W_%20">CTRL-W_=</a>*</b>
<code class="keystroke">CTRL-W</code> =        使得（几乎）所有窗口等宽、等高，但是对当前窗口使用 'winheight'
                和 'winwidth' 来设置。

:res[ize] -N                                    <b class="vimtag">*<a name=":res">:res</a>*</b> <b class="vimtag">*<a name=":resize">:resize</a>*</b> <b class="vimtag">*<a name="CTRL-W_-">CTRL-W_-</a>*</b>
<code class="keystroke">CTRL-W</code> -        使得当前窗口高度减 N （默认值是 1）。
                如果在 'vertical' 之后使用，则使得宽度减 N 。

:res[ize] +N                                    <b class="vimtag">*<a name="CTRL-W_+">CTRL-W_+</a>*</b>
<code class="keystroke">CTRL-W</code> +        使得当前窗口高度加 N （默认值是 1）。
                如果在 'vertical' 之后使用，则使得宽度加 N 。

:res[ize] [N]
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-_</code>                                   <b class="vimtag">*<a name="CTRL-W_CTRL-_">CTRL-W_CTRL-_</a>*</b> <b class="vimtag">*<a name="CTRL-W__">CTRL-W__</a>*</b>
<code class="keystroke">CTRL-W</code> _        设置当前窗口的高度为 N （默认值为可能的最大值）。

z<code class="special">{nr}</code><code class="special">&lt;CR&gt;</code>       设置当前窗口的高度为 <code class="special">{nr}</code> 。

                                                <b class="vimtag">*<a name="CTRL-W_%3C">CTRL-W_&lt;</a>*</b>
<code class="keystroke">CTRL-W</code> &lt;        使得当前窗口宽度减 N （默认值是 1）。

                                                <b class="vimtag">*<a name="CTRL-W_%3E">CTRL-W_&gt;</a>*</b>
<code class="keystroke">CTRL-W</code> &gt;        使得当前窗口宽度加 N （默认值是 1）。

:vertical res[ize] [N]                  <b class="vimtag">*<a name=":vertical-resize">:vertical-resize</a>*</b> <b class="vimtag">*<a name="CTRL-W_bar">CTRL-W_bar</a>*</b>
<code class="keystroke">CTRL-W</code> |        设置当前窗口的宽度为 N （默认值为可能的最大值）。

你也可以用鼠标上下拖动水平分割栏来改变窗口的高度，或者左右拖动垂直分割栏来改变
窗口宽度。这些功能只有在支持鼠标的版本里，并且设置了 'mouse' 选项才可以用。

选项 'winheight' ('wh') 用来设置当前窗口的最小高度。每当其它窗口变为当前窗口的
时候，这一选项就会生效。如果设置为 0 ，则禁用。把 'winheight' 设一个很大的值，
例如，'9999'，就使得当前窗口永远占据尽可能大的空间。尽量设置成一个编辑时比较
舒服的值，比如说， '10' 就是一个合理的值。

同样，'winwidth' ('wiw') 选项设定了当前窗口的最小宽度。

如果设置了 'equalalways' ('ea') 选项，在分割或者关闭窗口之后，所有窗口都会变为
相同大小。如果你没有设置这个选项，分割窗口时只会减少当前窗口的大小，而其它窗口
保持不变。当关闭窗口时，多出来的行会被上面的窗口占用。

选项 'eadirection' 用来限制 'equalalways' 的作用方向。默认值是 "both" ，两个方
向都改变。当设置为 "ver" 时，只限制所有窗口的高度必须相同，这样你可以自己调节
窗口的宽度。同样，"hor" 使得窗口的宽度都相等。

选项 'cmdheight' ('ch') 用来设置命令行的高度。如果你对 |<a href="message.html#hit-enter">hit-enter</a>| 的提示信息
感到厌烦，可以将它设置为 2 或 3 。

如果只有一个窗口，那么改变该窗口大小的同时也会改变命令行的高度。如果有多个窗口，
那么改变当前窗口的大小也会改变它下面的窗口（有时是上面的窗口）的高度。

一个窗口的最小高度和最小宽度可以用 'winminheight' 和 'winminwidth' 设定。这是
硬性值，一旦设定，窗口的高度（或宽度）将不能小于该值。

</pre><hr class="doubleline" /><pre>
<h4>7. 参数和缓冲区的列表命令                       <b class="vimtag">*<a name="buffer-list">buffer-list</a>*</b></h4>
<code class="section">      参数列表                缓冲区列表           含义 </code>
1. :[N]argument [N]     11. :[N]buffer [N]      切换至第 N 号参数/缓冲区
2. :[N]next [file ..]   12. :[N]bnext [N]       切换至向后数第 N 个参数/缓冲区
3. :[N]Next [N]         13. :[N]bNext [N]       切换至向前数第 N 个参数/缓冲区
4. :[N]previous [N]     14. :[N]bprevious [N]   切换至向前数第 N 个参数/缓冲区
5. :rewind / :first     15. :brewind / :bfirst  切换至第一个参数/缓冲区
6. :last                16. :blast              切换至最后一个参数/缓冲区
7. :all                 17. :ball               编辑所有的参数/缓冲区
                        18. :unhide             编辑所有已载入的缓冲区
                        19. :[N]bmod [N]        切换至第 N 个已修改的缓冲区

<code class="section">  分割 &amp; 参数列表        分割 &amp; 缓冲区列表         含义 </code>
21. :[N]sargument [N]   31. :[N]sbuffer [N]      分割 + 切换至第 N 号参数/缓冲区
22. :[N]snext [file ..] 32. :[N]sbnext [N]       分割 + 切换至向后数第 N 个参数/缓冲区
23. :[N]sNext [N]       33. :[N]sbNext [N]       分割 + 切换至向前数第 N 个参数/缓冲区
24. :[N]sprevious [N]   34. :[N]sbprevious [N]   分割 + 切换至向前数第 N 个参数/缓冲区
25. :srewind / :sfirst  35. :sbrewind / :sbfirst 分割 + 切换至第一个参数/缓冲区
26. :slast              36. :sblast              分割 + 切换至最后一个参数/缓冲区
27. :sall               37: :sball               编辑所有的参数/缓冲区
                        38. :sunhide             编辑所有已载入的缓冲区
                        39. :[N]sbmod [N]        分割 + 切换至第 N 个已修改的缓冲区

40. :args               显示参数列表
41. :buffers            显示缓冲区列表

上述命令中的 [N] 的含义取决于你使用的命令：
 [N] 在命令 ?2，?3，和 ?4 中是向前/向后的个数。
 [N] 在命令 1 和 21 中是参数号码，默认值是当前参数。
 [N] 在命令 11 和 31 中是缓冲区号码，默认值是当前缓冲区。
 [N] 在命令 19 和 39 中计数器。

<code class="note">备注</code>: ":next" 是一个例外，因为它必须以文件名列表为参数，这是为了和 Vi 兼容。


参数列表和多窗口
</pre><hr class="singleline" /><pre>

每一个窗口所编辑的文件可能位于参数列表的不同位置。记住！当 ":e file" 一个文件
时，你在参数列表中的位置没有变化，但你并不是在编辑处于那个位置的文件。为了说明
这一点，文件消息（和标题栏，如果有的话）会显示 "(file (N) of M)"，"(N)" 是当前
文件在列表中的位置，"M" 是列表中文件的数量。

所有参数列表中的条目都被加载到缓冲区列表中，这样你也可以用缓冲区列表的命令进行
操作，比如 ":bnext" 。

:[N]al[l][!] [N]                                <b class="vimtag">*<a name=":al">:al</a>*</b> <b class="vimtag">*<a name=":all">:all</a>*</b> <b class="vimtag">*<a name=":sal">:sal</a>*</b> <b class="vimtag">*<a name=":sall">:sall</a>*</b>
:[N]sal[l][!] [N]
                重新整理屏幕，为每一个参数打开一个窗口。其它窗口统统关闭。如果
                使用了计数器，则其数值为窗口数目的最大值。
                如果设置了 'hidden'，所有要关闭的窗口变为隐藏。
                如果没有设置 'hidden'，但是设置了 'autowrite' ，那么所有改动
                的缓冲区被写入文件。否则，包含更改过的缓冲区的窗口不会被删除，
                除非你用 [!] 使它们隐藏。更改过的缓冲区永远不会被丢弃，所以改
                动不会丢失。
                [N] 是最大可以打开的窗口数。'winheight' 也限制打开的窗口数。
                (如果前加了 |<a href="windows.html#:vertical">:vertical</a>| 的话 'winwidth')。
                Buf/Win Enter/Leave 自动命令不会被这里的新窗口执行，只有在它
                们真正进入时才会执行。

:[N]sa[rgument][!] [++opt] [+cmd] [N]                   <b class="vimtag">*<a name=":sa">:sa</a>*</b> <b class="vimtag">*<a name=":sargument">:sargument</a>*</b>
                这是 ":split | argument [N]" 命令的简写。分割窗口并切换至第 N
                号参数。但是如果该参数不存在，窗口也不会分割。参见 |<a href="editing.html#++opt">++opt</a>| 和
                |<a href="editing.html#+cmd">+cmd</a>| 。

:[N]sn[ext][!] [++opt] [+cmd] [file ..]                 <b class="vimtag">*<a name=":sn">:sn</a>*</b> <b class="vimtag">*<a name=":snext">:snext</a>*</b>
                这是 ":split | [N]next" 命令的简写。 分割窗口并切换到向后数第
                N 个参数。 但是如果该参数不存在，窗口也不会分割。参见 |<a href="editing.html#++opt">++opt</a>|
                和 |<a href="editing.html#+cmd">+cmd</a>| 。

:[N]spr[evious][!] [++opt] [+cmd] [N]                   <b class="vimtag">*<a name=":spr">:spr</a>*</b> <b class="vimtag">*<a name=":sprevious">:sprevious</a>*</b>
:[N]sN[ext][!] [++opt] [+cmd] [N]                       <b class="vimtag">*<a name=":sN">:sN</a>*</b> <b class="vimtag">*<a name=":sNext">:sNext</a>*</b>
                这是 ":split | [N]Next" 命令的简写。 分割窗口并切换到向前数第
                N 个参数。 但是如果该参数不存在，窗口也不会分割。参见 |<a href="editing.html#++opt">++opt</a>|
                和 |<a href="editing.html#+cmd">+cmd</a>| 。

                                                <b class="vimtag">*<a name=":sre">:sre</a>*</b> <b class="vimtag">*<a name=":srewind">:srewind</a>*</b>
:sre[wind][!] [++opt] [+cmd]
                这是 ":split | rewind" 命令的简写。分割窗口并切换到第一个参数。
                但是如果没有参数列表，窗口不会分割。参见 |<a href="editing.html#++opt">++opt</a>| 和 |<a href="editing.html#+cmd">+cmd</a>| 。

                                                <b class="vimtag">*<a name=":sfir">:sfir</a>*</b> <b class="vimtag">*<a name=":sfirst">:sfirst</a>*</b>
:sfir[st [++opt] [+cmd]
                与 ":srewind" 相同。

                                                <b class="vimtag">*<a name=":sla">:sla</a>*</b> <b class="vimtag">*<a name=":slast">:slast</a>*</b>
:sla[st][!] [++opt] [+cmd]
                这是 ":split | rewind" 命令的简写。分割窗口并切换到最后一个参
                数。 但是如果没有参数列表，窗口不会分割。参见 |<a href="editing.html#++opt">++opt</a>| 和
                |<a href="editing.html#+cmd">+cmd</a>| 。
                                                <b class="vimtag">*<a name=":dr">:dr</a>*</b> <b class="vimtag">*<a name=":drop">:drop</a>*</b>
:dr[op] <code class="special">{file}</code> ..
                在一个窗口内编辑第一个 <code class="special">{file}</code>。
                － 如果该文件已经被打开，切换至该文件所在窗口。
                － 如果该文件尚未被打开，在当前窗口内打开该文件。如果当前窗口
                   无法被放弃 |<a href="editing.html#abandon">abandon</a>|，窗口会先被分割。
                参数列表 |<a href="editing.html#argument-list">argument-list</a>| 会被象使用 |<a href="editing.html#:next">:next</a>| 命令一样被设定。
                此命令的目的在于：允许 debugger 之类的程序里让 Vim 编辑另一个文件。
                <code class="special">{只有在编译时加入 +gui 才可用}</code>

</pre><hr class="doubleline" /><pre>
<h4>8. 在所有的缓冲区和窗口里执行命令                       <b class="vimtag">*<a name="list-repeat">list-repeat</a>*</b></h4>
                                                        <b class="vimtag">*<a name=":windo">:windo</a>*</b>
:windo[!] <code class="special">{cmd}</code>         在每一个窗口里执行 <code class="special">{cmd}</code> 。
                        这就像是：
<code class="example">                                <code class="keystroke">CTRL-W</code> t</code>
<code class="example">                                :<code class="special">{cmd}</code></code>
<code class="example">                                <code class="keystroke">CTRL-W</code> w</code>
<code class="example">                                :<code class="special">{cmd}</code></code>
<code class="example">                                etc.</code>
<code class="example">                                等等……</code>
                        如果在一个窗口里检测到错误，余下的窗口没有被访问到。最后
                        一个窗口（或者出错的那个窗口）会变为当前窗口。
                        <code class="special">{cmd}</code> 可以包含 '|' 来连接多个命令。
                        <code class="special">{cmd}</code> 不能打开或关闭窗口，也不能重新装载它们。
                        <code class="special">{Vi 不可用}</code> <code class="special">{若编译时没有加入 |<a href="various.html#+listcmds">+listcmds</a>| 则不可用}</code>
                        也参见 |<a href="editing.html#:argdo">:argdo</a>| 和 |<a href="windows.html#:bufdo">:bufdo</a>|.

                                                        <b class="vimtag">*<a name=":bufdo">:bufdo</a>*</b>
:bufdo[!] <code class="special">{cmd}</code>         在每一个缓冲区里执行 <code class="special">{cmd}</code>。
                        就像是：
<code class="example">                                :bfirst</code>
<code class="example">                                :<code class="special">{cmd}</code></code>
<code class="example">                                :bnext</code>
<code class="example">                                :<code class="special">{cmd}</code></code>
<code class="example">                                等等……</code>
                        如果当前文件不能被丢弃 |<a href="editing.html#abandon">abandon</a>|，并且没有使用[!]，命令
                        会失败。
                        当在一个缓冲区里检测到错误，剩下的缓冲区不会被访问。
                        没有在列表里出现的缓冲区被略过。
                        最后一个缓冲区（或者出错的那个缓冲区）将变为当前缓冲区。
                        <code class="special">{cmd}</code> 可以包含 '|' 来连接多个命令。
                        <code class="special">{cmd}</code> 不能删除或添加缓冲区。
                        <code class="note">备注</code>: 当这个命令正在执行的时候，自动命令的语法事件可以
                        通过 'eventignore' 禁止。这样会加快编辑缓冲区的速度。
                        <code class="special">{Vi 不可用}</code> <code class="special">{若编译时没有加入 |<a href="various.html#+listcmds">+listcmds</a>| 则不可用}</code>
                        参见 |<a href="editing.html#:argdo">:argdo</a>| 和 |<a href="windows.html#:windo">:windo</a>| 。

例子：
<code class="example"></code>
<code class="example">        :windo set nolist nofoldcolumn | normal zn</code>
<code class="example"></code>
这个命令会复位 'list' 选项并在所有的窗口里关闭折叠功能。
<code class="example"></code>
<code class="example">        :bufdo set fileencoding= | update</code>
<code class="example"></code>
此命令在每个缓冲区里复位 'fileencoding' 选项的值，并将改动的缓冲区存盘。结果是所
有的缓冲区用 'encoding' 编码（如果执行顺利的话）。

</pre><hr class="doubleline" /><pre>
<h4>9. 当前光标处的标签和文件名                             <b class="vimtag">*<a name="window-tag">window-tag</a>*</b></h4>
                                                        <b class="vimtag">*<a name=":sta">:sta</a>*</b> <b class="vimtag">*<a name=":stag">:stag</a>*</b>
:sta[g][!] [tagname]
                执行 ":tag[!] [tagname]" 并且分割窗口打开新的标记。参见 |<a href="tagsrch.html#:tag">:tag</a>|。

<code class="keystroke">CTRL-W</code> ]                                        <b class="vimtag">*<a name="CTRL-W_]">CTRL-W_]</a>*</b> <b class="vimtag">*<a name="CTRL-W_CTRL-]">CTRL-W_CTRL-]</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-]</code>   把当前窗口一分为二，把光标所位置的标识符当作标记，并跳转至标记
                所指向的地方。新窗口（上面的窗口）的高度为 N。

                                                        <b class="vimtag">*<a name="CTRL-W_g]">CTRL-W_g]</a>*</b>
<code class="keystroke">CTRL-W</code> g ]      把当前窗口一分为二，把光标所位置的标识符当作标记，并在新窗口（
                上面的窗口）里执行 ":tselect" 。新窗口的高度为 N 。

                                                        <b class="vimtag">*<a name="CTRL-W_g_CTRL-]">CTRL-W_g_CTRL-]</a>*</b>
<code class="keystroke">CTRL-W</code> g <code class="keystroke">CTRL-]</code> 把当前窗口一分为二，把光标所位置的标识符当作标记，并在新窗口（
                上面的窗口）里执行 ":tjump" 。新窗口的高度为 N 。

<code class="keystroke">CTRL-W</code> f                                        <b class="vimtag">*<a name="CTRL-W_f">CTRL-W_f</a>*</b> <b class="vimtag">*<a name="CTRL-W_CTRL-F">CTRL-W_CTRL-F</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-F</code>   把当前窗口一分为二。编辑光标下的文件名。
                类似 ":split ]f"，但是找不到文件或者文件不存在时，不会分割窗口。
                此操作在 'path' 变量所定义的目录和当前文件所在的目录里寻找文件。
                如果是一个类似 "type://machine/path" 的超链接，那么只使用
                "/path"。
                如果指定了计数器 N ，那么编辑第 N 个匹配的文件。
                <code class="special">{如果 |<a href="various.html#+file_in_path">+file_in_path</a>| 在编译时被禁用，则不可用}</code>

参见 |<a href="tagsrch.html#CTRL-W_CTRL-I">CTRL-W_CTRL-I</a>|：为包含文件打开一个窗口（该文件包含当前光标下的关键字）。

</pre><hr class="doubleline" /><pre>
<h4>10. 预览窗口                            <b class="vimtag">*<a name="preview-window">preview-window</a>*</b></h4>
预览窗口是预览其它文件的特殊窗口。它通常是一个用来查看包含文件或者函数定义的小
窗口。 <code class="special">{若编译时未加入 |<a href="various.html#+quickfix">+quickfix</a>| 属性，则不可用}</code>

只能有一个预览窗口，可以用如下命令之一创建。选项 'previewheight' 可以用来指定
预览窗口的高度；选项 'previewwindow' 会在预览窗口内被设定以便区分。
'winfixheight' 选项也被设定用来保持该窗口的高度不受其它窗口的影响。

                                                <b class="vimtag">*<a name=":pta">:pta</a>*</b> <b class="vimtag">*<a name=":ptag">:ptag</a>*</b>
:pta[g][!] [tagname]
                执行 ":tag[!] [tagname]" 并且在预览窗口里显示标签所指向的内容。
                不改变当前缓冲区和光标的位置。如果预览窗口已经打开，则会被再
                次使用（类似于帮助窗口）。如果是打开一个新的预览窗口，那么其高
                度由 'previewheight' 决定。也参见 |<a href="tagsrch.html#:tag">:tag</a>| 。参考下面的例子。
                |<a href="windows.html#CursorHold-example">CursorHold-example</a>|
                与 |<a href="tagsrch.html#:tag">:tag</a>| 有细小的差别: 当 [tagname] 与当前显示的标记相同时，
                该命令不会重置"标记匹配列表"的当前位置。这使得在执行完
                |<a href="tagsrch.html#:ptnext">:ptnext</a>| 后，|<a href="windows.html#CursorHold-example">CursorHold-example</a>| 仍可以运行。

<code class="keystroke">CTRL-W</code> z                                        <b class="vimtag">*<a name="CTRL-W_z">CTRL-W_z</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-Z</code>                                   <b class="vimtag">*<a name="CTRL-W_CTRL-Z">CTRL-W_CTRL-Z</a>*</b> <b class="vimtag">*<a name=":pc">:pc</a>*</b> <b class="vimtag">*<a name=":pclose">:pclose</a>*</b>
:pc[lose][!]    关闭当前打开的预览窗口。如果设置了 'hidden' ，或者更改了缓冲区
                并且使用了 [!]，则缓冲区变为隐藏（除非还有其它窗口正在编辑该
                缓冲区）。如果预览窗口的缓冲区不能关闭，此命令失败。也参见
                |<a href="windows.html#:close">:close</a>|.

                                                        <b class="vimtag">*<a name=":pp">:pp</a>*</b> <b class="vimtag">*<a name=":ppop">:ppop</a>*</b>
:<code class="special">[count]</code>pp[op][!]
                在预览窗口执行 ":<code class="special">[count]</code>pop[!]" 。参见 |<a href="tagsrch.html#:pop">:pop</a>| 和 |<a href="windows.html#:ptag">:ptag</a>| 。
                <code class="special">{Vi 没有此功能}</code>

<code class="keystroke">CTRL-W</code> }                                                <b class="vimtag">*<a name="CTRL-W_}">CTRL-W_}</a>*</b>
                使用当前光标所处位置的标识符作为标签，执行 :ptag 。生成预览窗
                口（如果需要的话），窗口的高度为 N，如果没指定高度，就使用
                'previewheight' 的值。

<code class="keystroke">CTRL-W</code> g }                                              <b class="vimtag">*<a name="CTRL-W_g}">CTRL-W_g}</a>*</b>
                使用当前光标所处位置的标识符作为标签，执行 :ptjump 。生成预览
                窗口（如果需要的话），窗口的高度为 N，如果没指定高度，就使用
                'previewheight' 的值。

                                                        <b class="vimtag">*<a name=":ped">:ped</a>*</b> <b class="vimtag">*<a name=":pedit">:pedit</a>*</b>
:ped[it][!] [++opt] [+cmd] <code class="special">{file}</code>
                在预览窗口里编辑文件 <code class="special">{file}</code> 。预览窗口就像是用 |<a href="windows.html#:ptag">:ptag</a>| 命令打
                开的。当前窗口和光标的位置都不改变。一个有用的例子：
<code class="example">                        :pedit +/fputc /usr/include/stdio.h</code>

                                                        <b class="vimtag">*<a name=":ps">:ps</a>*</b> <b class="vimtag">*<a name=":psearch">:psearch</a>*</b>
:<code class="special">[range]</code>ps[earch][!] <code class="special">[count]</code> [/]pattern[/]
                与 |<a href="tagsrch.html#:ijump">:ijump</a>| 命令很像，只是找到匹配的在预览窗口显示。预览窗口用
                |<a href="windows.html#:ptag">:ptag</a>| 打开。 当前窗口和光标的位置都不改变。有用的例子：
<code class="example">                        :psearch popen</code>
                这很像 |<a href="windows.html#:ptag">:ptag</a>| 命令，你可以用它自动显示光标所在单词的相关信息。
                这个命令虽然不如 |<a href="windows.html#:ptag">:ptag</a>| 强大，但是你可以不使用标记文件，而且
                它也可以找到一些系统的头文件。例如：

<code class="example">  :au! CursorHold *.[ch] nested exe "silent! psearch " . expand("<code class="special">&lt;cword&gt;</code>")</code>
                警告：可能会很慢。

例子                                            <b class="vimtag">*<a name="CursorHold-example">CursorHold-example</a>*</b>
<code class="example"></code>
<code class="example">  :au! CursorHold *.[ch] nested exe "silent! ptag " . expand("<code class="special">&lt;cword&gt;</code>")</code>
<code class="example"></code>
这条命令以当前光标位置处的关键字为参数，执行 ":ptag" 命令。'updatetime' 指定了
光标停留的时间；"nested" 使得自动命令得以执行，这样可以在预览窗口里启用语法加
亮。"silent!" 屏蔽了在找不到标签时产生的错误信息。也参见 |<a href="autocmd.html#CursorHold">CursorHold</a>| 。要禁用
此功能：
<code class="example"></code>
<code class="example">  :au! CursorHold</code>
<code class="example"></code>
另一个比较好用的功能是加亮已经找到的标签，这样可以避免对光标处没有定义的单词执
行 ":ptag"，和一些别的东西：
<code class="example"></code>
<code class="example">  :au! CursorHold *.[ch] nested call PreviewWord()</code>
<code class="example">  :func PreviewWord()</code>
<code class="example">  :  if &amp;previewwindow                  " 不要在预览窗口里执行</code>
<code class="example">  :    return</code>
<code class="example">  :  endif</code>
<code class="example">  :  let w = expand("<code class="special">&lt;cword&gt;</code>")          " 在当前光标位置抓词</code>
<code class="example">  :  if w =~ '\a'                       " 如果该单词包括一个字母</code>
<code class="example">  :</code>
<code class="example">  :    " 在显示下一个标签之前，删除所有现存的语法加亮</code>
<code class="example">  :    silent! wincmd P                 " 跳转至预览窗口</code>
<code class="example">  :    if &amp;previewwindow                        " 如果确实转到了预览窗口……</code>
<code class="example">  :      match none                     " 删除语法加亮</code>
<code class="example">  :      wincmd p                       " 回到原来的窗口</code>
<code class="example">  :    endif</code>
<code class="example">  :</code>
<code class="example">  :    " 试着显示当前光标处匹配的标签</code>
<code class="example">  :    try</code>
<code class="example">  :       exe "ptag " . w</code>
<code class="example">  :    catch</code>
<code class="example">  :      return</code>
<code class="example">  :    endtry</code>
<code class="example">  :</code>
<code class="example">  :    silent! wincmd P                 " 跳转至预览窗口</code>
<code class="example">  :    if &amp;previewwindow                " 如果确实转到了预览窗口……</code>
<code class="example">  :      if has("folding")</code>
<code class="example">  :        silent! .foldopen            " 展开折叠的行</code>
<code class="example">  :      endif</code>
<code class="example">  :      call search("$", "b")          " 到前一行的行尾</code>
<code class="example">  :      let w = substitute(w, '\\', '\\\\', "")</code>
<code class="example">  :      call search('\<code class="special">&lt;\V' . w . '\&gt;</code>') " 把光标放置匹配的单词上</code>
<code class="example">  :      " 在此位置对匹配的单词加亮</code>
<code class="example">  :      hi previewWord term=bold ctermbg=green guibg=green</code>
<code class="example">  :      exe 'match previewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'</code>
<code class="example">  :      wincmd p                       " 返回原来的窗口</code>
<code class="example">  :    endif</code>
<code class="example">  :  endif</code>
<code class="example">  :endfun</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>11. 使用隐藏的缓冲区                                    <b class="vimtag">*<a name="buffer-hidden">buffer-hidden</a>*</b></h4>
隐藏的缓冲区已经载入内存，但是不会显示在窗口里。这使得 Vim 每次从一个文件切换
到另一个文件时，不必频繁地读写磁盘。 <code class="special">{若编译时没加入 |<a href="various.html#+listcmds">+listcmds</a>| ，则不可用}</code>

                                                        <b class="vimtag">*<a name=":buffer-!">:buffer-!</a>*</b>
如果设置了 'hidden' ('hid')，那么被丢弃的缓冲区会记忆你在 ":edit"， ":next"，
":tag"，等命令之后进行的所有操作。虽然有时没有设置 'hidden'，但是有一些作用于
缓冲区列表的命令还是会把当前窗口变为隐藏。这种情况发生在：当 'autowrite' 选项
是关闭的或者缓冲区不可保存时，你试图用 '!' 强制删除一个修改过的缓冲区窗口。

你可以用任何编辑命令使隐藏的缓冲区不再隐藏。或者用 ":bdelete" 命令将其删除。

'hidden' 是全局选项， 它作用于所有的缓冲区。'bufhidden' 选项可以作用于指定的缓
冲区，该选项可以是下面的值：

        <code class="special">&lt;empty&gt;</code>         使用 'hidden' 的值。
        hide            隐藏该缓冲区，也适合于 'hidden' 没有设置的情况。
        unload          不隐藏，而是卸载该缓冲区，也适合于设置了 'hidden' 的情
                        况。
        delete          删除该缓冲区。

                                                        <b class="vimtag">*<a name="hidden-quit">hidden-quit</a>*</b>
如果存在一个隐含的，并且被修改过的缓冲区，若此时退出 Vim 会得到一条错误信息，
并且 Vim 会把该缓冲区变为当前的缓冲区。你可以决定是保存（":wq"）还是退出（
":q!"）。<code class="note">注意</code>：可能不止一个隐藏的并且已被修改的缓冲区！

缓冲区也可能是非列表的（unlisted），这意味着此缓冲区存在，但是从缓冲区列表中看
不到。|<a href="windows.html#unlisted-buffer">unlisted-buffer</a>|


:files[!]                                       <b class="vimtag">*<a name=":files">:files</a>*</b>
:buffers[!]                                     <b class="vimtag">*<a name=":buffers">:buffers</a>*</b> <b class="vimtag">*<a name=":ls">:ls</a>*</b>
:ls[!]          显示所有缓冲区。例如：

<code class="section">                        1 #h  "/test/text"              line 1 </code>
<code class="section">                        2u    "asdf"                    line 0 </code>
<code class="section">                        3 %l+ "version.c"               line 1 </code>

                如果使用了 [!]，将显示所有的缓冲区，包括非列表的缓冲区。（
                "unlisted"  "非列表"这一术语有点儿别扭……）。

                每一个缓冲区都有唯一的号码与之对应。这个号码是不会改变的，所以
                你可以一直使用 ":buffer N" 或 "N <code class="keystroke">CTRL-^</code>" （N 是缓冲区号码）来
                选择特定的缓冲区。

                标识符号（同一列上的符号不可能同时出现）：
                u       非列表缓冲区（只有使用 [!] 才能看到）|<a href="windows.html#unlisted-buffer">unlisted-buffer</a>|
                 %      当前窗口里的缓冲区
                 #      用 ":e #" 或 <code class="keystroke">CTRL-^</code> 可切换到该缓冲区
                  a     激活的缓冲区：已载入内存并且可见
                  h     隐藏的缓冲区：已载入内存但是没有窗口显示它
                        |<a href="windows.html#hidden-buffer">hidden-buffer</a>|
                   -    不可更改的缓冲区，选项 'modifiable' 被关闭。
                   =    只读缓冲区
                    +   被更改的缓冲区
                    x   一个有读错误的缓冲

                                                <b class="vimtag">*<a name=":bad">:bad</a>*</b> <b class="vimtag">*<a name=":badd">:badd</a>*</b>
:bad[d] [+lnum] <code class="special">{fname}</code>
                在缓冲区列表里添加一个文件名 <code class="special">{fname}</code> ，但是不把该文件载入内存。
                如果指定了 "lnum" ，那么第一次进入缓冲区时，光标会停留在那一行。
                <code class="note">注意</code>  + 后面的其它命令将被忽略。

:[N]bd[elete][!]                        <b class="vimtag">*<a name=":bd">:bd</a>*</b> <b class="vimtag">*<a name=":bdel">:bdel</a>*</b> <b class="vimtag">*<a name=":bdelete">:bdelete</a>*</b> <b class="vimtag">*<a name="E516">E516</a>*</b>
:bd[elete][!] [N]
                卸载缓冲区 [N] （默认：当前窗口）并且从缓冲区列表里删除该缓冲
                区。如果缓冲区被改动过，那么该命令将失败，除非使用[!] ，但是这
                样所有的改动都会丢失。文件和 Vim 失去联系。打开该文件的所有窗
                口都会关闭。如果缓冲区 [N] 是当前的缓冲区，那么 Vim 会显示另一
                个缓冲区来替代它。Vim 会选择列表中距离最近的一个装入缓冲区。
                实际上，该缓冲区没有被完全从缓冲区列表 |<a href="windows.html#unlisted-buffer">unlisted-buffer</a>|
                里删除。该缓冲区中选项的值、变量、映射和缩写被清空。

:bdelete[!] <code class="special">{bufname}</code>                                           <b class="vimtag">*<a name="E93">E93</a>*</b> <b class="vimtag">*<a name="E94">E94</a>*</b>
                类似 ":bdelete[!] [N]"，但是使用名字指定缓冲区。
                <code class="note">注意</code> 如果缓冲区名字是数字的，不能用该命令引用；用号码代替。如
                果名字里含有空格，在空格前插入反斜杠。

:bdelete[!] N1 N2 ...
                对缓冲区 N1，N2，…… 执行 ":bdelete[!]"。
                参数可以是名字或号码（但是名字里不能含有数字）。
                如果名字里含有空格，在空格前插入反斜杠。

:N,Mbdelete[!]  对 N 号到 M 号（包含 N 和 M |<a href="motion.html#inclusive">inclusive</a>|）缓冲区执行 ":bdelete[!]"

:[N]bw[ipeout][!]                       <b class="vimtag">*<a name=":bw">:bw</a>*</b> <b class="vimtag">*<a name=":bwipe">:bwipe</a>*</b> <b class="vimtag">*<a name=":bwipeout">:bwipeout</a>*</b> <b class="vimtag">*<a name="E517">E517</a>*</b>
:bw[ipeout][!] <code class="special">{bufname}</code>
:N,Mbw[ipeout][!]
:bw[ipeout][!] N1 N2 ...
                类似 ":bdelete"，真正删除缓冲区。所有标记失效，选项丢失，等等。
                除非你确切地知道自己正在做什么，否则不要使用这个命令。

:[N]bun[load][!]                                <b class="vimtag">*<a name=":bun">:bun</a>*</b> <b class="vimtag">*<a name=":bunload">:bunload</a>*</b> <b class="vimtag">*<a name="E515">E515</a>*</b>
:bun[load][!] [N]
                卸载缓冲区 [N] （默认：当前缓冲区）。原来占用的内存将被释放该
                缓冲区还保留在缓冲区列表里如果缓冲区被改动过，那么该命令将失败，
                除非使用[!] ，但是这样所有的改动都会丢失。如果缓冲区 [N] 是当
                前的缓冲区，那么 Vim 会显示另一个缓冲区来替代它。Vim 会选择列
                表中距离最近的一个装入缓冲区。

:bunload[!] <code class="special">{bufname}</code>
                类似 ":bunload[!] [N]"， 但是使用名字指定缓冲区。
                <code class="note">注意</code> 如果缓冲区名字是数字的，不能用该命令引用；用号码代替。如
                果名字里含有空格，在空格前插入反斜杠。

:N,Mbunload[!]  对 N 号到 M 号（包含 N 和 M |<a href="motion.html#inclusive">inclusive</a>|）缓冲区执行 ":bunload[!]"

:bunload[!] N1 N2 ...
                对缓冲区 N1，N2，…… 执行 ":bunload[!]" 。
                参数可以是名字或号码（但是名字里不能含有数字）。
                如果名字里含有空格，在空格前插入反斜杠。

:[N]b[uffer][!] [N]                     <b class="vimtag">*<a name=":b">:b</a>*</b> <b class="vimtag">*<a name=":bu">:bu</a>*</b> <b class="vimtag">*<a name=":buf">:buf</a>*</b> <b class="vimtag">*<a name=":buffer">:buffer</a>*</b> <b class="vimtag">*<a name="E86">E86</a>*</b>
                编辑列表中的缓冲区 [N]，如果没指定 [N] ，就编辑当前的缓冲区。
                对于 [!] 参见 |<a href="windows.html#:buffer-!">:buffer-!</a>|。这个命令同样可以编辑不在列表里的缓
                冲区，而无需设置 'buflisted' 。

:[N]b[uffer][!] <code class="special">{filename}</code>
                编辑列表中的缓冲区 <code class="special">{filename}</code>。对于 [!] 参见 |<a href="windows.html#:buffer-!">:buffer-!</a>|。这
                个命令同样可以编辑不在列表里的缓冲区，而无需设置 'buflisted'。

:[N]sb[uffer] [N]                                       <b class="vimtag">*<a name=":sb">:sb</a>*</b> <b class="vimtag">*<a name=":sbuffer">:sbuffer</a>*</b>
                分割窗口编辑列表中的缓冲区 [N] ，如果没指定 [N] ，就编辑当前的
                缓冲区。分割窗口的时候要看 'switchbuf' 是不是设置了
                "useopen" 。这个命令同样可以编辑不在列表里的缓冲区，而无需设置
                'buflisted'。

:[N]sb[uffer] <code class="special">{filename}</code>
                分割窗口编辑列表中的缓冲区 <code class="special">{filename}</code>。这个命令同样可以编辑不
                在列表里的缓冲区，而无需设置 'buflisted' 。

                                                        <b class="vimtag">*<a name=":bn">:bn</a>*</b> <b class="vimtag">*<a name=":bnext">:bnext</a>*</b> <b class="vimtag">*<a name="E87">E87</a>*</b>
:[N]bn[ext][!] [N]
                前进至后面的第 [N] 个缓冲区。  [N] 默认是 1 。如果到了缓冲区列
                表的末尾，则从头循环。对于 [!] 参见 |<a href="windows.html#:buffer-!">:buffer-!</a>|
                如果你在帮助文件缓冲区里，这条命令让你跳到下一个帮助缓冲区（如
                果有的话）。同样，你在一个正常（非帮助）缓冲区里，就会使你跳到
                下一个正常缓冲区。这样是为了在打开帮助的时候不会影响到浏览正常
                的代码或文本。下面的命令都是这样。

                                                        <b class="vimtag">*<a name=":sbn">:sbn</a>*</b> <b class="vimtag">*<a name=":sbnext">:sbnext</a>*</b>
:[N]sbn[ext] [N]
                分割窗口前进至后面的第 [N] 个缓冲区。
                如果到了缓冲区列表的末尾，则从头循环。使用 'switchbuf'

:[N]bN[ext][!] [N]                      <b class="vimtag">*<a name=":bN">:bN</a>*</b> <b class="vimtag">*<a name=":bNext">:bNext</a>*</b> <b class="vimtag">*<a name=":bp">:bp</a>*</b> <b class="vimtag">*<a name=":bprevious">:bprevious</a>*</b> <b class="vimtag">*<a name="E88">E88</a>*</b>
:[N]bp[revious][!] [N]
                到前面的第 [N] 个缓冲区。  [N] 默认是 1 。
                如果到了缓冲区列表的顶端，则从末尾循环。对于 [!] 参见
                |<a href="windows.html#:buffer-!">:buffer-!</a>| 和 'switchbuf' 。

:[N]sbN[ext] [N]                        <b class="vimtag">*<a name=":sbN">:sbN</a>*</b> <b class="vimtag">*<a name=":sbNext">:sbNext</a>*</b> <b class="vimtag">*<a name=":sbp">:sbp</a>*</b> <b class="vimtag">*<a name=":sbprevious">:sbprevious</a>*</b>
:[N]sbp[revious] [N]
                分割窗口并前进到前面的第 [N] 个缓冲区。  [N] 默认是 1 。
                如果到了缓冲区列表的顶端，则从末尾循环。对于 [!] 参见
                |<a href="windows.html#:buffer-!">:buffer-!</a>| 和 'switchbuf' 。

                                                        <b class="vimtag">*<a name=":br">:br</a>*</b> <b class="vimtag">*<a name=":brewind">:brewind</a>*</b>
:br[ewind][!]
                前进到缓冲区列表中的第一个缓冲区。
                如果列表为空，则转到第一个非列表缓冲区。对于 [!] 参见
                |<a href="windows.html#:buffer-!">:buffer-!</a>|

                                                        <b class="vimtag">*<a name=":bf">:bf</a>*</b> <b class="vimtag">*<a name=":bfirst">:bfirst</a>*</b>
:bf[irst        与 ":brewind" 相同。

                                                        <b class="vimtag">*<a name=":sbr">:sbr</a>*</b> <b class="vimtag">*<a name=":sbrewind">:sbrewind</a>*</b>
:sbr[ewind]     分割窗口并前进到缓冲区列表中的第一个缓冲区。
                如果列表为空，则转到第一个非列表缓冲区。对于 [!] 参见
                |<a href="windows.html#:buffer-!">:buffer-!</a>|
                还需考虑 'switchbuf' 选项。

                                                        <b class="vimtag">*<a name=":sbf">:sbf</a>*</b> <b class="vimtag">*<a name=":sbfirst">:sbfirst</a>*</b>
:sbf[irst]      与 ":sbrewind" 相同。

                                                        <b class="vimtag">*<a name=":bl">:bl</a>*</b> <b class="vimtag">*<a name=":blast">:blast</a>*</b>
:bl[ast][!]     前进到缓冲区列表中的最后一个缓冲区。
                如果列表为空，则转到最后一个非列表缓冲区。对于 [!] 参见
                |<a href="windows.html#:buffer-!">:buffer-!</a>|
                还需考虑 'switchbuf' 选项。

                                                        <b class="vimtag">*<a name=":sbl">:sbl</a>*</b> <b class="vimtag">*<a name=":sblast">:sblast</a>*</b>
:sbl[ast]       分割窗口并前进到缓冲区列表中的最后一个缓冲区。
                如果列表为空，则转到最后一个非列表缓冲区。对于 [!] 参见
                |<a href="windows.html#:buffer-!">:buffer-!</a>|
                还需考虑 'switchbuf' 选项。

:[N]bm[odified][!] [N]                          <b class="vimtag">*<a name=":bm">:bm</a>*</b> <b class="vimtag">*<a name=":bmodified">:bmodified</a>*</b> <b class="vimtag">*<a name="E84">E84</a>*</b>
                前进至第 [N] 个修改过的缓冲区。  <code class="note">备注</code>: 这一命令同样也能找到非
                列表缓冲区。如果没有修改的缓冲区，此命令失败。

:[N]sbm[odified] [N]                                    <b class="vimtag">*<a name=":sbm">:sbm</a>*</b> <b class="vimtag">*<a name=":sbmodified">:sbmodified</a>*</b>
                分割窗口并前进至第 [N] 个修改过的缓冲区。
                还需考虑 'switchbuf' 选项。
                <code class="note">备注</code>: 这个命令也能找到不在列表里的缓冲区。

:[N]unh[ide] [N]                        <b class="vimtag">*<a name=":unh">:unh</a>*</b> <b class="vimtag">*<a name=":unhide">:unhide</a>*</b> <b class="vimtag">*<a name=":sun">:sun</a>*</b> <b class="vimtag">*<a name=":sunhide">:sunhide</a>*</b>
:[N]sun[hide] [N]
                重新排列窗口，给列表中的每一个载入的缓冲区打开一个窗口。如果设
                置了计数器，则计数器指定的数目为打开窗口的最多数目。

:[N]ba[ll] [N]                                  <b class="vimtag">*<a name=":ba">:ba</a>*</b> <b class="vimtag">*<a name=":ball">:ball</a>*</b> <b class="vimtag">*<a name=":sba">:sba</a>*</b> <b class="vimtag">*<a name=":sball">:sball</a>*</b>
:[N]sba[ll] [N] 重新排列窗口，给列表中的每一个缓冲区打开一个窗口。如果设置了计
                数器，则计数器指定的数目为打开窗口的最多数目。''winheight' 也
                限制了打开窗口的数目（当前缀 |<a href="windows.html#:vertical">:vertical</a>| 时 'winwidth' 也类似）
                Buf/Win Enter/Leave 不会在新窗口执行，只会在真正进入窗口时才会执行。

<code class="note">备注</code>: 上面所有的命令在编辑另一个缓冲区的时候，总是保持 'readonly' 不变。这和
":edit" 命令不同，它每次都会设置 'readonly' 。

</pre><hr class="doubleline" /><pre>
<h4>12. 特殊类型的缓冲区                    <b class="vimtag">*<a name="special-buffers">special-buffers</a>*</b></h4>
除了用来存放文本，缓冲区也可以用于其它目的。一些选项可以改变缓冲区的行为：
        'bufhidden'     缓冲区不再在窗口里显示
        'buftype'       缓冲区的类型
        'swapfile'      缓冲区是否需要交换文件
        'buflisted'     缓冲区是否在缓冲区列表中出现

有用的缓冲区类型：

quickfix        用来存放错误列表。参见 |<a href="quickfix.html#:cwindow">:cwindow</a>|。该命令设置 'buftype' 的值为
                "quickfix" 。你不应该修改它。'swapfile' 为关。

help            包含帮助文件。只能用 |<a href="various.html#:help">:help</a>| 命令创建，缓冲区的帮助标志是内置
                的，不能被更改。选项 'buflisted' 在帮助缓冲区里将被重置。

directory       显示目录内容。应用于 |<code class="badlink">file-explorer</code>| 插件。该缓冲区由以下设置
                创建：
<code class="example">                        :set buftype=nowrite</code>
<code class="example">                        :set bufhidden=delete</code>
<code class="example">                        :set noswapfile</code>
                缓冲区的名字就是目录的名字，并且在使用 |<a href="editing.html#:cd">:cd</a>| 命令时会作出相应
                的调整。

scratch         该缓冲区包含的文本可以被随时扔掉。在关闭窗口时，它被保存下来，
                并且必须被明确地删除。
                设置：
<code class="example">                        :set buftype=nofile</code>
<code class="example">                        :set bufhidden=hide</code>
<code class="example">                        :set noswapfile</code>
                缓冲区的名字可以用来标识缓冲区。

                                                <b class="vimtag">*<a name="unlisted-buffer">unlisted-buffer</a>*</b>
unlisted        该缓冲区不在缓冲区列表里。它不能用来编辑，但是可以显示帮助文件，
                记录文件名或标记。":bdelete" 命令也会设置这个选项，这样就不会
                完全地删除该缓冲区。设置：
<code class="example">                        :set nobuflisted</code>

 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 2006年 06月 24日 星期六 00:27:59 UTC</i></p>
</body>
</html>
