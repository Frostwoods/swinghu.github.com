<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>VIM: pattern</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>PATTERN</h2>
<pre>
<b class="vimtag">*<a name="pattern.txt">pattern.txt</a>*</b>   For Vim version 6.4.  最近更新：2006年3月


                  VIM REFERENCE MANUAL    by Bram Moolenaar
                    <code class="vim">译者</code>: lang2 http://vimcdoc.sf.net


模式及查找命令                                  <b class="vimtag">*<a name="pattern-searches">pattern-searches</a>*</b>

最基本的东西可以在用户手册的 |<a href="usr_03.html#03.9">03.9</a>| 节中找到。在 |<a href="usr_27.html#usr_27.txt">usr_27.txt</a>| 也有一些
解释。

1. 查找命令                     |<a href="pattern.html#search-commands">search-commands</a>|
2. 匹配模式的定义               |<a href="pattern.html#search-pattern">search-pattern</a>|
3. 魔术                         |<a href="pattern.html#%2Fmagic">/magic</a>|
4. 模式项总览                   |<a href="pattern.html#pattern-overview">pattern-overview</a>|
5. 倍数项                       |<a href="pattern.html#pattern-multi-items">pattern-multi-items</a>|
6. 普通匹配原                   |<a href="pattern.html#pattern-atoms">pattern-atoms</a>|
7. 忽略大小写                   |<a href="pattern.html#%2Fignorecase">/ignorecase</a>|
8. 与 Perl 匹配模式的比较       |<a href="pattern.html#perl-patterns">perl-patterns</a>|
9. 高亮显示匹配                 |<a href="pattern.html#match-highlight">match-highlight</a>|

</pre><hr class="doubleline" /><pre>
<h4>1. 查找命令                                     <b class="vimtag">*<a name="search-commands">search-commands</a>*</b> <b class="vimtag">*<a name="E486">E486</a>*</b></h4>
                                                        <b class="vimtag">*<a name="%2F">/</a>*</b>
/<code class="special">{pattern}</code>[/]<code class="special">&lt;CR&gt;</code>       向前查找第 <code class="special">[count]</code> 次出现 <code class="special">{pattern}</code> 的地方 (不包含
                        |<a href="motion.html#exclusive">exclusive</a>|)

/<code class="special">{pattern}</code>/<code class="special">{offset}</code><code class="special">&lt;CR&gt;</code> 向前查找第 <code class="special">[count]</code> 次出现 <code class="special">{pattern}</code> 的地方
                        并向上或下移动 |<a href="pattern.html#<code class="special">{offset}</code>"><code class="special">{offset}</code></a>| 行 |<a href="motion.html#linewise">linewise</a>|。

                                                        <b class="vimtag">*<a name="%2F%3CCR%3E">/&lt;CR&gt;</a>*</b>
/<code class="special">&lt;CR&gt;</code>                   向前查找第 <code class="special">[count]</code> 次出现处，使用上次的模式
                        |<a href="pattern.html#last-pattern">last-pattern</a>| 以及 |<a href="pattern.html#<code class="special">{offset}</code>"><code class="special">{offset}</code></a>|。

//<code class="special">{offset}</code><code class="special">&lt;CR&gt;</code>          向前查找第 <code class="special">[count]</code> 次出现处，使用上次的模式
                        |<a href="pattern.html#last-pattern">last-pattern</a>| 以及新偏移 |<a href="pattern.html#<code class="special">{offset}</code>"><code class="special">{offset}</code></a>|.  若
                        <code class="special">{offset}</code> 为空不使用任何偏移。

                                                        <b class="vimtag">*<a name="?">?</a>*</b>
?<code class="special">{pattern}</code>[?]<code class="special">&lt;CR&gt;</code>       向后查找第 <code class="special">[count]</code> 次出现 <code class="special">{pattern}</code> 的地方 (不包含
                        |<a href="motion.html#exclusive">exclusive</a>|)

?<code class="special">{pattern}</code>?<code class="special">{offset}</code><code class="special">&lt;CR&gt;</code> 向后查找第 <code class="special">[count]</code> 次出现 <code class="special">{pattern}</code> 的地方
                        并向上或下移动 |<a href="pattern.html#<code class="special">{offset}</code>"><code class="special">{offset}</code></a>| 行 |<a href="motion.html#linewise">linewise</a>|。

                                                        <b class="vimtag">*<a name="?%3CCR%3E">?&lt;CR&gt;</a>*</b>
?<code class="special">&lt;CR&gt;</code>                   向后查找第 <code class="special">[count]</code> 次出现处，使用上次的模式
                        |<a href="pattern.html#last-pattern">last-pattern</a>| 以及 |<a href="pattern.html#<code class="special">{offset}</code>"><code class="special">{offset}</code></a>|。

??<code class="special">{offset}</code><code class="special">&lt;CR&gt;</code>          向后查找第 <code class="special">[count]</code> 次出现处，使用上次的模式
                        |<a href="pattern.html#last-pattern">last-pattern</a>| 以及新偏移 |<a href="pattern.html#<code class="special">{offset}</code>"><code class="special">{offset}</code></a>|.  若
                        <code class="special">{offset}</code> 为空不使用任何偏移。

                                                        <b class="vimtag">*<a name="n">n</a>*</b>
n                       将上次的 "/" 或 "?" 重复 <code class="special">[count]</code> 次。
                        |<a href="pattern.html#last-pattern">last-pattern</a>| <code class="special">{Vi: 无次数}</code>

                                                        <b class="vimtag">*<a name="N">N</a>*</b>
N                       将上次的 "/" 或 "?" 在反方向上重复 <code class="special">[count]</code> 次。
                        |<a href="pattern.html#last-pattern">last-pattern</a>| <code class="special">{Vi: 无次数}</code>

                                                        <b class="vimtag">*<a name="star">star</a>*</b> <b class="vimtag">*<a name="E348">E348</a>*</b> <b class="vimtag">*<a name="E349">E349</a>*</b>
*                       向前查找第 <code class="special">[count]</code> 次出现距离当前光标最近的单词的地方。
                        用于查找的单词是以下的先符合条件的:
                                1. 光标下的关键字 |<a href="options.html#'iskeyword'">'iskeyword'</a>|
                                2. 当前行内的光标后的第一个关键字。
                                3. 光标下的非空白单词
                                4. 当前行内的光标后的第一个非空白单词
                        只查找整字，象和命令 "/\<code class="special">&lt;keyword\&gt;</code>" 一样。(不包含
                        |<a href="motion.html#exclusive">exclusive</a>|)
                        <code class="special">{Vi 无此功能}</code> 使用 'ignorecase'，'smartcase' 没有。

                                                        <b class="vimtag">*<a name="%23">#</a>*</b>
#                       同 "*"，但向后查找。 也可以用磅符号 (字符 163)。如果
                        "#" 的功能和退格键一样，试着在启动 Vim 前使用
                        "stty erase <code class="special">&lt;BS&gt;</code>" (<code class="special">&lt;BS&gt;</code> 是 <code class="keystroke">CTRL-H</code> 或真的退格键)。
                        <code class="special">{Vi 无此功能}</code>

                                                        <b class="vimtag">*<a name="gstar">gstar</a>*</b>
g*                      同 "*"，但不使用 "\<code class="special">&lt;" 和 "\&gt;</code>"。这样查找就会匹配非整字的
                        地方。<code class="special">{Vi 无此功能}</code>

                                                        <b class="vimtag">*<a name="g%23">g#</a>*</b>
g#                      同 "#"，但不使用 "\<code class="special">&lt;" 和 "\&gt;</code>"。这样查找就会匹配非整字的
                        地方。<code class="special">{Vi 无此功能}</code>

                                                        <b class="vimtag">*<a name="gd">gd</a>*</b>
gd                      跳转至局部声明。当光标下是一个局部变量时，此命令会跳转
                        到该变量被声明的地方。首先，Vim 会查找当前函数的起始处。
                        就象使用 "[[" 一样。如果找不到会停止在第一行。如果找到，
                        Vim 会向后直到找到一个空行，然后从这里开始向前查找光标
                        下的关键字，就象 "*"。看起来象注释的行会被忽略。
                        (见 'comments' 选项).
                        <code class="note">注意</code> 这并非总有效。Vim 不会做语法分析。它仅仅查找关键
                        字的匹配。如果需要搜索头文件的话，可以使用
                        |<a href="tagsrch.html#include-search">include-search</a>| 列出的命令。
                        这个命令之后，可以使用 |<a href="pattern.html#n">n</a>| 向前查找下一个匹配 (不能向
                        后)。<code class="special">{Vi 无此功能}</code>

                                                        <b class="vimtag">*<a name="gD">gD</a>*</b>
gD                      跳转至全局声明。当光标下是一个全局变量时，此命令会跳转
                        到该变量被声明的地方。这和 "gd" 命令一样，不过查找总是
                        从第一行开始。<code class="special">{Vi 无此功能}</code>

                                                        <b class="vimtag">*<a name="CTRL-C">CTRL-C</a>*</b>
<code class="keystroke">CTRL-C</code>                  中止当前的 (搜索) 命令。在 MS-DOS 上用 <code class="keystroke">CTRL-Break</code>
                        |<a href="os_dos.html#dos-CTRL-Break">dos-CTRL-Break</a>|.
                        在普通模式下，任何等待的命令将被终止。

                                                        <b class="vimtag">*<a name=":noh">:noh</a>*</b> <b class="vimtag">*<a name=":nohlsearch">:nohlsearch</a>*</b>
:noh[lsearch]           停止 'hlsearch' 选项的高亮显示。如果再执行查找命令
                        或者设定 'hlsearch' 选项，高亮会被自动打开。此命令
                        无法使用在自动命令里，因为加亮的状态会被自动保存和
                        恢复 |<a href="autocmd.html#autocmd-searchpat">autocmd-searchpat</a>|。

如果 'incsearch' 选项被打开，当键入查找模式时，当前的匹配会被显示。你还得
用 <code class="special">&lt;CR&gt;</code> 来结束查找命令并将光标定位到显示的匹配。或者用 <code class="special">&lt;ESC&gt;</code> 来放弃查找。

如果 'hlsearch' 被打开，你最后一次查找命令的所有匹配点都会被加亮。这可以用
|<a href="pattern.html#:nohlsearch">:nohlsearch</a>| 命令终止。

                                        <b class="vimtag">*<a name="search-offset">search-offset</a>*</b> <b class="vimtag">*<a name="<code class="special">{offset}</code>"><code class="special">{offset}</code></a>*</b>
这些命令查找一个指定的模式。对于 "/" 和 "?" 命令可以指定一个额外的偏移量。有两
种偏移：行偏移和字符偏移。<code class="special">{字符偏移不适用于 Vi}</code>

偏移用来指定光标相对于找到的匹配的位置:
    <code class="special">[num]</code>       <code class="special">[num]</code> 行向下，第一列
    +<code class="special">[num]</code>      <code class="special">[num]</code> 行向下，第一列
    -<code class="special">[num]</code>      <code class="special">[num]</code> 行向上，第一列
    e<code class="special">[+num]</code>     <code class="special">[num]</code> 字符向右 (从匹配结束 (end) 处算起)
    e<code class="special">[-num]</code>     <code class="special">[num]</code> 字符向左 (从匹配结束 (end) 处算起)
    s<code class="special">[+num]</code>     <code class="special">[num]</code> 字符向右 (从匹配开始 (start) 处算起)
    s<code class="special">[-num]</code>     <code class="special">[num]</code> 字符向左 (从匹配开始 (start) 处算起)
    b<code class="special">[+num]</code>     <code class="special">[num]</code> 等价于 s<code class="special">[+num]</code> (从匹配开始 (begin) 处算起)
    b<code class="special">[-num]</code>     <code class="special">[num]</code> 等价于 s<code class="special">[-num]</code> (从匹配开始 (begin) 处算起)

如果给出了 '-' 或 '+' 但是省略了 <code class="special">[num]</code>，会使用缺省的 1。如果使用了 'e' 偏移，
查找会成为包含的 (光标要到达的字符本身被包含在操作里)。

示例:

<code class="section">模式                    光标位置        </code>
/test/+1                "test" 下一行，第一列
/test/e                 "test" 的后一个 't'
/test/s+2               "test" 中的 's'
/test/b-3               "test" 前的第三个字符

如果把这些命令之一和一个操作符连用，查找之前和之后光标位置之间的字符会被影响。
然而，如果一个行偏移被使用，两光标位置之间的所有行都被影响。

一个如何查找一个模式并用另一个单词来更改匹配的例子:
<code class="example">        /foo<code class="special">&lt;CR&gt;</code>        查找 "foo"</code>
<code class="example">        c//e            改变从当前位置到匹配结尾的部分</code>
<code class="example">        bar<code class="special">&lt;Esc&gt;</code>        输入要改变的内容</code>
<code class="example">        //<code class="special">&lt;CR&gt;</code>          跳转到下一个相同匹配的开始</code>
<code class="example">        c//e            改变从当前位置到匹配结尾的部分</code>
<code class="example">        beep<code class="special">&lt;Esc&gt;</code>       输入另外一项要改变的内容</code>
<code class="example">                        等等。</code>

                                                        <b class="vimtag">*<a name="%2F%2F;">//;</a>*</b> <b class="vimtag">*<a name="E386">E386</a>*</b>
一个很特别的偏移是 ';' 后面接另一个查找命令。例如:
<code class="example"></code>
<code class="example">   /test 1/;/test</code>
<code class="example">   /test.*/+1;?ing?</code>
<code class="example"></code>
第一次查找先找到下一个出现 "test 1" 的地方，然后找第一次出现 "test" 的地方。

这就好象接连执行两次查找命令，不同之处在于:
- 这可以被当做一个移动命令而于一个操作符之后。
- 后续的 "n" 或 "N" 命令取决于第一个查找操作。
- 当有错误时光标原地不动。

                                                        <b class="vimtag">*<a name="last-pattern">last-pattern</a>*</b>
最近被使用的模式和偏移会被记住。它们可以被用来重复查找，向前或向后均可，还可以
使用次数。 <code class="note">注意</code> Vim 会记住两个模式：一个普通模式下查找命令用的，另一个是替换
命令 ":s" 用的。每次给出一个空白的模式时，上次的模式都将被用到。

'magic' 选项的值是被绑在上次使用的模式上的。如果你改变了 'magic'，这不会改变上
次使用的模式的解释方法。'ignorecase' 选项就不同。当 'ignorecase' 的值被改变时，
会使得该模式匹配另外的文本。

如果你设定了 'hlsearch' 选项，所有最后一次查找的匹配都会被加亮。

要清除最后一次查找的模式:
<code class="example">        :let @/ = ""</code>
这不会把该模式设置为空串，因为那样会匹配所有的东西。该模式是真的被清除了，就象
Vim 刚刚启动一样。

通常查找会跳过那些不移动光标位置的匹配。下一次匹配是开始于下一个字符还是在跳过
的匹配之后取决于 'cpoptions' 选项中的 'c' 标志位。见 |<a href="options.html#cpo-c">cpo-c</a>|。
             带 'c' 标志位:   "/..." 前进 1 至 3 个字符
           不带 'c' 标志位:   "/..." 前进 1 个字符
从第一栏开始搜索并忽略任何光标位置之前的匹配导致了 'c' 标志的不可预见性。

在 Vi 里 ":tag" 命令会将最后一次查找的模式设定为要搜索的标签。Vim 没有这样做。
前一次查找的模式仍然被记住，除非 'cpoptions' 选项中包括 't' 标志位。查找模式
总被存入查找历史记录。

如果 'wrapscan' 选项的值为真 (缺省) 的话，查找会在缓冲的结尾折返。否则，向后
查找会在开始处停止；向前查找会在结尾处停止。如果该选项为真但找不到该模式，会
给出一个错误信息："pattern not found"。光标原地不动。否则给出的信息是：
"search hit BOTTOM without match" 或者 "search hit TOP without match"，取决于
查找的方向。如果该选项为真，当查找折返时会显示："search hit TOP, continuing at
BOTTOM" 或 "search hit BOTTOM, continuing at TOP"。这各信息可以用设定
'shortmess' 选项里的 's' 标志位来关闭。该信息的显示会使用 'w' 的加亮方法。
(缺省: 标准输出)

                                                        <b class="vimtag">*<a name="search-range">search-range</a>*</b>
你可以限定 "/" 命令查找的范围。一个窍门是使用 ":substitute" 命令并与 'c' 联用。
例:
<code class="example">   :.,300s/Pattern//gc</code>
这个命令会从光标所在处开始查找 "Pattern"，直到第 300 行。在匹配处，你会被提示
键入一个字符。键入 'q' 终止；键入 'n' 找下一个匹配。

"*"，"#"，"g*" 和 "g#" 命令依照以下的次序在光标附近查找一个单词，第一个被找到的
会被使用:
- 光标下的关键字。
- 同行的光标右侧的第一各关键字。
- 光标下的第一个字 (WORD)。
- 同行的光标右侧的第一个字 (WORD)。
关键字只能包括字母和 'iskeyword' 中的字符。字 (WORD) 可以包括任何非空白 (<code class="special">&lt;Tab&gt;</code>
和／或 <code class="special">&lt;Space&gt;</code>) 。
<code class="note">注意</code> 如果你用十个指头打字的话，这些字符是很容易记住的：
"#" 在你的左手中指上 (向左上查找)；"*" 在你的右手中指上 (向右下查找)。
(这取决于你的键盘布局).

</pre><hr class="doubleline" /><pre>
<h4>2. 模式的定义                           <b class="vimtag">*<a name="search-pattern">search-pattern</a>*</b> <b class="vimtag">*<a name="pattern">pattern</a>*</b> <b class="vimtag">*<a name="[pattern]">[pattern]</a>*</b></h4>                                        <b class="vimtag">*<a name="regular-expression">regular-expression</a>*</b> <b class="vimtag">*<a name="regexp">regexp</a>*</b> <b class="vimtag">*<a name="Pattern">Pattern</a>*</b>
                                        <b class="vimtag">*<a name="E76">E76</a>*</b> <b class="vimtag">*<a name="E361">E361</a>*</b> <b class="vimtag">*<a name="E363">E363</a>*</b> <b class="vimtag">*<a name="E383">E383</a>*</b> <b class="vimtag">*<a name="E476">E476</a>*</b>

头一道菜已经在用户手册的第 27 章 |<a href="usr_27.html#usr_27.txt">usr_27.txt</a>| 上过了。

                                                <b class="vimtag">*<a name="%2Fbar">/bar</a>*</b> <b class="vimtag">*<a name="%2F\bar">/\bar</a>*</b> <b class="vimtag">*<a name="%2Fpattern">/pattern</a>*</b>
1. 一个模式 (pattern) 是由 "\|" 分割开的一个或多个分支 (branch)。它可以匹配
   其中的任何一个分支。例如："foo\|beep" 可以匹配 "foo" 或 "beep"。如果超过
   一个分支可以匹配，第一个被选用。

   pattern ::=      branch
                或  branch \| branch
                或  branch \| branch \| branch
                等。

                                                <b class="vimtag">*<a name="%2Fbranch">/branch</a>*</b> <b class="vimtag">*<a name="%2F\&">/\&amp;</a>*</b>
2. 一个分支是一个或多个被 "\&amp;" 分割的邻接。它匹配最后一个邻接，但仅仅当前面所
   的邻接也在同样位置匹配。例:
        "foobeep\&amp;..." 匹配 "foobeep" 中的 "foo"。
        ".<b class="vimtag">*<a name="Peter\&.">Peter\&amp;.</a>*</b>Bob" 匹配同时包括 "Peter" 和 "Bob" 的一行

   branch ::=       concat
                或  concat \&amp; concat
                或  concat \&amp; concat \&amp; concat
                等。

                                                <b class="vimtag">*<a name="%2Fconcat">/concat</a>*</b>
3. 一个邻接 (concat) 是一或多个相邻的组件 (piece)。它匹配第一个组件，后接第二
   个组件的匹配，等等。例如: "f[0-9]b"，先匹配 "f"，然后是一个数位，接着 "b"。

   concat  ::=      piece
                或  piece piece
                或  piece piece piece
                等。

                                                <b class="vimtag">*<a name="%2Fpiece">/piece</a>*</b>
4. 一个组件是一个匹配原 (atom)，后面可能带一个倍数 (multi)，用来表示该匹配原匹
   配的次数。例如："a*" 匹配任意个 "a" 组成的序列: ""，"a"，"aa" 等。参见
   |<a href="pattern.html#%2Fmulti">/multi</a>|。

   piece   ::=      atom
                或  atom  multi

                                                <b class="vimtag">*<a name="%2Fatom">/atom</a>*</b>
5. 一个匹配原可以是一个很长的条目列表中的一个。很多匹配原被用来匹配文本中的一
   个字符。匹配原经常是一个普通的字符或字符类。可以用圆括号来将一个模式变成一
   个匹配原。结构 "\z(\)" 仅仅被用在语法加亮中。

   atom    ::=      ordinary-atom               |<a href="pattern.html#%2Fordinary-atom">/ordinary-atom</a>|
                或  \( pattern \)               |<a href="pattern.html#%2F\(">/\(</a>|
                或  \%( pattern \)              |<a href="pattern.html#%2F\%(">/\%(</a>|
                或  \z( pattern \)              |<a href="syntax.html#%2F\z(">/\z(</a>|


</pre><hr class="doubleline" /><pre>
<h4>4. 模式项总览                                   <b class="vimtag">*<a name="pattern-overview">pattern-overview</a>*</b></h4>
倍数总览。                                              <b class="vimtag">*<a name="%2Fmulti">/multi</a>*</b> <b class="vimtag">*<a name="E61">E61</a>*</b> <b class="vimtag">*<a name="E62">E62</a>*</b>
下面给出一些解释和示例，包括链接。                      <b class="vimtag">*<a name="E64">E64</a>*</b>

<code class="section">          倍数 </code>
<code class="section">     'magic' 'nomagic'  匹配前面的匹配原 </code>
|<a href="pattern.html#%2Fstar">/star</a>| *       \*      0 或更多        尽可能多
|<a href="pattern.html#%2F\+">/\+</a>|   \+      \+      1 或更多        尽可能多 (*)
|<a href="pattern.html#%2F\%20">/\=</a>|   \=      \=      0 或 1          尽可能多 (*)
|<a href="pattern.html#%2F\?">/\?</a>|   \?      \?      0 或 1          尽可能多 (*)

|<a href="pattern.html#%2F\<code class="special">{">/\{</a>|   \{n,m}</code>  \<code class="special">{n,m}</code>  n 到 m          尽可能多 (*)
        \<code class="special">{n}</code>    \<code class="special">{n}</code>    n               准确 (*)
        \<code class="special">{n,}</code>   \<code class="special">{n,}</code>   最少 n          尽可能多 (*)
        \<code class="special">{,m}</code>   \<code class="special">{,m}</code>   0 到 m          尽可能多 (*)
        \<code class="special">{}</code>     \<code class="special">{}</code>     0 或更多        尽可能多 (*)

|<a href="pattern.html#%2F\<code class="special">{-">/\{-</a>|  \{-n,m}</code> \<code class="special">{-n,m}</code> n 到 m          尽可能少 (*)
        \<code class="special">{-n}</code>   \<code class="special">{-n}</code>   n               准确 (*)
        \<code class="special">{-n,}</code>  \<code class="special">{-n,}</code>  最少 n          尽可能少 (*)
        \<code class="special">{-,m}</code>  \<code class="special">{-,m}</code>  0 到 m          尽可能少 (*)
        \<code class="special">{-}</code>    \<code class="special">{-}</code>    0 或更多        尽可能少 (*)

                                                        <b class="vimtag">*<a name="E59">E59</a>*</b>
|<a href="pattern.html#%2F\@%3E">/\@&gt;</a>|  \@&gt;     \@&gt;     1，要求完整的模式匹配 (不能回溯) (*)
|<a href="pattern.html#%2F\@%20">/\@=</a>|  \@=     \@=     无，但要求匹配 |<a href="pattern.html#%2Fzero-width">/zero-width</a>| (*)
|<a href="pattern.html#%2F\@!">/\@!</a>|  \@!     \@!     无，但要求不匹配 |<a href="pattern.html#%2Fzero-width">/zero-width</a>| (*)
|<a href="pattern.html#%2F\@%3C%20">/\@&lt;=</a>| \@&lt;=    \@&lt;=    无，但要求反向匹配 |<a href="pattern.html#%2Fzero-width">/zero-width</a>| (*)
|<a href="pattern.html#%2F\@%3C!">/\@&lt;!</a>| \@&lt;!    \@&lt;!    无，但要其反向不匹配 |<a href="pattern.html#%2Fzero-width">/zero-width</a>| (*)

(*) <code class="special">{Vi 无此功能}</code>


普通匹配原总览。                                        <b class="vimtag">*<a name="%2Fordinary-atom">/ordinary-atom</a>*</b>
下面给出解释和示例，包括链接。

<code class="section">          普通匹配原 </code>
<code class="section">      magic   nomagic   匹配 </code>
|<a href="pattern.html#%2F^">/^</a>|    ^       ^       行首 (在模式起始) |<a href="pattern.html#%2Fzero-width">/zero-width</a>|
|<a href="pattern.html#%2F\^">/\^</a>|   \^      \^      字符 '^'
|<a href="pattern.html#%2F\_^">/\_^</a>|  \_^     \_^     行首 (用于任何地方) |<a href="pattern.html#%2Fzero-width">/zero-width</a>|
|<a href="pattern.html#%2F$">/$</a>|    $       $       行尾 (在模式结尾) |<a href="pattern.html#%2Fzero-width">/zero-width</a>|
|<a href="pattern.html#%2F\$">/\$</a>|   \$      \$      字符 '$'
|<a href="pattern.html#%2F\_$">/\_$</a>|  \_$     \_$     行尾 (用于任何地方) |<a href="pattern.html#%2Fzero-width">/zero-width</a>|
|<a href="pattern.html#%2F.">/.</a>|    .       \.      任何单个字符 (不包括行尾)
|<a href="pattern.html#%2F\_.">/\_.</a>|  \_.     \_.     任何单个字符，包括行尾
|<a href="pattern.html#%2F\%3C">/\&lt;</a>|   \&lt;      \&lt;      一个单词的起始 |<a href="pattern.html#%2Fzero-width">/zero-width</a>|
|<a href="pattern.html#%2F\%3E">/\&gt;</a>|   \&gt;      \&gt;      一个单词的结尾 |<a href="pattern.html#%2Fzero-width">/zero-width</a>|
|<a href="pattern.html#%2F\zs">/\zs</a>|  \zs     \zs     任何字符，设定匹配起始
|<a href="pattern.html#%2F\ze">/\ze</a>|  \ze     \ze     任何字符，设定匹配结尾
|<a href="pattern.html#%2F\%^">/\%^</a>|  \%^     \%^     文件首 |<a href="pattern.html#%2Fzero-width">/zero-width</a>|            <b class="vimtag">*<a name="E71">E71</a>*</b>
|<a href="pattern.html#%2F\%$">/\%$</a>|  \%$     \%$     文件尾 |<a href="pattern.html#%2Fzero-width">/zero-width</a>|
|<a href="pattern.html#%2F\%%23">/\%#</a>|  \%#     \%#     光标位置 |<a href="pattern.html#%2Fzero-width">/zero-width</a>|
|<a href="pattern.html#%2F\%l">/\%l</a>|  \%23l   \%23l   在第 23 行 |<a href="pattern.html#%2Fzero-width">/zero-width</a>|
|<a href="pattern.html#%2F\%c">/\%c</a>|  \%23c   \%23c   在第 23 列 |<a href="pattern.html#%2Fzero-width">/zero-width</a>|
|<a href="pattern.html#%2F\%v">/\%v</a>|  \%23v   \%23v   在虚拟第 23 列 |<a href="pattern.html#%2Fzero-width">/zero-width</a>|

字符类 <code class="special">{Vi 无此功能}</code>:
|<a href="pattern.html#%2F\i">/\i</a>|   \i      \i      标识符字符 (见 'isident' 选项)
|<a href="pattern.html#%2F\I">/\I</a>|   \I      \I      同 "\i"，但不包括数字字符
|<a href="pattern.html#%2F\k">/\k</a>|   \k      \k      关键字字符 (见 'iskeyword' 选项)
|<a href="pattern.html#%2F\K">/\K</a>|   \K      \K      同 "\k"，但不包括数字字符
|<a href="pattern.html#%2F\f">/\f</a>|   \f      \f      文件名字符 (见 'isfname' 选项)
|<a href="pattern.html#%2F\F">/\F</a>|   \F      \F      同 "\f"，但不包括数字字符
|<a href="pattern.html#%2F\p">/\p</a>|   \p      \p      可打印字符 (见 'isprint' 选项)
|<a href="pattern.html#%2F\P">/\P</a>|   \P      \P      同 "\p"，但不包括数字字符
|<a href="pattern.html#%2F\s">/\s</a>|   \s      \s      空白字符； <code class="special">&lt;Space&gt;</code> 和 <code class="special">&lt;Tab&gt;</code>
|<a href="pattern.html#%2F\S">/\S</a>|   \S      \S      非空白字符：\s 之反
|<a href="pattern.html#%2F\d">/\d</a>|   \d      \d      数字:                   [0-9]
|<a href="pattern.html#%2F\D">/\D</a>|   \D      \D      非数字:                 [^0-9]
|<a href="pattern.html#%2F\x">/\x</a>|   \x      \x      十六进制数字:           [0-9A-Fa-f]
|<a href="pattern.html#%2F\X">/\X</a>|   \X      \X      非十六进制字符:         [^0-9A-Fa-f]
|<a href="pattern.html#%2F\o">/\o</a>|   \o      \o      八进制字符:             [0-7]
|<a href="pattern.html#%2F\O">/\O</a>|   \O      \O      非八进制字符:           [^0-7]
|<a href="pattern.html#%2F\w">/\w</a>|   \w      \w      单词字符:               [0-9A-Za-z_]
|<a href="pattern.html#%2F\W">/\W</a>|   \W      \W      非单词字符:             [^0-9A-Za-z_]
|<a href="pattern.html#%2F\h">/\h</a>|   \h      \h      单词首字符:             [A-Za-z_]
|<a href="pattern.html#%2F\H">/\H</a>|   \H      \H      单词非首字符:           [^A-Za-z_]
|<a href="pattern.html#%2F\a">/\a</a>|   \a      \a      英文字母字符:           [A-Za-z]
|<a href="pattern.html#%2F\A">/\A</a>|   \A      \A      非英文字母字符:         [^A-Za-z]
|<a href="pattern.html#%2F\l">/\l</a>|   \l      \l      小写字符:               [a-z]
|<a href="pattern.html#%2F\L">/\L</a>|   \L      \L      非小写字符:             [^a-z]
|<a href="pattern.html#%2F\u">/\u</a>|   \u      \u      大写字符:               [A-Z]
|<a href="pattern.html#%2F\U">/\U</a>|   \U      \U      非大写字符              [^A-Z]
|<a href="pattern.html#%2F\_">/\_</a>|   \_x     \_x     其中 x 可以是以上任意一个字符：包括行尾的字符类
 (字符类结束)

|<a href="pattern.html#%2F\e">/\e</a>|   \e      \e      <code class="special">&lt;Esc&gt;</code>
|<a href="pattern.html#%2F\t">/\t</a>|   \t      \t      <code class="special">&lt;Tab&gt;</code>
|<a href="pattern.html#%2F\r">/\r</a>|   \r      \r      <code class="special">&lt;CR&gt;</code>
|<a href="pattern.html#%2F\b">/\b</a>|   \b      \b      <code class="special">&lt;BS&gt;</code>
|<a href="pattern.html#%2F\n">/\n</a>|   \n      \n      行尾
|<a href="pattern.html#%2F%7E">/~</a>|    ~       \~      上次给出的替换字符串
|<a href="pattern.html#%2F\1">/\1</a>|   \1      \1      第一个 \(\) 匹配的字符  <code class="special">{Vi 无此功能}</code>
|<a href="pattern.html#%2F\2">/\2</a>|   \2      \2      如 "\1"，但用第二个 \(\)
           ...
|<a href="pattern.html#%2F\9">/\9</a>|   \9      \9      如 "\1"，但用第九个 \(\)
                                                                <b class="vimtag">*<a name="E68">E68</a>*</b>
|<a href="syntax.html#%2F\z1">/\z1</a>|  \z1     \z1     仅用于语法加亮，见 |<a href="syntax.html#:syn-ext-match">:syn-ext-match</a>|
           ...
|<a href="syntax.html#%2F\z1">/\z1</a>|  \z9     \z9     仅用于语法加亮，见 |<a href="syntax.html#:syn-ext-match">:syn-ext-match</a>|

        x       x       一个没有特殊含义的字符匹配其自身

|<a href="pattern.html#%2F[]">/[]</a>|   []      \[]     [] 内指定的任何字符之一
|<a href="pattern.html#%2F\%[]">/\%[]</a>| \%[]    \%[]    一个可以选择性匹配的匹配原列表

|<a href="pattern.html#%2F\c">/\c</a>|   \c      \c      忽略大小写
|<a href="pattern.html#%2F\C">/\C</a>|   \C      \C      匹配大小写
|<a href="pattern.html#%2F\m">/\m</a>|   \m      \m      对之后模式中字符打开 'magic' 选项
|<a href="pattern.html#%2F\M">/\M</a>|   \M      \M      对之后模式中字符关闭 'magic' 选项
|<a href="pattern.html#%2F\v">/\v</a>|   \v      \v      对之后模式中字符设定 'magic' 选项为 "very magic"
|<a href="pattern.html#%2F\V">/\V</a>|   \V      \V      对之后模式中字符设定 'magic' 选项为 "very nomagic"
|<a href="pattern.html#%2F\Z">/\Z</a>|   \Z      \Z      忽略 Unicode 中的 "组合用字符"，对于搜索带元音的希伯来
                        和阿拉伯文本有用。


<code class="section">示例                    匹配 </code>
\&lt;\I\i*         或
\&lt;\h\w*
\&lt;[a-zA-Z_][a-zA-Z0-9_]*
                        一个标识符 (例如，在一个 C 程序里)。

\(\.$\|\. \)            一个英文句号后跟 <code class="special">&lt;EOL&gt;</code> 或一个空格。

[.!?][])"']*\($\|[ ]\)  一个匹配英文句子结尾的模式。类似于 ")" 的定义。

cat\Z                   匹配 "cat" 和 "càt" ("a" 后跟 0x0300)
                        不匹配 "càt" (字符 0x00e0)，即使它们看起来可能一样。


</pre><hr class="doubleline" /><pre>
<h4>3. 魔术                                                 <b class="vimtag">*<a name="%2Fmagic">/magic</a>*</b></h4>
某些字符在模式中是原文被采用的。它们匹配自身。然而，当前面有一个反斜杠时，这些
字符具有特殊的含义。

另外一些字符即使没有反斜杠也代表特殊的意思。它们反而需要一个反斜杠来匹配其自
身。

一个字符是否被当原文采用取决于 'magic' 选项以及下面将解释的条目。
                                                        <b class="vimtag">*<a name="%2F\m">/\m</a>*</b> <b class="vimtag">*<a name="%2F\M">/\M</a>*</b>
使用 "\m" 会使得其后的模式的解释方式就如同设定了 'magic' 选项一样。而且将忽略
'magic' 选项的实际值。
使用 "\M" 会使得其后的模式的解释方式就如同设定了 'nomagic' 选项一样。
                                                        <b class="vimtag">*<a name="%2F\v">/\v</a>*</b> <b class="vimtag">*<a name="%2F\V">/\V</a>*</b>
使用 "\v" 会使得其后的模式中所有 '0'-'9'，'a'-'z'，'A'-'Z' 和 '_' 之外的字符都
被当做特殊字符解释。"very magic"

使用 "\V" 会使得其后的模式中只有反斜杠有特殊的意义。"very nomagic"

示例:
<code class="section">在这之后: \v       \m       \M       \V         匹配 </code>
                'magic' 'nomagic'
          $        $        $        \$         匹配行尾
          .        .        \.       \.         匹配任何字符
          *        *        \*       \*         前面匹配原的任意次重复
          ()       \(\)     \(\)     \(\)       组成为单个匹配原
          |        \|       \|       \|         分割 alternatives
          \a       \a       \a       \a         字母字符
          \\       \\       \\       \\         反斜杠 (按本义)
          \.       \.       .        .          英文句号 (按本义)
          \{       {        {        {          '{'  (按本义)
          a        a        a        a          'a'  (按本义)

<code class="special">{only 只有 Vim 支持 \m，\M，\v 和 \V}</code>

建议始终将 'magic' 选项保持在缺省值 －  'magic'。这可以避免移植性的麻烦。要使
模式不受该选项值的影响，在模式前面加上 "\m" 或 "\M"。


</pre><hr class="doubleline" /><pre>
<h4>5. 倍数项                                       <b class="vimtag">*<a name="pattern-multi-items">pattern-multi-items</a>*</b></h4>
一个匹配原后面可以跟一个表示该匹配原匹配次数和方式的修饰。这个修饰被称为倍数。
在 |<a href="pattern.html#%2Fmulti">/multi</a>| 可以看到一个综述。

如果一个匹配原可以匹配空串，其后就不能使用倍数。那样可能会引起死循环。如果你坚
持要试，你会得到一个错误信息:
<code class="example">        *, \+ or \{ operand could be empty</code>

                                                <b class="vimtag">*<a name="%2Fstar">/star</a>*</b> <b class="vimtag">*<a name="%2F\star">/\star</a>*</b> <b class="vimtag">*<a name="E56">E56</a>*</b>
*        (在没有设定 'magic' 使用 \*)
        匹配 0 或更多个前面的匹配原，尽可能多地匹配。
<code class="section">        示例     'nomagic'      匹配 </code>
        a*         a\*          ""，"a"，"aa"，"aaa" 等。
        .*         \.\*         任意，包括空串，不包括行尾
        \_.*       \_.\*        匹配至缓冲结束
        \_.*END    \_.\*END     匹配至缓冲中最后一次出现 "END" 处，包括该
                                "END"

        特例: 当 "*" 被使用在模式的开头或者紧跟在 "^" 之后时它匹配星号字符。

        要当心，重复匹配 "\_." 会包括大量的文本，因而可能会花很长时间。例如，
        "\_.*END" 匹配从当前位置开始到文件中最后一次出现 "END" 的地方。因为 "*"
        会尽可能多的匹配，这会先跳过到文件结束前的所有行然后反方向逐字查找
        "END"。

                                                        <b class="vimtag">*<a name="%2F\+">/\+</a>*</b> <b class="vimtag">*<a name="E57">E57</a>*</b>
\+      匹配一个或更多前面的匹配原。尽可能多。<code class="special">{Vi 无此功能}</code>
<code class="section">        例              匹配 </code>
        ^.\+$           任意空行
        \s\+            一个以上的空白字符

                                                        <b class="vimtag">*<a name="%2F\%20">/\=</a>*</b>
\=      匹配 0 或 1 个前面的匹配原。尽可能多。 <code class="special">{Vi 无此功能}</code>
<code class="section">        例              匹配 </code>
        foo\=           "fo" 和 "foo"

                                                        <b class="vimtag">*<a name="%2F\?">/\?</a>*</b>
\?      和 \= 一样。不能和 "?" 命令中使用。<code class="special">{Vi 无此功能}</code>

                                                <b class="vimtag">*<a name="%2F\{">/\{</a>*</b> <b class="vimtag">*<a name="E58">E58</a>*</b> <b class="vimtag">*<a name="E60">E60</a>*</b> <b class="vimtag">*<a name="E554">E554</a>*</b>
\<code class="special">{n,m}</code>  匹配 n 至 m 个前面的匹配原。尽可能多。
\<code class="special">{n}</code>    匹配 n 个前面的匹配原。
\<code class="special">{n,}</code>   匹配至少 n 个前面的匹配原。尽可能多。
\<code class="special">{,m}</code>   匹配 0 至 m 个前面的匹配原。尽可能多。
\<code class="special">{}</code>     匹配 0 个以上前面的匹配原。尽可能多。(如同 *)
                                                        <b class="vimtag">*<a name="%2F\{-">/\{-</a>*</b>
\<code class="special">{-n,m}</code> 匹配 n 至 m 个前面的匹配原。尽可能少。
\<code class="special">{-n}</code>   匹配 n 个前面的匹配原。
\<code class="special">{-n,}</code>  匹配至少 n 个前面的匹配原。尽可能少。
\<code class="special">{-,m}</code>  匹配 0 至 m 个前面的匹配原。尽可能少。
\<code class="special">{-}</code>    匹配 0 个以上前面的匹配原。尽可能少。(如同 *)
        <code class="special">{Vi 没有这些}</code>

        n 和 m 是正的十进制数

        如果一个 "-" 紧接在 "{" 之后，那么最短匹配优先算法将被启用 (见下面的例
        子)。特别的，"\<code class="special">{-}</code>" 和 "*" 一样，只不过使用了最短匹配优先算法。_但_，
        一个更早开始的匹配比一个更短的匹配优先: "a\<code class="special">{-}</code>b" 匹配 "xaaab" 中的
        "aaab"。


<code class="section">        示例                    匹配 </code>
        ab\<code class="special">{2,3}</code>c               "abbc" 或 "abbbc"
        a\<code class="special">{5}</code>                   "aaaaa"。
        ab\<code class="special">{2,}</code>c                "abbc"，"abbbc"，"abbbbc" 等
        ab\<code class="special">{,3}</code>c                "ac"，"abc"，"abbc" 或 "abbbc"。
        a[bc]\<code class="special">{3}</code>d              "abbbd"，"abbcd"，"acbcd"，"acccd" 等。
        a\(bc\)\<code class="special">{1,2}</code>d          "abcd" 或 "abcbcd"
        a[bc]\<code class="special">{-}</code>[cd]           "abcd" 中的 "abc"
        a[bc]*[cd]              "abcd" 中的 "abcd"

        } 之前可以加 (也可以不加) 一个反斜杠: \<code class="special">{n,m\}</code>.

                                                        <b class="vimtag">*<a name="%2F\@%20">/\@=</a>*</b>
\@=     零宽度匹配前面的匹配原。<code class="special">{Vi 无此功能}</code>
        象 Perl 中的 "(?=pattern)"。
<code class="section">        示例                    匹配 </code>
        foo\(bar\)\@=           "foobar" 中的 "foo"
        foo\(bar\)\@=foo        空
                                                        <b class="vimtag">*<a name="%2Fzero-width">/zero-width</a>*</b>
        当使用 "\@=" (或 "^"，"$"，"\<code class="special">&lt;"，"\&gt;</code>") 时匹配中不包括任何字符。这些
        字符仅仅是被用来检查能否构成一个匹配的。这很容易搞错。因为后续的项
        会被在同样位置作匹配。上面的最后一个例子不会匹配 "foobarfoo"，因为
        Vim 会尝试在 "bar" 匹配的同样地方匹配 "foo"。

        <code class="note">注意</code> 使用 "\&amp;" 同使用 "\@=" 是一样的: "foo\&amp;.." 和 "\(foo\)\@=.."
        一样。但用 "\&amp;" 容易些，你可以省了那些括号。


                                                        <b class="vimtag">*<a name="%2F\@!">/\@!</a>*</b>
\@!     零宽度否匹配，亦即，要求前面的匹配原在当前位置_不_匹配。|<a href="pattern.html#%2Fzero-width">/zero-width</a>|
        <code class="special">{Vi 无此功能}</code>
        象 Perl 中的 '(?!pattern)"。
<code class="section">        示例                    匹配 </code>
        foo\(bar\)\@!           任意后面不带 "bar" 的 "foo"
        a.\<code class="special">{-}</code>p\@!              "a"，"ap"，"app" 等。后面不带 "p"
        if \(\(then\)\@!.\)*$   "if " 后面无跟随 "then"

        使用 "\@!" 要小心，因为很多地方一个模式可以不匹配。"a.*p\@!" 会匹配
        一个 "a" 直到行尾，因为 ".*" 匹配所有行内的字符，而 "p" 不匹配行尾。
        "a.\<code class="special">{-}</code>p\@!" 则可以匹配 "a"，"ap"，"aap" 等中的一项，只要它们不再紧跟
        另外一个 "p"，这是因为 "." 可以匹配 "p" 而 "p\@!" 不匹配这个 "p" 的后
        面。

        你不能用 "\@!" 去寻找匹配所在位置之前的否匹配。"\(foo\)\@!bar" 会匹配
        "foobar" 中的 "bar"，因为在 "bar" 匹配的位置上，"foo" 并不匹配。如果
        不想匹配 "foobar"，你可以尝试 "\(foo\)\@!...bar"，但它不能匹配在行首出
        现的 "bar"。最好的方法是用 "\(foo\)\@&lt;!bar"。

                                                        <b class="vimtag">*<a name="%2F\@%3C%20">/\@&lt;=</a>*</b>
\@&lt;=    零宽度匹配，如果前面的匹配原所匹配的文本出现在其后的匹配的文本之前。
        <code class="special">{Vi 无此功能}</code>
        和 Perl 的 '(?&lt;=pattern)" 类似，但是 Vim 允许使用非固定宽度的模式。
<code class="section">        示例                    匹配 </code>
        \(an\_s\+\)\@&lt;=file     在 "an" 和若干个空白或者回车之后的 "file"。
        为了提高性能，最好避免这个倍数项。可以用 "\zs" 替代 |<a href="pattern.html#%2F\zs">/\zs</a>|。要匹配
        上述的示例：
<code class="example">                an\_s\+\zsfile</code>
<code class="example"></code>
        "\@&lt;=" 和 "\@&lt;!" 检查刚好在其后匹配之前出现的匹配文本。理论上，这些匹
        配可以从当前位置之前的任何地方开始，为了限制所需的时间，只有其后匹配所
        在的行和它上一行 (如果有上一行的话) 会被检索。这对大多数的应用来说已经
        足够，而且也不会减慢速度太多。
        在 "\@&lt;=" 和 "\@&lt;!" 之后的模式其实先被匹配，所以 "\1" 之类的结构不能用
        来引用这两个倍数所引用的匹配原中的 \(\)。反过来倒是可以的。
<code class="section">        示例                    匹配 </code>
        \1\@&lt;=,\([a-z]\+\)      ",abc" in "abc,abc"

                                                        <b class="vimtag">*<a name="%2F\@%3C!">/\@&lt;!</a>*</b>
\@&lt;!    零宽度匹配，如果前面的匹配原所匹配的文本_不_出现在其后的匹配的文本之
        前。换而言之，如果在当前或者前一行中没有任何位置这个匹配原可以匹配而且
        它匹配文本刚好紧贴在其后匹配之前。|<a href="pattern.html#%2Fzero-width">/zero-width</a>|  <code class="special">{Vi 无此功能}</code>
        和 Perl 的 '(?&lt;!pattern)" 类似，但是 Vim 允许使用非固定宽度的模式。
        该倍数所引用的匹配原必须紧贴在其后匹配之前，所以这个匹配原可以用 ".*“
        结尾。警告：该倍数项可能会很慢  (因为在匹配之前的许多位置都要被检查)。
<code class="section">        示例                    匹配 </code>
        \(foo\)\@&lt;!bar          任何不在 "foobar" 中的 "bar"
        \(\/\/.*\)\@\&lt;!in       不在 "//" 之后 (中间可以有间隔) 的 "in"

                                                        <b class="vimtag">*<a name="%2F\@%3E">/\@&gt;</a>*</b>
\@&gt;     匹配前面的匹配原时要求完整匹配 (不能回溯)。<code class="special">{Vi 无此功能}</code>
        类似 Perl 中的 "(?&gt;pattern)"。
<code class="section">        示例            匹配 </code>
        \(a*\)\@&gt;a      无 ("a*" 用尽了所有的 "a"，后面不可能再有)

        试图匹配前面的匹配原，就如同匹配一个完整的模式那样。如果以后无法匹配，
        不会用较短的子模式或者任何其它的方法来重试该匹配原。<code class="note">注意</code>观察以下两者的
        不同: "a*b" 和 "a*ab" 都匹配 "aaab"，但是后者中的 "a*" 仅仅匹配前两个
        "a"。"\(a*\)\@&gt;ab" 不会匹配 "aaab"，因为 "a*" 匹配了 "aaa"  (尽可能多
        的 "a")，导致 "ab" 无法匹配。


</pre><hr class="doubleline" /><pre>
<h4>6.  普通匹配原                                  <b class="vimtag">*<a name="pattern-atoms">pattern-atoms</a>*</b></h4>
一个普通匹配原可能是:

                                                        <b class="vimtag">*<a name="%2F^">/^</a>*</b>
^       在模式起点或在 "\|"，"\("，"\%("，"\n" 之后: 匹配行首；在其它位置
        匹配 '^' 字符。 |<a href="pattern.html#%2Fzero-width">/zero-width</a>|
<code class="section">        示例            匹配 </code>
        ^beep(          C 函数 "beep" 开始的地方 (很可能)。

                                                        <b class="vimtag">*<a name="%2F\^">/\^</a>*</b>
\^      匹配原字符 '^'。可以用于任何位置。

                                                        <b class="vimtag">*<a name="%2F\_^">/\_^</a>*</b>
\_^     匹配行首。|<a href="pattern.html#%2Fzero-width">/zero-width</a>| 可以被用于任何位置。
<code class="section">        示例            匹配 </code>
        \_s*\_^foo      空白字符及空行，后接行首的 "foo"。

                                                        <b class="vimtag">*<a name="%2F$">/$</a>*</b>
$       在模式终点或 "\|"，"\)" ("\v" 之后的 "|"，")" ) 之前: 匹配行尾 <code class="special">&lt;EOL&gt;</code>;
        其它位置，匹配原字符 '$'。|<a href="pattern.html#%2Fzero-width">/zero-width</a>|

                                                        <b class="vimtag">*<a name="%2F\$">/\$</a>*</b>
\$      匹配原字符 '$'。可以被用于任何位置。

                                                        <b class="vimtag">*<a name="%2F\_$">/\_$</a>*</b>
\_$     匹配行尾。|<a href="pattern.html#%2Fzero-width">/zero-width</a>|  可以被用于任何位置。<code class="note">注意</code>："a\_$b" 永远无法
        匹配，因为 "b" 不能匹配行尾。可以使用 "a\nb" |<a href="pattern.html#%2F\n">/\n</a>|。
<code class="section">        示例            匹配 </code>
        foo\_$\_s*      "foo" 在行尾，后接空白字符及空行

.       ('nomagic' 的情形: \.)                          <b class="vimtag">*<a name="%2F.">/.</a>*</b> <b class="vimtag">*<a name="%2F\.">/\.</a>*</b>
        匹配任何单个字符，不包括行尾。

                                                        <b class="vimtag">*<a name="%2F\_.">/\_.</a>*</b>
\_.     匹配任何单个字符，或行尾。当心："\_.*" 会一直匹配到缓冲区结尾！

                                                        <b class="vimtag">*<a name="%2F\%3C">/\&lt;</a>*</b>
\&lt;      匹配单词起点：下一个字符是单词的首字符。'iskeyword' 选项指定那些是
        组成单词的字符。|<a href="pattern.html#%2Fzero-width">/zero-width</a>|

                                                        <b class="vimtag">*<a name="%2F\%3E">/\&gt;</a>*</b>
\&gt;      匹配单词终点：前一个字符是单词的尾字符。'iskeyword' 选项指定那些是
        组成单词的字符。|<a href="pattern.html#%2Fzero-width">/zero-width</a>|

                                                        <b class="vimtag">*<a name="%2F\zs">/\zs</a>*</b>
\zs     匹配任何位置，并将匹配起始处置于该处: 下一个字符将是整个匹配的第一个
        字符。|<a href="pattern.html#%2Fzero-width">/zero-width</a>|
        可以被多次使用，最后一个分支中的将被选中。
        例如:
<code class="example">                "^\s*\zsif"</code>
        匹配行首的 "if"，忽略所有空白字符。
        可以使用多次，但实际使用最后一次在匹配的分支里遇到的。例如:
<code class="example">                /\(.\<code class="special">{-}</code>\zsFab\)\<code class="special">{3}</code></code>
        找到第三次出现的 "Fab"。
        <code class="special">{Vi 无此功能}</code> <code class="special">{only 只有在编译时加入 +syntax 特性才可用}</code>
                                                        <b class="vimtag">*<a name="%2F\ze">/\ze</a>*</b>
\ze     匹配任何位置，并将匹配结尾处置于该处: 前一个字符将是整个匹配的最后一个
        字符。|<a href="pattern.html#%2Fzero-width">/zero-width</a>|
        可以被多次使用，最后一个分支中的将被选中。
        例如: "end\ze\(if\|for\)" 匹配 "endif" 和 "endfor" 中的 "end"。
        <code class="special">{Vi 无此功能}</code> <code class="special">{only 只有在编译时加入 +syntax 特性才可用}</code>

                                                <b class="vimtag">*<a name="%2F\%^">/\%^</a>*</b> <b class="vimtag">*<a name="start-of-file">start-of-file</a>*</b>
\%^     匹配文件头。当用于一个字符串时，匹配字符串起始处。<code class="special">{Vi 无此功能}</code>
        例如，要查找一个文件中首次出现 "VIM" 的地方:
<code class="example">                /\%^\_.\<code class="special">{-}</code>\zsVIM</code>

                                                <b class="vimtag">*<a name="%2F\%$">/\%$</a>*</b> <b class="vimtag">*<a name="end-of-file">end-of-file</a>*</b>
\%$     匹配文件尾。当用于一个字符串时，匹配字符串结束处。<code class="special">{Vi 无此功能}</code>
        <code class="note">注意</code> 下面的模式不匹配文件中的最后一个 "VIM":
<code class="example">                /VIM\_.\<code class="special">{-}</code>\%$</code>
        它会找到下一个 VIM，因为其后的部分总会匹配。这个才能匹配文件
        中的最后一个 "VIM":
<code class="example">                /VIM\ze\(\(VIM\)\@!\_.\)*\%$</code>
        这使用了 |<a href="pattern.html#%2F\@!">/\@!</a>| 来确定在第一 "VIM" 之后无法再次匹配 "VIM"。
        从文件尾部向前搜索会容易些!

                                                <b class="vimtag">*<a name="%2F\%%23">/\%#</a>*</b> <b class="vimtag">*<a name="cursor-position">cursor-position</a>*</b>
\%#     匹配光标位置。仅对显示于窗口内的缓冲有效。<code class="special">{Vi 无此功能}</code>
        警 告: 如果使用了该模式之后光标被移动，结果会成为无效的。Vim 不会自动的
        更新匹配。这对语法高亮和 'hlsearch' 有更大的关系。换言之: 在光标移动时
        显示并不因此而更新。Vim 只更新改动的行 (整行被更新) 或用户使用 |<a href="various.html#CTRL-L">CTRL-L</a>|
        命令时 (整个屏幕被更新)。例如，要高亮显示光标下的单词:
<code class="example">                /\k<b class="vimtag">*<a name="\%%23\k">\%#\k</a>*</b></code>
        当设定了 'hlsearch' 时，你移动光标并作更改就能清楚的看到更新的情况。

                                                <b class="vimtag">*<a name="%2F\%l">/\%l</a>*</b> <b class="vimtag">*<a name="%2F\%%3El">/\%&gt;l</a>*</b> <b class="vimtag">*<a name="%2F\%%3Cl">/\%&lt;l</a>*</b>
\%23l   在一个指定的行内进行匹配。
\%&lt;23l  在一个指定的行上方进行匹配。
\%&gt;23l  在一个指定的行下方进行匹配。
        这三个可以被用来匹配缓冲内的特定行。"23" 可以是任何行号。第一行为 1。
        <code class="special">{Vi 无此功能}</code>
        警告：当插入和删除行时 Vim 不会自动更新匹配。这意味着语法加亮会出错。
        例如，要高亮显示光标所在行:
<code class="example">                :exe '/\%' . line(".") . 'l.*'</code>
        当 'hlsearch' 被设定时，你的移动会很清楚的被显示 (仅当匹配被更新时)

                                                <b class="vimtag">*<a name="%2F\%c">/\%c</a>*</b> <b class="vimtag">*<a name="%2F\%%3Ec">/\%&gt;c</a>*</b> <b class="vimtag">*<a name="%2F\%%3Cc">/\%&lt;c</a>*</b>
\%23c   在一个指定的列内进行匹配。
\%&lt;23c  在一个指定的列前进行匹配。
\%&gt;23c  在一个指定的列后进行匹配。
        这三个可以被用来匹配缓冲内的特定列。"23" 可以是任何列号。第一列为 1。
        事实上，列以字节计算 (因此对多字节字符来说是不准确的)。 <code class="special">{Vi 无此功能}</code>
        警 告：当插入和删除字符时 Vim 并不自动更新匹配。这意味着语法高亮很
        快就不正确了。
        例如，要高亮显示光标所在列:
<code class="example">                :exe '/\%' . col(".") . 'c'</code>
        当 'hlsearch' 被设定时，你的移动会很清楚的被显示 (仅当匹配被更新时)
        一个匹配第 44 列单个字节的例子:
<code class="example">                /\%&gt;43c.\%&lt;46c</code>
        <code class="note">注意</code>："\%&lt;46c" 匹配第 45 列，而 "." 匹配 44 列的一个字节。

                                                <b class="vimtag">*<a name="%2F\%v">/\%v</a>*</b> <b class="vimtag">*<a name="%2F\%%3Ev">/\%&gt;v</a>*</b> <b class="vimtag">*<a name="%2F\%%3Cv">/\%&lt;v</a>*</b>
\%23v   匹配指定虚拟列。
\%&lt;23v  匹配指定虚拟列之前。
\%&gt;23v  匹配指定虚拟列之后。
        这三个可以被用来匹配缓冲或字符串中指定的虚拟列。当匹配一个不在窗口内
        的缓冲时，当前窗口的选项值将被使用 (如, 'tabstop')。 "23" 可以是任何
        列号。第一列为 1。
        <code class="note">注意</code> 默写虚拟列位置永远无法被匹配，因为它们被包含在一个制表符或者其它
        占用超过一个屏幕字符的特殊字符。<code class="special">{Vi 无此功能}</code>
        警 告: 当删除和插入字符时 Vim 不会自动更新匹配。这意味着语法高亮很快
        就变得不对了。
        例如，要高亮显示所有位于虚拟第 72 列的字符:
<code class="example">                /\%&gt;72v.*</code>
        当设定了 'hlsearch' 选项时，如果你移动光标并做一些改动，更新的情况就
        会清楚的被显示了。
        要匹配直到第 17 列的文本:
<code class="example">                /.*\%17v</code>
        第 17 没有被包括，因为那是 "\%17v" 匹配的地方，而这是一个零宽度
        |<a href="pattern.html#%2Fzero-width">/zero-width</a>| 匹配，第 17 列没有被包括在匹配之中。这个也一样:
<code class="example">                /.*\%&lt;18v</code>


字符类: <code class="special">{Vi 无此功能}</code>
\i      标识符字符 (见 'isident' 选项)                  <b class="vimtag">*<a name="%2F\i">/\i</a>*</b>
\I      像 "\i"，但不包括数字字符                       <b class="vimtag">*<a name="%2F\I">/\I</a>*</b>
\k      关键字字符 (见 'iskeyword' 选项)                <b class="vimtag">*<a name="%2F\k">/\k</a>*</b>
\K      像 "\k"，但不包括数字字符                       <b class="vimtag">*<a name="%2F\K">/\K</a>*</b>
\f      文件名字符 (见 'isfname' 选项)                  <b class="vimtag">*<a name="%2F\f">/\f</a>*</b>
\F      像 "\f"，但不包括数字字符                       <b class="vimtag">*<a name="%2F\F">/\F</a>*</b>
\p      可打印字符 (见 'isprint' 选项)                  <b class="vimtag">*<a name="%2F\p">/\p</a>*</b>
\P      像 "\p"，但不包括数字字符                       <b class="vimtag">*<a name="%2F\P">/\P</a>*</b>

<code class="note">备注</code>: 上面也作用于多字节字符。下面的只匹配 ASCII 字符。

                                                <b class="vimtag">*<a name="whitespace">whitespace</a>*</b> <b class="vimtag">*<a name="white-space">white-space</a>*</b>
\s      空白字符； <code class="special">&lt;Space&gt;</code> 和 <code class="special">&lt;Tab&gt;</code>                     <b class="vimtag">*<a name="%2F\s">/\s</a>*</b>
\S      非空白字符：\s 之反                             <b class="vimtag">*<a name="%2F\S">/\S</a>*</b>
\d      数字:                           [0-9]           <b class="vimtag">*<a name="%2F\d">/\d</a>*</b>
\D      非数字:                         [^0-9]          <b class="vimtag">*<a name="%2F\D">/\D</a>*</b>
\x      十六进制数字:                   [0-9A-Fa-f]     <b class="vimtag">*<a name="%2F\x">/\x</a>*</b>
\X      非十六进制字符:                 [^0-9A-Fa-f]    <b class="vimtag">*<a name="%2F\X">/\X</a>*</b>
\o      八进制字符:                     [0-7]           <b class="vimtag">*<a name="%2F\o">/\o</a>*</b>
\O      非八进制字符:                   [^0-7]          <b class="vimtag">*<a name="%2F\O">/\O</a>*</b>
\w      单词字符:                       [0-9A-Za-z_]    <b class="vimtag">*<a name="%2F\w">/\w</a>*</b>
\W      非单词字符:                     [^0-9A-Za-z_]   <b class="vimtag">*<a name="%2F\W">/\W</a>*</b>
\h      单词首字符:                     [A-Za-z_]       <b class="vimtag">*<a name="%2F\h">/\h</a>*</b>
\H      非单词首字符:                   [^A-Za-z_]      <b class="vimtag">*<a name="%2F\H">/\H</a>*</b>
\a      英文字母字符:                   [A-Za-z]        <b class="vimtag">*<a name="%2F\a">/\a</a>*</b>
\A      非英文字母字符:                 [^A-Za-z]       <b class="vimtag">*<a name="%2F\A">/\A</a>*</b>
\l      小写字符:                       [a-z]           <b class="vimtag">*<a name="%2F\l">/\l</a>*</b>
\L      非小写字符:                     [^a-z]          <b class="vimtag">*<a name="%2F\L">/\L</a>*</b>
\u      大写字符:                       [A-Z]           <b class="vimtag">*<a name="%2F\u">/\u</a>*</b>
\U      非大写字符                      [^A-Z]          <b class="vimtag">*<a name="%2F\U">/\U</a>*</b>

        <code class="note">备注</code>: 使用匹配原比使用 [] 构造要快。

        <code class="note">备注</code>: 'ignorecase'，"\c" 和 "\C" 不能和字符类一起使用。

                        <b class="vimtag">*<a name="%2F\_">/\_</a>*</b> <b class="vimtag">*<a name="E63">E63</a>*</b> <b class="vimtag">*<a name="%2F\_i">/\_i</a>*</b> <b class="vimtag">*<a name="%2F\_I">/\_I</a>*</b> <b class="vimtag">*<a name="%2F\_k">/\_k</a>*</b> <b class="vimtag">*<a name="%2F\_K">/\_K</a>*</b> <b class="vimtag">*<a name="%2F\_f">/\_f</a>*</b> <b class="vimtag">*<a name="%2F\_F">/\_F</a>*</b>
                        <b class="vimtag">*<a name="%2F\_p">/\_p</a>*</b> <b class="vimtag">*<a name="%2F\_P">/\_P</a>*</b> <b class="vimtag">*<a name="%2F\_s">/\_s</a>*</b> <b class="vimtag">*<a name="%2F\_S">/\_S</a>*</b> <b class="vimtag">*<a name="%2F\_d">/\_d</a>*</b> <b class="vimtag">*<a name="%2F\_D">/\_D</a>*</b> <b class="vimtag">*<a name="%2F\_x">/\_x</a>*</b> <b class="vimtag">*<a name="%2F\_X">/\_X</a>*</b>
                        <b class="vimtag">*<a name="%2F\_o">/\_o</a>*</b> <b class="vimtag">*<a name="%2F\_O">/\_O</a>*</b> <b class="vimtag">*<a name="%2F\_w">/\_w</a>*</b> <b class="vimtag">*<a name="%2F\_W">/\_W</a>*</b> <b class="vimtag">*<a name="%2F\_h">/\_h</a>*</b> <b class="vimtag">*<a name="%2F\_H">/\_H</a>*</b> <b class="vimtag">*<a name="%2F\_a">/\_a</a>*</b> <b class="vimtag">*<a name="%2F\_A">/\_A</a>*</b>
                        <b class="vimtag">*<a name="%2F\_l">/\_l</a>*</b> <b class="vimtag">*<a name="%2F\_L">/\_L</a>*</b> <b class="vimtag">*<a name="%2F\_u">/\_u</a>*</b> <b class="vimtag">*<a name="%2F\_U">/\_U</a>*</b>
\_x     其中 x 可以是以上任意一个字符：包括行尾的字符类 (字符类结束)

\e      匹配 <code class="special">&lt;Esc&gt;</code>                                      <b class="vimtag">*<a name="%2F\e">/\e</a>*</b>
\t      匹配 <code class="special">&lt;Tab&gt;</code>                                      <b class="vimtag">*<a name="%2F\t">/\t</a>*</b>
\r      匹配 <code class="special">&lt;CR&gt;</code>                                       <b class="vimtag">*<a name="%2F\r">/\r</a>*</b>
\b      匹配 <code class="special">&lt;BS&gt;</code>                                       <b class="vimtag">*<a name="%2F\b">/\b</a>*</b>
\n      匹配行尾                                        <b class="vimtag">*<a name="%2F\n">/\n</a>*</b>
        当对一个字符串而不是缓冲区进行匹配时，匹配一个按本义出现的换行字符。

~       匹配上次给出的替换字串                          <b class="vimtag">*<a name="%2F%7E">/~</a>*</b> <b class="vimtag">*<a name="%2F\%7E">/\~</a>*</b>

\(\)    一个由转义的括号括起来的模式。                  <b class="vimtag">*<a name="%2F\(">/\(</a>*</b> <b class="vimtag">*<a name="%2F\(\)">/\(\)</a>*</b> <b class="vimtag">*<a name="%2F\)">/\)</a>*</b>
        例："\(^a\)" 匹配行首的 'a'。                   <b class="vimtag">*<a name="E51">E51</a>*</b> <b class="vimtag">*<a name="E54">E54</a>*</b> <b class="vimtag">*<a name="E55">E55</a>*</b>

\1      匹配第一个子表达式匹配的字串                    <b class="vimtag">*<a name="%2F\1">/\1</a>*</b> <b class="vimtag">*<a name="E65">E65</a>*</b>
        <code class="special">{Vi 无此功能}</code>
        例如: "\([a-z]\).\1" 匹配 "ata"，"ehe"，"tot" 等.
\2      象 "\1"，但使用第二子表达式,                    <b class="vimtag">*<a name="%2F\2">/\2</a>*</b>
   ...                                                  <b class="vimtag">*<a name="%2F\3">/\3</a>*</b>
\9      象 "\1", 但使用第三子表达式。                   <b class="vimtag">*<a name="%2F\9">/\9</a>*</b>
        <code class="note">备注</code>: 各组的标号是基于那一个 "\(" 先出现 (自左至右)，而非那一个先匹配。

\%(\)   一个由转义的括号括起来的模式。                  <b class="vimtag">*<a name="%2F\%(\)">/\%(\)</a>*</b> <b class="vimtag">*<a name="%2F\%(">/\%(</a>*</b> <b class="vimtag">*<a name="E53">E53</a>*</b>
        类似 \(\)，但不算作一个子表达式。这样做允许使用更多的群组，并且处理时
        会稍快些。
        <code class="special">{Vi 无此功能}</code>

x       一个没有特殊含义的单个字符，匹配其自身。

                                                        <b class="vimtag">*<a name="%2F\">/\</a>*</b> <b class="vimtag">*<a name="%2F\\">/\\</a>*</b>
\x      一个反斜杠带一个没有特殊含义的单个字符，保留做将来的扩展。

[]      ('nomagic' 情况下: \[])         <b class="vimtag">*<a name="%2F[]">/[]</a>*</b> <b class="vimtag">*<a name="%2F\[]">/\[]</a>*</b> <b class="vimtag">*<a name="%2F\_[]">/\_[]</a>*</b> <b class="vimtag">*<a name="%2Fcollection">/collection</a>*</b>
\_[]
        一个集合。一组由方括号括起来的字符。匹配集合中的任意一个单一字符。
<code class="section">        示例            匹配 </code>
        [xyz]           任意 'x'，'y' 或 'z'
        [a-zA-Z]$       行尾的任意一个字母字符
        \c[a-z]$        同上

        如果在集合前加上 "\_" 的话，该模式也将匹配行尾，这等价于集合里加上
        "\n"。 "^" 开始的模式也可以匹配行尾。因此 "\_[^ab]" 将匹配行尾以及任意
        非 "a" 或 "b" 的字符。这使其与 Vi 兼容：没有 "\_" 或 "\n"时，集合不匹
        配行尾。

        如果集合以 "^" 开始，它匹配任意_不在_集合内的字符："[^xyz]" 匹配任何
        不是 'x', 'y' 和 'z' 的字符。
        - 如果集合中的两个字符被以 '-' 隔开，表示它们之间的所有 ASCII 字符。例
          如， "[0-9]" 匹配任何十进制数位。
        - 一个字符类表达式被解释为该字符类代表的字符集合。Vim 支持以下字符类：
<code class="section">                          名称          内容 </code>
<b class="vimtag">*<a name="[:alnum:]">[:alnum:]</a>*</b>               [:alnum:]     字母和数字
<b class="vimtag">*<a name="[:alpha:]">[:alpha:]</a>*</b>               [:alpha:]     字母
<b class="vimtag">*<a name="[:blank:]">[:blank:]</a>*</b>               [:blank:]     空格和制表字符
<b class="vimtag">*<a name="[:cntrl:]">[:cntrl:]</a>*</b>               [:cntrl:]     控制字符
<b class="vimtag">*<a name="[:digit:]">[:digit:]</a>*</b>               [:digit:]     十进制数位
<b class="vimtag">*<a name="[:graph:]">[:graph:]</a>*</b>               [:graph:]     可打印字符 (不包括空格)
<b class="vimtag">*<a name="[:lower:]">[:lower:]</a>*</b>               [:lower:]     小写字母 (使用 'ignorecase' 时代表所有
                                        字母)
<b class="vimtag">*<a name="[:print:]">[:print:]</a>*</b>               [:print:]     可打印字符 (包括空格)
<b class="vimtag">*<a name="[:punct:]">[:punct:]</a>*</b>               [:punct:]     标点字符
<b class="vimtag">*<a name="[:space:]">[:space:]</a>*</b>               [:space:]     空白字符
<b class="vimtag">*<a name="[:upper:]">[:upper:]</a>*</b>               [:upper:]     大写字母 (使用 'ignorecase' 时代表所有
                                        字母)
<b class="vimtag">*<a name="[:xdigit:]">[:xdigit:]</a>*</b>              [:xdigit:]    十六进制数位
<b class="vimtag">*<a name="[:return:]">[:return:]</a>*</b>              [:return:]    字符 <code class="special">&lt;CR&gt;</code>
<b class="vimtag">*<a name="[:tab:]">[:tab:]</a>*</b>                 [:tab:]       字符 <code class="special">&lt;Tab&gt;</code>
<b class="vimtag">*<a name="[:escape:]">[:escape:]</a>*</b>              [:escape:]    字符 <code class="special">&lt;Esc&gt;</code>
<b class="vimtag">*<a name="[:backspace:]">[:backspace:]</a>*</b>           [:backspace:] 字符 <code class="special">&lt;BS&gt;</code>
          字符类表达式中的方括号是对于集合的补充。例如，下面的模式是一个
          UNIX 文件名: "[-./[:alnum:]_~]\+"。即一组至少有一个字符的字符列表。
          其中每一个字符是 '-'，'.'，'/'，字母，数字，'_' 或 '~' 中的一个。
          这些项仅对 8 位字符有效。
                                                          <b class="vimtag">*<a name="%2F\]">/\]</a>*</b>
        - 要在集合之内包括字符 ']'，^'，'-' 或 '\'，只需在该字符前加上反斜杠：
          "[xyz\]]"，"[\^xyz]"，"[xy\-z]" 和 "[xyz\\]"。 (<code class="note">备注</code>: POSIX 不支持这
          种反斜杠的用法)。
          对于 ']' 你也可以将其作为第一个字符 (但可能在 "^" 之后) 而无须转义：
          "[]xyz]" 或 "[^]xyz]"  <code class="special">{Vi 无此功能}</code>。
          对于 '-' 你也可以将其作为第一个或最后一个字符："[-xyz]"， "[^-xyz]"
          或 "[xyz-]"。
          对于 '\' 你也可以将其放置在非 "^]-\bertn"的任何一个别的字符之前而无
          须转义："[\xyz]" 匹配 '\'，'x'，'y' 及 'z'。但是用 "\\" 好些，因为将
          来的扩展可能会在 '\' 之后使用其它字符。
        - 当 'cpoptions' 中不包括 'l' 标志时，以下转义是可用的 <code class="special">{Vi 无此功能}</code>：
                \e      <code class="special">&lt;Esc&gt;</code>
                \t      <code class="special">&lt;Tab&gt;</code>
                \r      <code class="special">&lt;CR&gt;</code>    (不是行尾！)
                \b      <code class="special">&lt;BS&gt;</code>
          <code class="note">备注</code>: 这些额外的转义码不能用在方括号 [] 之内！
        - 用集合来匹配可能会很慢。因为每个字符都要和集合中的每一个字符作比较。
          尽可能使用上面提到的匹配原。例如：同样是匹配数字，"\d" 要比 "[0-9]"
          快的多。

                                                <b class="vimtag">*<a name="%2F\%[]">/\%[]</a>*</b> <b class="vimtag">*<a name="E69">E69</a>*</b> <b class="vimtag">*<a name="E70">E70</a>*</b> <b class="vimtag">*<a name="E369">E369</a>*</b>
\%[]    一个可能匹配的匹配原列表。它总能匹配，但试图匹配尽量多的匹配原，而在第
        一个不匹配的地方终止。例如：
<code class="example">                /r\%[ead]</code>
        匹配 "r"，"re"，"rea" 或者 "read"。最长可能的匹配被采用。下面例子可以
        用来匹配 Ex 命令 "function"，其中 "fu" 是必须的而 "nction" 是可选的:
<code class="example">                /\<code class="special">&lt;fu\%[nction]\&gt;</code></code>
        这里用到了单词结尾 "\&gt;" 来避免匹配 "full" 中的 "fu"。
        当要匹配的不是普通字符时，问题就变得更复杂了。你不一定会经常这样做，但
        这么做的确是可能的。例如:
<code class="example">                /\<code class="special">&lt;r\%[[eo]ad]\&gt;</code></code>
        匹配 "r"，"re"，"ro"，"rea"，"roa"，"read" 及 "road"。
        <code class="special">{only 只在编译时加入 +syntax 特征时有效}</code>


</pre><hr class="doubleline" /><pre>
<h4>7. 忽略大小写                                           <b class="vimtag">*<a name="%2Fignorecase">/ignorecase</a>*</b></h4>
如果选项 'ignorecase' 被设定为打开的话，一般字符的大小写就会被忽略。当模式
只包含小写字符时 'smartcase' 会被设成忽略大小写。
                                                        <b class="vimtag">*<a name="%2F\c">/\c</a>*</b> <b class="vimtag">*<a name="%2F\C">/\C</a>*</b>
如果模式的任何位置出现了 "\c"，整个模式会被象打开 'ignorecase' 一样被处理。
真正的 'ignorecase' 和 'smartcase' 的值会被忽略。"\C" 的效果恰好相反: 强制
对整个模式匹配大小写。
<code class="special">{only Vim 支持 \c 和 \C}</code>
<code class="note">注意</code> 'ignorecase'，"\c" 和 "\C" 对字符类无效。

例如:
<code class="section">        模式    'ignorecase'  'smartcase'       匹配 </code>
        foo       off           -               foo
        foo       on            -               foo Foo FOO
        Foo       on            off             foo Foo FOO
        Foo       on            on                  Foo
        \cfoo     -             -               foo Foo FOO
        foo\C     -             -               foo

                                                        <b class="vimtag">*<a name="%2F\Z">/\Z</a>*</b>
如果模式的任何位置出现了 "\Z"，合成用字符将被忽略。这样，只有基本字符需要匹配，
合成用字符或有不同甚至其数量也可以不定。这一功能只在 'encoding' 为 'utf-8' 时
有意义。

技术细节:                                               <b class="vimtag">*<a name="NL-used-for-Nul">NL-used-for-Nul</a>*</b>
文件中的 <code class="special">&lt;Nul&gt;</code> 字符在内存中被存储为 <code class="special">&lt;NL&gt;</code>。显示为 "^@"。翻译是在读写文件时完成
的。为了在查找模式中匹配 <code class="special">&lt;Nul&gt;</code> 你可以使用 <code class="keystroke">CTRL-@</code> 或 "<code class="keystroke">CTRL-V</code> 000"。这应该不出你
的所料。内部该字符被替换为 <code class="special">&lt;NL&gt;</code>。不寻常的是键入 <code class="keystroke">CTRL-V</code> <code class="keystroke">CTRL-J</code> 同样插入一个
<code class="special">&lt;NL&gt;</code>，因此也搜索文件中的 <code class="special">&lt;Nul&gt;</code>.  <code class="special">{Vi 则完全不能处理文件中的 <code class="special">&lt;Nul&gt;</code> 字符}</code>

                                                        <b class="vimtag">*<a name="CR-used-for-NL">CR-used-for-NL</a>*</b>
当 'fileformat' 为 "mac" 时，<code class="special">&lt;NL&gt;</code> 字符在内部储存为 <code class="special">&lt;CR&gt;</code>。显示为 "^M"。其它的
类似以 <code class="special">&lt;NL&gt;</code> 作为 <code class="special">&lt;Nul&gt;</code> 的用法。

在作表达式求值时，模式中的 <code class="special">&lt;NL&gt;</code> 字符匹配字符串中的 <code class="special">&lt;NL&gt;</code>。用 "\n" (反斜杠 n) 来
匹配 <code class="special">&lt;NL&gt;</code> 在这里是行不通的，它仅对缓冲内的文本有效。

                                                        <b class="vimtag">*<a name="pattern-multi-byte">pattern-multi-byte</a>*</b>
模式匹配对于多字节字符同样适用。大体上使用并无区别，不过要<code class="note">注意</code>无效字节可能引起
的问题，一个包含无效字节的模式永远不会得到匹配。

</pre><hr class="doubleline" /><pre>
<h4>8. 与 Perl 模式的比较                                   <b class="vimtag">*<a name="perl-patterns">perl-patterns</a>*</b></h4>
Vim 中的正则表达式和 Perl 的在功能上来说非常相似。它们之间的区别基本上只是在表
示方法上。这里给出一个它们之间的区别的总结:

<code class="section">功能                            Vim 方言        Perl 方言 </code>
</pre><hr class="singleline" /><pre>
强制不区分大小写                \c              (?i)
强制区分大小写                  \C              (?-i)
不须被引用的群组                \%(atom)        (?:atom)
保守的倍数描述                  \<code class="special">{-n,m}</code>         *?，+?，??，<code class="special">{}</code>?
零宽度匹配                      atom\@=         (?=atom)
零宽度否匹配                    atom\@!         (?!atom)
零宽度反向匹配                  atom\@&lt;=        (?&lt;=atom)
零宽度反向否匹配                atom\@&lt;!        (?&lt;!atom)
无重试匹配                      atom\@&gt;         (?&gt;atom)

Vim 和 Perl 匹配一个字符串中的新行时有所不同:

在 Perl 里，^ 和 $ 缺省只匹配文本的开始和结尾。但是你也可以设定 'm' 标志，
用来匹配内嵌的换行符。你还可以设定 's' 标志，使 . 可以也用来匹配换行符。 (
顺便提一下，这两个标志都可以用类似上面提到的 i 标志的用法来在模式内部改动。)

另一方面，Vim 中的 ^ 和 $ 永远匹配内嵌的换行符。同时，有另外的两个匹配原：
\%^ 和 \%$ 可以分别被用来仅仅匹配文本的起始和结尾。Vim 用 \_ "修饰符" 来
解决第二个问题：把它放在一个 . 或一个字符类之前，结果的模式就可以匹配换行
字符。

最后，以下这些结构是 Perl 独有的：
- 在正则表达式内执行任意代码:  (?<code class="special">{perl code}</code>)
- 条件表达式:  (?(condition)true-expr|false-expr)

下面是 Vim 独有的：
- 改变模式的 'magic' 属性:  \v \V \m \M 对于避免反斜杠非常有用)
- 可选匹配原序列:  \%[atoms]
- \&amp;  (相对于 \| 来说 就象 "与" 相对于 "或"；它强迫多个模式在同一个位置匹配)
- 通过行/列号匹配:  \%5l \%5c \%5v
- 限制正则表达式的 "返回值":  \zs \ze

</pre><hr class="doubleline" /><pre>
<h4>9. 高亮显示匹配                                         <b class="vimtag">*<a name="match-highlight">match-highlight</a>*</b></h4>
                                                        <b class="vimtag">*<a name=":mat">:mat</a>*</b> <b class="vimtag">*<a name=":match">:match</a>*</b>
:mat[ch] <code class="special">{group}</code> /<code class="special">{pattern}</code>/
                定义一个要在当前窗口高亮显示的模式。会被以 <code class="special">{group}</code> 高亮。例:
<code class="example">                        :highlight MyGroup ctermbg=green guibg=green</code>
<code class="example">                        :match MyGroup /TODO/</code>
                除了 // 任何字符都可以被用来表示一个 <code class="special">{pattern}</code> 的开始和结束。
                要当心某些特殊的字符，例如 '"' 和 '|'。
                <code class="special">{group}</code> 在该命令被执行时必须是已经定义好的。该匹配会否决
                'hlsearch' 所定义的高亮。
                'ignorecase' 不起作用。你得在模式中使用 |<a href="pattern.html#%2F\c">/\c</a>| 来达到目的。
                否则大小写是区分的。
                <code class="note">注意</code> 使用 'hlsearch' 高亮显示上次使用的查找模式对所有窗口都
                有效，而以 ":match" 定义的模式仅仅对当前窗口生效。当切换至
                另一个缓冲时，该设定被保留。
                另一个例子，高亮显示所有虚拟第 72 列之后的文本:
<code class="example">                        :highlight rightMargin term=bold ctermfg=blue guifg=blue</code>
<code class="example">                        :match rightMargin /.\%&gt;72v/</code>
                要高亮显示所有位于虚拟第 7 列的文本:
<code class="example">                        :highlight col8 ctermbg=grey guibg=grey</code>
<code class="example">                        :match col8 /\%<code class="special">&lt;8v.\%&gt;</code>7v/</code>
                <code class="note">注意</code> 用两个项是为了匹配那些占用超过一列的字符，例如 TAB。

:mat[ch]
:mat[ch] none
                清除前面定义的匹配模式。

 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 2006年 06月 24日 星期六 00:27:59 UTC</i></p>
</body>
</html>
