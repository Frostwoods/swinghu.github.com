<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>VIM: tips</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>TIPS</h2>
<pre>
<b class="vimtag">*<a name="tips.txt">tips.txt</a>*</b>      For Vim version 6.4.  最近更新: 2006年2月


                     Vim 参考手册    作者：Bram Moolenaar
           <code class="vim">译者</code>: iCrazy <code class="special">&lt;icrazy@ustc.edu&gt;</code>  http://vimcdoc.sf.net


使用 Vim 的技巧                                         <b class="vimtag">*<a name="tips">tips</a>*</b>

别忘记浏览用户手册，里面有很多实用的技巧 |<a href="usr_toc.html#usr_toc.txt">usr_toc.txt</a>|.

编辑 C 程序                                     |<a href="tips.html#C-editing">C-editing</a>|
查找使用标识符的地方                            |<a href="tips.html#ident-search">ident-search</a>|
在 xterm 中切换屏幕                             |<a href="tips.html#xterm-screens">xterm-screens</a>|
在插入模式下滚屏                                |<a href="tips.html#scroll-insert">scroll-insert</a>|
平滑的滚屏                                      |<a href="tips.html#scroll-smooth">scroll-smooth</a>|
纠正普通的录入错误                              |<a href="tips.html#type-mistakes">type-mistakes</a>|
统计单词，行数                                  |<a href="tips.html#count-items">count-items</a>|
恢复光标位置                                    |<a href="tips.html#restore-position">restore-position</a>|
文件更名                                        |<a href="tips.html#rename-files">rename-files</a>|
加速外部命令的执行                              |<a href="tips.html#speed-up">speed-up</a>|
一些有用的映射                                  |<a href="tips.html#useful-mappings">useful-mappings</a>|
压缩帮助文件                                    |<a href="tips.html#gzip-helpfile">gzip-helpfile</a>|
十六进制编辑                                    |<a href="tips.html#hex-editing">hex-editing</a>|
在一个窗口中执行 shell 命令                     |<a href="tips.html#shell-window">shell-window</a>|
在自动命令中使用符号 <code class="special">&lt;&gt;</code>                         |<a href="tips.html#autocmd-%3C%3E">autocmd-&lt;&gt;</a>|

</pre><hr class="doubleline" /><pre>
<h4>编辑 C 程序                                             <b class="vimtag">*<a name="C-editing">C-editing</a>*</b></h4>
Vim 里面有不少功能可以帮助你们编辑 C 程序。以下是一个概括，你们可以使用标签
跳转到具体的内容中去：

|<a href="usr_29.html#usr_29.txt">usr_29.txt</a>|            用户手册中关于在程序的不同部分间移动的内容。
|<a href="usr_30.html#usr_30.txt">usr_30.txt</a>|            用户手册中关于编辑程序的内容。
|<a href="indent.html#C-indenting">C-indenting</a>|           输入时自动设置每行的缩进。
|<a href="change.html#%20">=</a>|                     重新缩进一些行。
|<a href="change.html#format-comments">format-comments</a>|       对注释进行编排。

|<a href="tagsrch.html#:checkpath">:checkpath</a>|            显示所有被包含的文件 (嵌套)。
|<a href="tagsrch.html#[i">[i</a>|                    在当前和被包含的文件中查找光标当前位置的标识符。
|<a href="tagsrch.html#[_CTRL-I">[_CTRL-I</a>|              跳转到 "[i" 的匹配。
|<a href="tagsrch.html#[I">[I</a>|                    显示在当前和被包含的文件中现出光标所在位置标识符的
                        那些行。
|<a href="tagsrch.html#[d">[d</a>|                    在当前和被包含的文件中查找光标所在位置的标识符的定义
                        （define）。

|<a href="tagsrch.html#CTRL-]">CTRL-]</a>|                跳转到光标当前位置的标签处 （例如：一个函数的定义）。
|<a href="tagsrch.html#CTRL-T">CTRL-T</a>|                跳转到执行 <code class="keystroke">CTRL-]</code> 命令前的地方。
|<a href="tagsrch.html#:tselect">:tselect</a>|              从一连串匹配的标签中选出一个。

|<a href="pattern.html#gd">gd</a>|                    跳转到光标当前位置的局部变量的声明处。
|<a href="pattern.html#gD">gD</a>|                    跳转到光标当前位置的全局变量的声明处。

|<a href="editing.html#gf">gf</a>|                    跳转到光标当前位置的文件名表示的文件。

|<a href="motion.html#%">%</a>|                     跳转到匹配的(), <code class="special">{}</code>, [], /* */, #if, #else, #endif 处。
|<a href="motion.html#[%2F">[/</a>|                    跳转到上一个注释开始的位置。
|<a href="motion.html#]%2F">]/</a>|                    跳转到下一个注释结束的位置。
|<a href="motion.html#[%23">[#</a>|                    返回到未闭合的 #if、#ifdef 或 #else 处。
|<a href="motion.html#]%23">]#</a>|                    前进到未闭合的 #else 或 #endif 处。
|<a href="motion.html#[(">[(</a>|                    返回到未闭合的 '(' 处。
|<a href="motion.html#])">])</a>|                    前进到未闭合的 ')' 处。
|<a href="motion.html#[{">[{</a>|                    返回到未闭合的 '{' 处。
|<a href="motion.html#]}">]}</a>|                    前进到未闭合的 '}' 处。

|<a href="motion.html#v_ab">v_ab</a>|                  选中一个"块" ("a block")，从 "[(" 至 "])"，含括号
|<a href="motion.html#v_ib">v_ib</a>|                  选中一个"内部块" ("inner block")，从 "[(" 至 "])"
|<a href="motion.html#v_aB">v_aB</a>|                  选中一个"块" ("a block")，从 "[<code class="special">{" 至 "]}</code>"，含括号
|<a href="motion.html#v_iB">v_iB</a>|                  选中一个"内部块" ("inner block")，从 "[<code class="special">{" 至 "]}</code>"

</pre><hr class="doubleline" /><pre>
<h4>查找使用标识符的地方                                    <b class="vimtag">*<a name="ident-search">ident-search</a>*</b></h4>
你应该已经知道 |<a href="tagsrch.html#tags">tags</a>| 可以被用来跳转到定义函数和变量的地方。但是有时你希望跳
转到使用函数和变量的地方。可以用以下2种方法实现：
1. 使用 |<a href="quickfix.html#:grep">:grep</a>| 命令。这个应该可以在大多数 Unix 系统上工作，但是速度会比较慢
（因为它读取所有的文件），并且只能在一个目录中搜索。
2. 使用 ID 工具集。这个速度比较块而且可以搜索多个目录。它使用一个数据库来存放
定位信息。你需要一些额外的程序来使它得以工作，并且你必须使数据库不断保持更新。

使用 GNU id 工具集：

你所需要的：
- 安装 GNU id 工具集（mkid 是用来创建 ID 的，lid 是用来运行宏的）
- 一个在当前目录下名为 "ID" 的标识符数据库。你可以用 shell 命令 "mkid file1
  file2 .." 来创建它。

把这些添加写你的 .vimrc文件中：
<code class="example">        map _u :call ID_search()<code class="special">&lt;Bar&gt;</code>execute "/\\<code class="special">&lt;" . g:word . "\\&gt;</code>"<code class="special">&lt;CR&gt;</code></code>
<code class="example">        map _n :n<code class="special">&lt;Bar&gt;</code>execute "/\\<code class="special">&lt;" . g:word . "\\&gt;</code>"<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
<code class="example">        function! ID_search()</code>
<code class="example">          let g:word = expand("<code class="special">&lt;cword&gt;</code>")</code>
<code class="example">          let x = system("lid --key=none ". g:word)</code>
<code class="example">          let x = substitute(x, "\n", " ", "g")</code>
<code class="example">          execute "next " . x</code>
<code class="example">        endfun</code>
<code class="example"></code>
使用的时候，把光标放在一个单词上，敲入 "_u"，然后 vim 会读入含有这个单词的文
件。使用 "n"查找这个单词在相同文件中下一次的出现的地方。使用 "_n" 可以跳转到下一个
文件。

这写操作已经使用 id-utils-3.2（这是位于距你最近的 gnu ftp 镜像服务器上的档案
名称）测试通过了。

[这个的想法来自于 Andreas Kutschera]

</pre><hr class="doubleline" /><pre>
<h4>在 xterm 中切换屏幕                     <b class="vimtag">*<a name="xterm-screens">xterm-screens</a>*</b> <b class="vimtag">*<a name="xterm-save-screen">xterm-save-screen</a>*</b></h4>
(来源：comp.editors, 作者：Juergen Weigert, 回答一个问题的时候)

:&gt; 另一个问题就是退出 vim 后，屏幕内容就被留在那儿了，也就是说：我刚刚正在
:&gt; 查看（或编辑）的内容就被留在屏幕上了。我此前执行的命令（例如："ls"）的输出
:&gt; 就不见了，即在滚屏缓冲里不存在了。我知道有个办法可以在退出 vim 或其他类似
:&gt; 于 vi 的编辑器的时候恢复屏幕内容，但是我不知道该如何操作。请帮助我，谢谢！
:
:我认为可能有人可以回答这个问题。我认为 vim 和 vi 在某个特定
:的 xterm 安装下和别的程序一样工作。

他们并不一定完全相同，因为这牵扯到一个 termcap 对 terminfo 的问题。你们应该知
道针对一种特定的终端，有2种数据库可以用来描述它的属性： termcap 和 terminfo。
当它们中的条目不同，而且以上问题中的一个程序使用 terminfo，另一个使用 termcap
时，两个程序会出现差异（请参见： |<a href="various.html#+terminfo">+terminfo</a>|）。

在你的问题中，你可能需要以下的控制序列：^[[?47h 和 ^[[?47l。他们用来在 xterm
和主屏幕缓冲中轮流切换。如果你希望工作得更加有效率，如下的命令序列
<code class="example">        echo -n "^[[?47h"; vim ... ; echo -n "^[[?47l"</code>
可能就是你所需要的。（我用符号 ^[ 表示 ESC 字符，往后你还会看到数据库使用 \E
来表示它）。

在启动的时候，vim 把 termcap 中变量 ti (terminfo:smcup)的值显示在终端上。退出
的时候，它显示 te (terminfo: rmcup) 的值。这样一来，这2个变量正好处于以上所述
的控制序列需要被执行的位置。

把你的 xterm termcap 条目（在 /etc/termcap 中）和 xterm terminfo 条目（用
/usr/5bin/infocmp -C xterm 得到）比较一下。两者应该都会有与下面类似的条目：
<code class="example">        :te=\E[2J\E[?47l\E8:ti=\E7\E[?47h:</code>
<code class="example"></code>
附：如果你发现了任何差异，那么最好让某人（或许是你的系统管理员）彻底的检查
    一下 termcap 和 terminfo 的一致性。

<code class="note">备注</code> 1: 如果你在 feature.h 中定义了 FEAT_XTERM_SAVE 之后又重新编译了 Vim，那
么内置的 xterm 会有上述的 "te" 和 "ti" 条目。

<code class="note">备注</code> 2: 如果你希望禁止屏幕切换，并且不希望改变你的 termcap，你可以在你的
.vimrc 文件中加入这一行：
<code class="example">        :set t_ti= t_te=</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>在插入模式下滚屏                                        <b class="vimtag">*<a name="scroll-insert">scroll-insert</a>*</b></h4>
如果你处于插入模式下并且希望看一些恰好在屏幕范围以外的东西，你可以使用 <code class="keystroke">CTRL-X</code>
<code class="keystroke">CTRL-E</code> 和 <code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-Y</code> 来滚屏。
                                                |<a href="insert.html#i_CTRL-X_CTRL-E">i_CTRL-X_CTRL-E</a>|

为了使这个简单些，你可以用这些映射:
<code class="example">        :inoremap <code class="special">&lt;C-E&gt;</code> <code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-E&gt;</code></code>
<code class="example">        :inoremap <code class="special">&lt;C-Y&gt;</code> <code class="special">&lt;C-X&gt;</code><code class="special">&lt;C-Y&gt;</code></code>
（逐字敲入这些字符，并确认 '&lt;' 标志不在 'cpoptions' 选项中）。
不过这样你就不能使用从光标上一行/下一行拷贝文字的功能了 |<a href="insert.html#i_CTRL-E">i_CTRL-E</a>|。

你还可以考虑把 'scrolloff' 设置得大一些，这样你就总能看到光标附近的上下文了。
如果 'scrolloff' 的值大于窗口高度的一半，在向上或向下移动光标时，文字会上下卷
动，但是光标会始终停留在屏幕中间的位置。

</pre><hr class="doubleline" /><pre>
<h4>平滑的滚屏                                              <b class="vimtag">*<a name="scroll-smooth">scroll-smooth</a>*</b></h4>
如果你希望你的滚屏更加平滑一些，你可以使用以下的映射：
<code class="example">        :map <code class="special">&lt;C-U&gt;</code> <code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code><code class="special">&lt;C-Y&gt;</code></code>
<code class="example">        :map <code class="special">&lt;C-D&gt;</code> <code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code><code class="special">&lt;C-E&gt;</code></code>
<code class="example"></code>
（逐字敲入这些字符，并确认 '&lt;' 标志不在 'cpoptions' 选项中）。

</pre><hr class="doubleline" /><pre>
<h4>纠正普通的录入错误                                      <b class="vimtag">*<a name="type-mistakes">type-mistakes</a>*</b></h4>
如果有一些单词你总是敲错，你可以使用缩写来改正它们。例如：
<code class="example">        :ab teh the</code>
<code class="example">        :ab fro for</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>统计单词，行数等                                        <b class="vimtag">*<a name="count-items">count-items</a>*</b></h4>
如果需要统计缓冲中一个模式（pattern）出现的频率，需要把 'report' 置为0，然后
用替换命令把模式替换成它自己。Vim 报告的已替换的数目就是模式出现的次数。例：
<code class="example"></code>
<code class="example">        :set report=0</code>
<code class="example">        :%s/./&amp;/g               characters</code>
<code class="example">        :%s/\i\+/&amp;/g            words</code>
<code class="example">        :%s/^                   lines</code>
<code class="example">        :%s/the/&amp;/g             "the" anywhere</code>
<code class="example">        :%s/\<code class="special">&lt;the\&gt;</code>/&amp;/g         "the" as a word</code>
<code class="example"></code>
你可能希望复位 'hlsearch' 或者使用 ":nohlsearch"。

如果 'modifiable' 选项是关的，这些就失效了。另一种办法就是在 Visual 模式下使用
|<a href="editing.html#v_g_CTRL-G">v_g_CTRL-G</a>|。

                                                        <b class="vimtag">*<a name="count-bytes">count-bytes</a>*</b>
如果你想数字节数，你可以这样做：

        选中那些字符（块选择也可以）
        使用 "y" 来拷贝这些字符
        使用 strlen() 函数:
<code class="example">                :echo strlen(@")</code>
一个换行符被当做一个字节。

</pre><hr class="doubleline" /><pre>
<h4>恢复光标位置                                            <b class="vimtag">*<a name="restore-position">restore-position</a>*</b></h4>
有时你希望写一个映射，让它在文件中的其他地方做一些修改然后恢复光标的位置
（不使当前的文本卷屏）。例如，修改一个文件中的日期标记：
<code class="example"></code>
<code class="example">   :map <code class="special">&lt;F2&gt;</code> msHmtgg/Last [cC]hange:\s*/e+1<code class="special">&lt;CR&gt;</code>"_D"=strftime("%Y %b %d")<code class="special">&lt;CR&gt;</code>p'tzt`s</code>
<code class="example"></code>
分解出保存位置的命令：
        ms      把光标位置存放在标记 's' 中
        H       跳转到当前屏幕的顶端
        mt      把这个位置存放在标记 't' 中

分解出恢复位置的命令：
        't      跳转到先前位于屏幕顶端的那一行
        zt      卷屏，使这一行位于屏幕的顶端
        `s      跳转到最初光标的位置

</pre><hr class="doubleline" /><pre>
<h4>文件更名                                                <b class="vimtag">*<a name="rename-files">rename-files</a>*</b></h4>
假如我有一个目录，里面有如下的文件（目录是随机选取的）：

buffer.c
charset.c
digraph.c
...

现在我希望把 *.c 更名为 *.bla。我可以这样做：
<code class="example"></code>
<code class="example">        $ vim</code>
<code class="example">        :r !ls *.c</code>
<code class="example">        :%s/\(.*\).c/mv &amp; \1.bla</code>
<code class="example">        :w !sh</code>
<code class="example">        :q!</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>加速外部命令的执行                                      <b class="vimtag">*<a name="speed-up">speed-up</a>*</b></h4>
在一些情况下，外部命令执行起来非常的慢。这个还会减慢 Unix 下的通配符扩展。这
儿有一些建议可以加快速度：

如果你的 .cshrc 文件（根据你使用的 shell，文件名可能不同）非常的长，你应该把
它分割成2节：需要和用户交互的、无需和用户交互的（经常被称作二级 shell）。当你
在 Vim 中执行一个类似 ":!ls" 的命令时，你就不需要和用户交互的那一部分（例如：
设置提示符）。把那些不必要的部分放到这些行后面去：
<code class="example"></code>
<code class="example">        if ($?prompt == 0) then</code>
<code class="example">                exit 0</code>
<code class="example">        endif</code>
<code class="example"></code>
另一个办法是在 'shell' 选项中包含 "-f" 参数，例如：
<code class="example"></code>
<code class="example">        :set shell=csh\ -f</code>
<code class="example"></code>
（这儿的反斜杠是必须的，这样才能在选项中表示一个空格）。
这样就会使 csh 完全跳过 .cshrc 文件。不过这样可能会造成一些程序不能正常运行。

</pre><hr class="doubleline" /><pre>
<h4>一些有用的映射                                  <b class="vimtag">*<a name="useful-mappings">useful-mappings</a>*</b></h4>
这里有一些人们喜欢使用的映射。

                                                        <b class="vimtag">*<a name="map-backtick">map-backtick</a>*</b>
<code class="example">        :map ' `</code>
使得单引号和 ' 一样工作。把光标移动到一个标记的第一列，而不是那一行的第一个非
空白字符。

                                                        <b class="vimtag">*<a name="emacs-keys">emacs-keys</a>*</b>
要在命令行上实现 Emacs 风格的编辑操作：
<code class="example">        " start of line</code>
<code class="example">        :cnoremap <code class="special">&lt;C-A&gt;</code>         <code class="special">&lt;Home&gt;</code></code>
<code class="example">        " back one character</code>
<code class="example">        :cnoremap <code class="special">&lt;C-B&gt;</code>         <code class="special">&lt;Left&gt;</code></code>
<code class="example">        " delete character under cursor</code>
<code class="example">        :cnoremap <code class="special">&lt;C-D&gt;</code>         <code class="special">&lt;Del&gt;</code></code>
<code class="example">        " end of line</code>
<code class="example">        :cnoremap <code class="special">&lt;C-E&gt;</code>         <code class="special">&lt;End&gt;</code></code>
<code class="example">        " forward one character</code>
<code class="example">        :cnoremap <code class="special">&lt;C-F&gt;</code>         <code class="special">&lt;Right&gt;</code></code>
<code class="example">        " recall newer command-line</code>
<code class="example">        :cnoremap <code class="special">&lt;C-N&gt;</code>         <code class="special">&lt;Down&gt;</code></code>
<code class="example">        " recall previous (older) command-line</code>
<code class="example">        :cnoremap <code class="special">&lt;C-P&gt;</code>         <code class="special">&lt;Up&gt;</code></code>
<code class="example">        " back one word</code>
<code class="example">        :cnoremap <code class="special">&lt;Esc&gt;</code><code class="special">&lt;C-B&gt;</code>    <code class="special">&lt;S-Left&gt;</code></code>
<code class="example">        " forward one word</code>
<code class="example">        :cnoremap <code class="special">&lt;Esc&gt;</code><code class="special">&lt;C-F&gt;</code>    <code class="special">&lt;S-Right&gt;</code></code>
<code class="example"></code>
<code class="note">备注</code>: 前提条件是 '&lt;' 标志不在 'cpoptions' 选项中。 |<a href="intro.html#%3C%3E">&lt;&gt;</a>|

                                                        <b class="vimtag">*<a name="format-bullet-list">format-bullet-list</a>*</b>
这个映射可以格式化任何 bullet 列表，不过它需要在每一个条目的上下都各有一
个空行。这些表达式命令可以用来对映射的部分进行注释：
<code class="example"></code>
<code class="example">        :let m =     ":map _f  :set ai<code class="special">&lt;CR&gt;</code>"   " 需要设置 'autoindent'</code>
<code class="example">        :let m = m . "{O<code class="special">&lt;Esc&gt;</code>"                " 在项目上面加入空行</code>
<code class="example">        :let m = m . "}{)^W"                  " 跳转到 bullet 之后的文本</code>
<code class="example">        :let m = m . "i     <code class="special">&lt;CR&gt;</code>     <code class="special">&lt;Esc&gt;</code>"   " 为缩进加空格</code>
<code class="example">        :let m = m . "gq}"                    " 格式化 bullet 之后的文本</code>
<code class="example">        :let m = m . "{dd"                    " 删除空行</code>
<code class="example">        :let m = m . "5lDJ"                   " 把文本放到 bullet 之后</code>
<code class="example">        :execute m                            |" 定义这个 mapping</code>
<code class="example"></code>
（符号 <code class="special">&lt;&gt;</code> |<a href="intro.html#%3C%3E">&lt;&gt;</a>|。  <code class="note">注意</code> 这些必须按照字面逐个输入。  ^W 是 "^" 和 "W"，而不是
<code class="keystroke">CTRL-W</code>。 如果 '&lt;' 标志不在 'cpoptions' 选项中，你可以把这些拷贝/粘贴到 Vim 中
去）

<code class="note">注意</code> 最后一个注释以 |" 开始，因为 ":execute" 不能直接识别一个注释。

你还需要把 'textwidth' 设置成一个非0值，例如：
<code class="example">        :set tw=70</code>
<code class="example"></code>
以下这个映射可以达到同样的效果，不过它从第一行获得列表的缩进(<code class="note">备注</code>: 这个
映射是在同一行中输入的，其中有很多空格):
<code class="example">        :map _f :set ai<code class="special">&lt;CR&gt;</code>}<code class="special">{a                                                          <code class="special">&lt;Esc&gt;</code>WWmmkD`mi<code class="special">&lt;CR&gt;</code><code class="special">&lt;Esc&gt;</code>kkddpJgq}</code>'mJO<code class="special">&lt;Esc&gt;</code>j</code>

                                                        <b class="vimtag">*<a name="collapse">collapse</a>*</b>
这2个映射可以把一连串的空行 (;b) 或空白行 (;n) 压缩到一行
<code class="example">    :map ;b   GoZ<code class="special">&lt;Esc&gt;</code>:g/^$/.,/./-j<code class="special">&lt;CR&gt;</code>Gdd</code>
<code class="example">    :map ;n   GoZ<code class="special">&lt;Esc&gt;</code>:g/^[ <code class="special">&lt;Tab&gt;</code>]*$/.,/[^ <code class="special">&lt;Tab&gt;</code>]/-j<code class="special">&lt;CR&gt;</code>Gdd</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>压缩帮助文件                                            <b class="vimtag">*<a name="gzip-helpfile">gzip-helpfile</a>*</b></h4>
对于那些磁盘空间极度紧张的人来说，你们可以压缩帮助文件。这样会使得查看帮助文
件时稍微慢一点，并且需要 "gzip" 这个程序的支持。

(1) 压缩所有帮助文件: "gzip doc/*.txt"。

(2) 编辑文件 "doc/tags"，用 ".txt.gz" 替换 ".txt"：
<code class="example">        :%s=\(\t.*\.txt\)\t=\1.gz\t=</code>
<code class="example"></code>
(3) 把这一行加入到你的 vimrc 文件中：
<code class="example">        set helpfile=<code class="special">{dirname}</code>/help.txt.gz</code>
<code class="example"></code>
这儿 <code class="special">{dirname}</code> 是存放帮助文件的目录。|<a href="pi_gzip.html#gzip">gzip</a>| 这个插件会负责解压缩这些文件的。
你必须肯定已经把 $VIMRUNTIME 设置成存放 Vim 文件的目录了，如果两者不一致的
话。参见： |<a href="starting.html#$VIMRUNTIME">$VIMRUNTIME</a>|。

</pre><hr class="doubleline" /><pre>
<h4>在一个窗口中执行 shell 命令                             <b class="vimtag">*<a name="shell-window">shell-window</a>*</b></h4>
很多人都询问能不能在 Vim 中的一个窗口内执行 shell 命令。答案是：不行！加入这
个功能会给 Vim 增加很多代码量，这也是为什么我们没有这样做的一个很好的理由。毕
竟，Vim 只是一个编辑器，它本身并不是用来做那些非编辑类工作的。然而，要达到这
样的目的，你可以把你的终端屏幕拆分开或者使者用 "splitvt" 程序来显示你的屏幕。
在一些 ftp 服务器上你可以找到这个工具。Sam Lantinga <code class="special">&lt;slouken@cs.ucdavis.edu&gt;</code>
对此了解颇多。另一种办法就是使用最早在 BSD Unix 上出现的 "window" 命令，它可
以支持很多重叠的窗口。或者使用最先出现在 www.uni-erlangen.de 上的 "screen" 程
序，它支持把多个窗口存入堆栈中。

</pre><hr class="doubleline" /><pre>
<h4>十六进制编辑                                    <b class="vimtag">*<a name="hex-editing">hex-editing</a>*</b> <b class="vimtag">*<a name="using-xxd">using-xxd</a>*</b></h4>
请看用户手册的第 |<a href="usr_23.html#23.4">23.4</a>| 节。

如果你用一个专门的扩展名用来命令二进制文件（诸如 exe，bin等等），你们会发现以
下使用在 <code class="special">&lt;.vimrc&gt;</code> 文件中的一些命令在自动处理这些文件时非常有用。你可以用你希
望编辑的文件扩展名（用逗号分隔）替换以下的 "*.bin"：
<code class="example"></code>
<code class="example">        " vim -b : edit binary using xxd-format!</code>
<code class="example">        augroup Binary</code>
<code class="example">          au!</code>
<code class="example">          au BufReadPre  *.bin let &amp;bin=1</code>
<code class="example">          au BufReadPost *.bin if &amp;bin | %!xxd</code>
<code class="example">          au BufReadPost *.bin set ft=xxd | endif</code>
<code class="example">          au BufWritePre *.bin if &amp;bin | %!xxd -r</code>
<code class="example">          au BufWritePre *.bin endif</code>
<code class="example">          au BufWritePost *.bin if &amp;bin | %!xxd</code>
<code class="example">          au BufWritePost *.bin set nomod | endif</code>
<code class="example">        augroup END</code>
<code class="example"></code>
</pre><hr class="doubleline" /><pre>
<h4>在自动命令中使用符号 <code class="special">&lt;&gt;</code>                                 <b class="vimtag">*<a name="autocmd-%3C%3E">autocmd-&lt;&gt;</a>*</b></h4>
在一个自动命令的参数中，符号 <code class="special">&lt;&gt;</code> 是不能被识别的。为避免使用特殊的字符，你可以
使用一个可以自我毁灭的映射来得到符号 <code class="special">&lt;&gt;</code>，然后从自动命令中调用这个映射。
举例如下：

                                                <b class="vimtag">*<a name="map-self-destroy">map-self-destroy</a>*</b>
<code class="example"> " 这个将会自动的把文件名加入到菜单列表中</code>
<code class="example"> " 它使用了一个可以自我毁灭的 mapping!</code>
<code class="example"> " 1. 用缓冲中的一行把文件名中的点（'dots'）转换成 \ 。</code>
<code class="example"> " 2. 把那个存放在寄存器 '"' 中</code>
<code class="example"> " 3. 把那个名字存在缓冲菜单列表中</code>
<code class="example"> " <code class="note">注意</code>：这个有一些副作用，比如：覆盖当前的寄存器内容和</code>
<code class="example"> " 删除任何对 "i" 命令的mapping。</code>
<code class="example"> "</code>
<code class="example"> autocmd BufNewFile,BufReadPre * nmap i :nunmap i<code class="special">&lt;CR&gt;</code>O<code class="special">&lt;C-R&gt;</code>%<code class="special">&lt;Esc&gt;</code>:.g/\./s/\./\\./g<code class="special">&lt;CR&gt;</code>0"9y$u:menu Buffers.<code class="special">&lt;C-R&gt;</code>9 :buffer <code class="special">&lt;C-R&gt;</code>%<code class="special">&lt;C-V&gt;</code><code class="special">&lt;CR&gt;</code><code class="special">&lt;CR&gt;</code></code>
<code class="example"> autocmd BufNewFile,BufReadPre * normal i</code>
<code class="example"></code>
另一个或许更好一些的办法就是使用 ":execute" 命令。在字符串中，你可以通过在符
号 <code class="special">&lt;&gt;</code> 前面加一个反斜杠的方法来使用它。别忘了重复反斜杠以及在'"'前面放一个反斜
杠。
<code class="example"></code>
<code class="example">  autocmd BufNewFile,BufReadPre * exe "normal O\<code class="special">&lt;C-R&gt;</code>%\<code class="special">&lt;Esc&gt;</code>:.g/\\./s/\\./\\\\./g\<code class="special">&lt;CR&gt;</code>0\"9y$u:menu Buffers.\<code class="special">&lt;C-R&gt;</code>9 :buffer \<code class="special">&lt;C-R&gt;</code>%\<code class="special">&lt;C-V&gt;</code>\<code class="special">&lt;CR&gt;</code>\<code class="special">&lt;CR&gt;</code>"</code>
<code class="example"></code>
为了建立一个真实的缓冲菜单，需要用到用户函数（参见 |<a href="eval.html#:function">:function</a>|），不过那里不
使用符号 <code class="special">&lt;&gt;</code> , 所以失去了在这里举例的意义。

 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 2006年 06月 24日 星期六 00:27:59 UTC</i></p>
</body>
</html>
