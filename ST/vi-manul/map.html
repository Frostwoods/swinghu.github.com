<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>VIM: map</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>MAP</h2>
<pre>
<b class="vimtag">*<a name="map.txt">map.txt</a>*</b>       For Vim version 7.0.  最后更新: 2006年4月


                  <code class="vim">VIM 参考手册    作者: Bram Moolenaar</code>
                                  <code class="vim">译者</code>:  con<code class="special">&lt;con@netease.com&gt;</code>
                                  VCD主页：http://vimcdoc.sf.net


键映射，缩写和用户定义的命令。

本主题在用户手册 |<a href="usr_05.html#05.3">05.3</a>|，|<a href="usr_24.html#24.7">24.7</a>| 和 |<a href="usr_40.html#40.1">40.1</a>| 中有过介绍。

1. 键映射                       |<a href="map.html#key-mapping">key-mapping</a>|
   1.1 映 射 命 令                      |<a href="map.html#:map-commands">:map-commands</a>|
   1.2 特殊参数                         |<a href="map.html#:map-arguments">:map-arguments</a>|
   1.3 映射与运行模式                   |<a href="map.html#:map-modes">:map-modes</a>|
   1.4 列出映射                         |<a href="map.html#map-listing">map-listing</a>|
   1.5 映射特殊键                       |<a href="map.html#:map-special-keys">:map-special-keys</a>|
   1.6 特殊字符                         |<a href="map.html#:map-special-chars">:map-special-chars</a>|
   1.7 映射哪些键                       |<a href="map.html#map-which-keys">map-which-keys</a>|
   1.8 示例                             |<a href="map.html#map-examples">map-examples</a>|
   1.9 使用映射                         |<a href="map.html#map-typing">map-typing</a>|
   1.10 映射 ALT 键                     |<a href="map.html#:map-alt-keys">:map-alt-keys</a>|
   1.11 映射操作符                      |<a href="map.html#:map-operator">:map-operator</a>|
2. 缩写                         |<a href="map.html#abbreviations">abbreviations</a>|
3. 局部映射和函数               |<a href="map.html#script-local">script-local</a>|
4. 用户定义的命令               |<a href="map.html#user-commands">user-commands</a>|

</pre><hr class="doubleline" /><pre>
<h4>1. 键映射                               <b class="vimtag">*<a name="key-mapping">key-mapping</a>*</b> <b class="vimtag">*<a name="mapping">mapping</a>*</b> <b class="vimtag">*<a name="macro">macro</a>*</b></h4>
键映射用于改变输入键的含义。最通常的用途是为一个功能键定义成一系列的命令。
比如:

        :map <code class="special">&lt;F2&gt;</code> a<code class="special">&lt;C-R&gt;</code>=strftime("%c")<code class="special">&lt;CR&gt;</code><code class="special">&lt;Esc&gt;</code>

这个映射在光标之后追加当前的日期和时间 (用 <code class="special">&lt;&gt;</code> 记法 |<a href="intro.html#%3C%3E">&lt;&gt;</a>|)。


1.1 映 射 命 令                                         <b class="vimtag">*<a name=":map-commands">:map-commands</a>*</b>

有很多命令用于定义新的映射，删除映射和列出当前的映射.可以从 |<a href="map.html#map-overview">map-overview</a>| 参考
不同的 "映射" 形式和相关的模式。

<code class="special">{lhs}</code>   表示左手边      <b class="vimtag">*<a name="<code class="special">{lhs}</code>"><code class="special">{lhs}</code></a>*</b>
<code class="special">{rhs}</code>   表示右手边      <b class="vimtag">*<a name="<code class="special">{rhs}</code>"><code class="special">{rhs}</code></a>*</b>

:map    <code class="special">{lhs}</code> <code class="special">{rhs}</code>             |<a href="map.html#mapmode-nvo">mapmode-nvo</a>|           <b class="vimtag">*<a name=":map">:map</a>*</b>
:nm[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>             |<a href="map.html#mapmode-n">mapmode-n</a>|             <b class="vimtag">*<a name=":nm">:nm</a>*</b> <b class="vimtag">*<a name=":nmap">:nmap</a>*</b>
:vm[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>             |<a href="map.html#mapmode-v">mapmode-v</a>|             <b class="vimtag">*<a name=":vm">:vm</a>*</b> <b class="vimtag">*<a name=":vmap">:vmap</a>*</b>
:xm[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>             |<a href="map.html#mapmode-x">mapmode-x</a>|             <b class="vimtag">*<a name=":xm">:xm</a>*</b> <b class="vimtag">*<a name=":xmap">:xmap</a>*</b>
:smap   <code class="special">{lhs}</code> <code class="special">{rhs}</code>             |<a href="map.html#mapmode-s">mapmode-s</a>|                   <b class="vimtag">*<a name=":smap">:smap</a>*</b>
:om[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>             |<a href="map.html#mapmode-o">mapmode-o</a>|             <b class="vimtag">*<a name=":om">:om</a>*</b> <b class="vimtag">*<a name=":omap">:omap</a>*</b>
:map!   <code class="special">{lhs}</code> <code class="special">{rhs}</code>             |<a href="map.html#mapmode-ic">mapmode-ic</a>|            <b class="vimtag">*<a name=":map!">:map!</a>*</b>
:im[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>             |<a href="map.html#mapmode-i">mapmode-i</a>|             <b class="vimtag">*<a name=":im">:im</a>*</b> <b class="vimtag">*<a name=":imap">:imap</a>*</b>
:lm[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>             |<a href="map.html#mapmode-l">mapmode-l</a>|             <b class="vimtag">*<a name=":lm">:lm</a>*</b> <b class="vimtag">*<a name=":lmap">:lmap</a>*</b>
:cm[ap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>             |<a href="map.html#mapmode-c">mapmode-c</a>|             <b class="vimtag">*<a name=":cm">:cm</a>*</b> <b class="vimtag">*<a name=":cmap">:cmap</a>*</b>
                        在映射命令作用的模式中把键系列<code class="special">{lhs}</code>映射为<code class="special">{rhs}</code>。并
                        且映射后的<code class="special">{rhs}</code>也被进行映射扫描。这个特性可以用来进
                        行映射的嵌套和递归。


:no[remap]  <code class="special">{lhs}</code> <code class="special">{rhs}</code>         |<a href="map.html#mapmode-nvo">mapmode-nvo</a>|           <b class="vimtag">*<a name=":no">:no</a>*</b>  <b class="vimtag">*<a name=":noremap">:noremap</a>*</b>
:nn[oremap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>         |<a href="map.html#mapmode-n">mapmode-n</a>|             <b class="vimtag">*<a name=":nn">:nn</a>*</b>  <b class="vimtag">*<a name=":nnoremap">:nnoremap</a>*</b>
:vn[oremap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>         |<a href="map.html#mapmode-v">mapmode-v</a>|             <b class="vimtag">*<a name=":vn">:vn</a>*</b>  <b class="vimtag">*<a name=":vnoremap">:vnoremap</a>*</b>
:xn[oremap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>         |<a href="map.html#mapmode-x">mapmode-x</a>|             <b class="vimtag">*<a name=":xn">:xn</a>*</b>  <b class="vimtag">*<a name=":xnoremap">:xnoremap</a>*</b>
:snor[emap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>         |<a href="map.html#mapmode-s">mapmode-s</a>|             <b class="vimtag">*<a name=":snor">:snor</a>*</b> <b class="vimtag">*<a name=":snoremap">:snoremap</a>*</b>
:ono[remap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>         |<a href="map.html#mapmode-o">mapmode-o</a>|             <b class="vimtag">*<a name=":ono">:ono</a>*</b> <b class="vimtag">*<a name=":onoremap">:onoremap</a>*</b>
:no[remap]! <code class="special">{lhs}</code> <code class="special">{rhs}</code>         |<a href="map.html#mapmode-ic">mapmode-ic</a>|            <b class="vimtag">*<a name=":no!">:no!</a>*</b> <b class="vimtag">*<a name=":noremap!">:noremap!</a>*</b>
:ino[remap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>         |<a href="map.html#mapmode-i">mapmode-i</a>|             <b class="vimtag">*<a name=":ino">:ino</a>*</b> <b class="vimtag">*<a name=":inoremap">:inoremap</a>*</b>
:ln[oremap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>         |<a href="map.html#mapmode-l">mapmode-l</a>|             <b class="vimtag">*<a name=":ln">:ln</a>*</b>  <b class="vimtag">*<a name=":lnoremap">:lnoremap</a>*</b>
:cno[remap] <code class="special">{lhs}</code> <code class="special">{rhs}</code>         |<a href="map.html#mapmode-c">mapmode-c</a>|             <b class="vimtag">*<a name=":cno">:cno</a>*</b> <b class="vimtag">*<a name=":cnoremap">:cnoremap</a>*</b>
                        在映射命令作用的模式中把键序列<code class="special">{lhs}</code>映射为<code class="special">{rhs}</code>。禁
                        止对映射后的<code class="special">{rhs}</code>进行映射扫描。这个特性可以避免映射
                        的嵌套和递归。通常用于重定义一个命令。  <code class="special">{not in Vi}</code>

:unm[ap]  <code class="special">{lhs}</code>                 |<a href="map.html#mapmode-nvo">mapmode-nvo</a>|           <b class="vimtag">*<a name=":unm">:unm</a>*</b>  <b class="vimtag">*<a name=":unmap">:unmap</a>*</b>
:nun[map] <code class="special">{lhs}</code>                 |<a href="map.html#mapmode-n">mapmode-n</a>|             <b class="vimtag">*<a name=":nun">:nun</a>*</b>  <b class="vimtag">*<a name=":nunmap">:nunmap</a>*</b>
:vu[nmap] <code class="special">{lhs}</code>                 |<a href="map.html#mapmode-v">mapmode-v</a>|             <b class="vimtag">*<a name=":vu">:vu</a>*</b>   <b class="vimtag">*<a name=":vunmap">:vunmap</a>*</b>
:xu[nmap] <code class="special">{lhs}</code>                 |<a href="map.html#mapmode-x">mapmode-x</a>|             <b class="vimtag">*<a name=":xu">:xu</a>*</b>   <b class="vimtag">*<a name=":xunmap">:xunmap</a>*</b>
:sunm[ap] <code class="special">{lhs}</code>                 |<a href="map.html#mapmode-s">mapmode-s</a>|             <b class="vimtag">*<a name=":sunm">:sunm</a>*</b> <b class="vimtag">*<a name=":sunmap">:sunmap</a>*</b>
:ou[nmap] <code class="special">{lhs}</code>                 |<a href="map.html#mapmode-o">mapmode-o</a>|             <b class="vimtag">*<a name=":ou">:ou</a>*</b>   <b class="vimtag">*<a name=":ounmap">:ounmap</a>*</b>
:unm[ap]! <code class="special">{lhs}</code>                 |<a href="map.html#mapmode-ic">mapmode-ic</a>|            <b class="vimtag">*<a name=":unm!">:unm!</a>*</b> <b class="vimtag">*<a name=":unmap!">:unmap!</a>*</b>
:iu[nmap] <code class="special">{lhs}</code>                 |<a href="map.html#mapmode-i">mapmode-i</a>|             <b class="vimtag">*<a name=":iu">:iu</a>*</b>   <b class="vimtag">*<a name=":iunmap">:iunmap</a>*</b>
:lu[nmap] <code class="special">{lhs}</code>                 |<a href="map.html#mapmode-l">mapmode-l</a>|             <b class="vimtag">*<a name=":lu">:lu</a>*</b>   <b class="vimtag">*<a name=":lunmap">:lunmap</a>*</b>
:cu[nmap] <code class="special">{lhs}</code>                 |<a href="map.html#mapmode-c">mapmode-c</a>|             <b class="vimtag">*<a name=":cu">:cu</a>*</b>   <b class="vimtag">*<a name=":cunmap">:cunmap</a>*</b>
                        在映射命令作用的模式中删除 <code class="special">{lhs}</code> 的映射。该映射可能
                        会在它作用的其它模式中被保留。
                        <code class="note">备注</code>: <code class="special">{lhs}</code> 包含末尾的空格。该映射取消操作不会生效:
                                :map @@ foo
                                :unmap @@ | print

:mapc[lear]                     |<a href="map.html#mapmode-nvo">mapmode-nvo</a>|           <b class="vimtag">*<a name=":mapc">:mapc</a>*</b>   <b class="vimtag">*<a name=":mapclear">:mapclear</a>*</b>
:nmapc[lear]                    |<a href="map.html#mapmode-n">mapmode-n</a>|             <b class="vimtag">*<a name=":nmapc">:nmapc</a>*</b>  <b class="vimtag">*<a name=":nmapclear">:nmapclear</a>*</b>
:vmapc[lear]                    |<a href="map.html#mapmode-v">mapmode-v</a>|             <b class="vimtag">*<a name=":vmapc">:vmapc</a>*</b>  <b class="vimtag">*<a name=":vmapclear">:vmapclear</a>*</b>
:xmapc[lear]                    |<a href="map.html#mapmode-x">mapmode-x</a>|             <b class="vimtag">*<a name=":xmapc">:xmapc</a>*</b>  <b class="vimtag">*<a name=":xmapclear">:xmapclear</a>*</b>
:smapc[lear]                    |<a href="map.html#mapmode-s">mapmode-s</a>|             <b class="vimtag">*<a name=":smapc">:smapc</a>*</b>  <b class="vimtag">*<a name=":smapclear">:smapclear</a>*</b>
:omapc[lear]                    |<a href="map.html#mapmode-o">mapmode-o</a>|             <b class="vimtag">*<a name=":omapc">:omapc</a>*</b>  <b class="vimtag">*<a name=":omapclear">:omapclear</a>*</b>
:mapc[lear]!                    |<a href="map.html#mapmode-ic">mapmode-ic</a>|            <b class="vimtag">*<a name=":mapc!">:mapc!</a>*</b>  <b class="vimtag">*<a name=":mapclear!">:mapclear!</a>*</b>
:imapc[lear]                    |<a href="map.html#mapmode-i">mapmode-i</a>|             <b class="vimtag">*<a name=":imapc">:imapc</a>*</b>  <b class="vimtag">*<a name=":imapclear">:imapclear</a>*</b>
:lmapc[lear]                    |<a href="map.html#mapmode-l">mapmode-l</a>|             <b class="vimtag">*<a name=":lmapc">:lmapc</a>*</b>  <b class="vimtag">*<a name=":lmapclear">:lmapclear</a>*</b>
:cmapc[lear]                    |<a href="map.html#mapmode-c">mapmode-c</a>|             <b class="vimtag">*<a name=":cmapc">:cmapc</a>*</b>  <b class="vimtag">*<a name=":cmapclear">:cmapclear</a>*</b>
                        在映射命令作用的模式中删除所有的映射。  <code class="special">{not in Vi}</code>
                        警告: 这也会删除缺省的映射。

:map                            |<a href="map.html#mapmode-nvo">mapmode-nvo</a>|
:nm[ap]                         |<a href="map.html#mapmode-n">mapmode-n</a>|
:vm[ap]                         |<a href="map.html#mapmode-v">mapmode-v</a>|
:xm[ap]                         |<a href="map.html#mapmode-x">mapmode-x</a>|
:sm[ap]                         |<a href="map.html#mapmode-s">mapmode-s</a>|
:om[ap]                         |<a href="map.html#mapmode-o">mapmode-o</a>|
:map!                           |<a href="map.html#mapmode-ic">mapmode-ic</a>|
:im[ap]                         |<a href="map.html#mapmode-i">mapmode-i</a>|
:lm[ap]                         |<a href="map.html#mapmode-l">mapmode-l</a>|
:cm[ap]                         |<a href="map.html#mapmode-c">mapmode-c</a>|
                        在映射命令作用的模式中列出所有的键映射。<code class="note">注意</code> ":map"
                        和":map!"是最常用的，因为它们包括其它模式。

:map    <code class="special">{lhs}</code>                   |<a href="map.html#mapmode-nvo">mapmode-nvo</a>|           <b class="vimtag">*<a name=":map_l">:map_l</a>*</b>
:nm[ap] <code class="special">{lhs}</code>                   |<a href="map.html#mapmode-n">mapmode-n</a>|             <b class="vimtag">*<a name=":nmap_l">:nmap_l</a>*</b>
:vm[ap] <code class="special">{lhs}</code>                   |<a href="map.html#mapmode-v">mapmode-v</a>|             <b class="vimtag">*<a name=":vmap_l">:vmap_l</a>*</b>
:xm[ap] <code class="special">{lhs}</code>                   |<a href="map.html#mapmode-x">mapmode-x</a>|             <b class="vimtag">*<a name=":xmap_l">:xmap_l</a>*</b>
:sm[ap] <code class="special">{lhs}</code>                   |<a href="map.html#mapmode-s">mapmode-s</a>|             <b class="vimtag">*<a name=":smap_l">:smap_l</a>*</b>
:om[ap] <code class="special">{lhs}</code>                   |<a href="map.html#mapmode-o">mapmode-o</a>|             <b class="vimtag">*<a name=":omap_l">:omap_l</a>*</b>
:map!   <code class="special">{lhs}</code>                   |<a href="map.html#mapmode-ic">mapmode-ic</a>|            <b class="vimtag">*<a name=":map_l!">:map_l!</a>*</b>
:im[ap] <code class="special">{lhs}</code>                   |<a href="map.html#mapmode-i">mapmode-i</a>|             <b class="vimtag">*<a name=":imap_l">:imap_l</a>*</b>
:lm[ap] <code class="special">{lhs}</code>                   |<a href="map.html#mapmode-l">mapmode-l</a>|             <b class="vimtag">*<a name=":lmap_l">:lmap_l</a>*</b>
:cm[ap] <code class="special">{lhs}</code>                   |<a href="map.html#mapmode-c">mapmode-c</a>|             <b class="vimtag">*<a name=":cmap_l">:cmap_l</a>*</b>
                        在映射命令作用的模式中列出以 <code class="special">{lhs}</code>
                        开头的键映射的键系列。 <code class="special">{not in Vi}</code>

这些命令用于把一个或一个键系列映射成一个字符串。
可以用它来在功能键里放置一系列命令，把一个键转换成另一个，等等。
如何保存和恢复当前映射可以参考 |<a href="starting.html#:mkexrc">:mkexrc</a>|。

                                                        <b class="vimtag">*<a name="map-ambiguous">map-ambiguous</a>*</b>
当两个映射以相同的字符顺序开始，它们是有二义性的。
例如:
<code class="example">        :imap aa foo</code>
<code class="example">        :imap aaa bar</code>
当 Vim 读如 "aa"，它将需要取得另外一个字符才能决定是否是 "aa" 或是 "aaa"
应该被映射。这意味这当输入 "aa" 以后映射还不会展开，Vim还在等待另一个字符。
如果你输入一个空格，那么 "foo" 将被插入，加上空格。如果你输入一个 "a"，
那么 "bar" 将被插入。
<code class="special">{Vi 不允许有二义性的映射}</code>


1.2 特 殊 参 数                                         <b class="vimtag">*<a name=":map-arguments">:map-arguments</a>*</b>

"<code class="special">&lt;buffer&gt;</code>"，"<code class="special">&lt;silent&gt;</code>"，"<code class="special">&lt;special&gt;</code>"、"<code class="special">&lt;script&gt;</code>"、"<code class="special">&lt;expr&gt;</code>" 和 "<code class="special">&lt;unique&gt;</code>" 可以按
任意顺序使用。它们必须出现在命令的右边，并且在任何其它参数的之前边。

                                <b class="vimtag">*<a name=":map-local">:map-local</a>*</b> <b class="vimtag">*<a name=":map-%3Cbuffer%3E">:map-&lt;buffer&gt;</a>*</b> <b class="vimtag">*<a name="E224">E224</a>*</b> <b class="vimtag">*<a name="E225">E225</a>*</b>
如果这些命令的第一个参数是 "<code class="special">&lt;buffer&gt;</code>"，映射将只局限于当前的缓冲内。例如:
<code class="example">        :map <code class="special">&lt;buffer&gt;</code>  ,w  /[.,;]<code class="special">&lt;CR&gt;</code></code>
然后你可以把 ",w" 在另一个缓冲内作另外的映射:
<code class="example">        :map <code class="special">&lt;buffer&gt;</code>  ,w  /[#&amp;!]<code class="special">&lt;CR&gt;</code></code>
局部缓冲映射在全局映射之前被应用。"<code class="special">&lt;buffer&gt;</code>" 参数也可以用于清除映射:
<code class="example">        :unmap <code class="special">&lt;buffer&gt;</code> ,w</code>
<code class="example">        :mapclear <code class="special">&lt;buffer&gt;</code></code>
当一个缓冲被删除时局部映射也会被清除，但是在它被卸载时不会。就象局部选项值的情
况一样。

                                                <b class="vimtag">*<a name=":map-%3Csilent%3E">:map-&lt;silent&gt;</a>*</b> <b class="vimtag">*<a name=":map-silent">:map-silent</a>*</b>
要在定义一个映射时不在命令行里回显，可以使用 "<code class="special">&lt;silent&gt;</code>" 作为第一个参数，
例如:
<code class="example">        :map <code class="special">&lt;silent&gt;</code> ,h /Header<code class="special">&lt;CR&gt;</code></code>
在使用这个映射时搜索字串将不被回显。被执行的命令的信息仍然会被显示。
要把它也关掉，可以在执行的命令里加入一个 ":silent" :
<code class="example">        :map <code class="special">&lt;silent&gt;</code> ,h :exe ":silent normal /Header\r"<code class="special">&lt;CR&gt;</code></code>
提示仍然会给出，比如使用 inputdialog() 的时候。
在一个缩写上使用 "<code class="special">&lt;silent&gt;</code>" 是可能的，但将会使重绘命令行失败。

                                                <b class="vimtag">*<a name=":map-%3Cspecial%3E">:map-&lt;special&gt;</a>*</b> <b class="vimtag">*<a name=":map-special">:map-special</a>*</b>
定义映射时，特殊键可用 <code class="special">&lt;&gt;</code> 记法，即使 'cpoptions' 包含了 "&lt;" 标志位也没问题。可
用于不希望看到设置 'cpoptions' 时出现副作用的场合。例如:
<code class="example">        :map <code class="special">&lt;special&gt;</code> <code class="special">&lt;F12&gt;</code> /Header<code class="special">&lt;CR&gt;</code></code>

                                                <b class="vimtag">*<a name=":map-%3Cscript%3E">:map-&lt;script&gt;</a>*</b> <b class="vimtag">*<a name=":map-script">:map-script</a>*</b>
如果给这些命令的第一个参数是 "<code class="special">&lt;script&gt;</code>" 并且它用于定义一个新的映射或缩写，
该映射将仅仅重映射 <code class="special">{rhs}</code> 中使用被一个以 "<code class="special">&lt;SID&gt;</code>" 开头的脚本局部定义的映射中的字
符。它可以用于避免来自外部的脚本的干扰 (举例来说，在 mswin.vim 中 <code class="keystroke">CTRL-V</code> 被重
新映射)，但是又使用该脚本中定义的其它映射。
<code class="note">备注</code>: ":map <code class="special">&lt;script&gt;</code>" 和 ":noremap <code class="special">&lt;script&gt;</code>" 做同样的事情。
"<code class="special">&lt;script&gt;</code>" 否决了该命令名。更推荐使用 ":noremap <code class="special">&lt;script&gt;</code>"，因为它更清晰的表示
了重映射已被 (大多数时候) 禁止。

                                                <b class="vimtag">*<a name=":map-%3Cunique%3E">:map-&lt;unique&gt;</a>*</b> <b class="vimtag">*<a name="E226">E226</a>*</b> <b class="vimtag">*<a name="E227">E227</a>*</b>
如果这些命令的第一个参数是 "<code class="special">&lt;unique&gt;</code>" 并且它用于定义一个新的映射或缩写时该映射
或缩写已经存在，则该命令会失败。例如:
<code class="example">        :map <code class="special">&lt;unique&gt;</code> ,w  /[#&amp;!]<code class="special">&lt;CR&gt;</code></code>
当定义一个局部映射，同时也会检查是否已存在了一个相同的全局映射。
这个例子将失败:
<code class="example">        :map ,w  /[#&amp;!]<code class="special">&lt;CR&gt;</code></code>
<code class="example">        :map <code class="special">&lt;buffer&gt;</code> <code class="special">&lt;unique&gt;</code> ,w  /[.,;]<code class="special">&lt;CR&gt;</code></code>
如果你想给键进行映射，但同时也想执行它原来映射的内容，参见 |<a href="eval.html#maparg()">maparg()</a>|。

                                                <b class="vimtag">*<a name=":map-%3Cexpr%3E">:map-&lt;expr&gt;</a>*</b> <b class="vimtag">*<a name=":map-expression">:map-expression</a>*</b>
如果这些命令中第一个参数是 "<code class="special">&lt;expr&gt;</code>" 且它被用来定义新的映射或缩写，参数是表达式
。计算该表达式以获得使用的 <code class="special">{rhs}</code>。例如:
<code class="example">        :inoremap <code class="special">&lt;expr&gt;</code> . InsertDot()</code>
插入 InsertDot() 函数的返回值。可以用来检查光标至前的文本并在一定条件下启动全
方位 (omni) 补全。

要非常小心副作用！计算表达式的同时正在获取字符，因此很有可能你使得该命令不再可
用。为此原因禁止以下行为:
- 改变缓冲区文本 |<a href="eval.html#textlock">textlock</a>|
- 编辑其它缓冲区
- |<a href="various.html#:normal">:normal</a>| 命令
- 可以移动光标，但事后光标会被恢复
如果希望映射完成这些操作，让返回的字符做这些事情。

这里是插入递增的列表编号的例子:
<code class="example">        let counter = 0</code>
<code class="example">        inoremap <code class="special">&lt;expr&gt;</code> <code class="special">&lt;C-L&gt;</code> ListItem()</code>
<code class="example">        inoremap <code class="special">&lt;expr&gt;</code> <code class="special">&lt;C-R&gt;</code> ListReset()</code>
<code class="example"></code>
<code class="example">        func ListItem()</code>
<code class="example">          let g:counter += 1</code>
<code class="example">          return g:counter . '. '</code>
<code class="example">        endfunc</code>
<code class="example"></code>
<code class="example">        func ListReset()</code>
<code class="example">          let g:counter = 0</code>
<code class="example">          return ''</code>
<code class="example">        endfunc</code>
<code class="example"></code>
<code class="keystroke">CTRL-L</code> 插入下一个数值，<code class="keystroke">CTRL-R</code> 复位计数。<code class="keystroke">CTRL-R</code> 返回空字符串，确保不插入任何内
容。

<code class="note">注意</code> 要使特殊键和转义的 CSI 字节工作需要一些技巧。|<a href="map.html#:map">:map</a>| 目录已经做好了，所以
你应该避免做两次操作。这样不行:
<code class="example">        :imap <code class="special">&lt;expr&gt;</code> <code class="special">&lt;F3&gt;</code> "<code class="special">&lt;Char-0x611B&gt;</code>"</code>
因为 &lt;Char- 序列作为 |<a href="map.html#:imap">:imap</a>| 的参数被转义，而 <code class="special">&lt;expr&gt;</code> 又做一次。这样就可以:
<code class="example">        :imap <code class="special">&lt;expr&gt;</code> <code class="special">&lt;F3&gt;</code> "\u611B"</code>
在其它文本之前使用单个字节出现的 0x80 是不行的。它会被看作一个特殊键。


1.3 映 射 与 运 行 模 式                                <b class="vimtag">*<a name=":map-modes">:map-modes</a>*</b>

有五种映射存在
- 对于普通模式: 当输入命令时。
- 对于可视模式: 当输入命令并且可视区域已被设置为高亮时。
- 对于操作符等待模式: 当一个操作符正在进行中 ("d"，"y"，"c" 等等之后)
  例如: ":omap { w" 会使 "y{" 和 "yw" 一样，"d{" 和 "dw"一样。
- 对于插入模式: 也被用于替换模式。
- 对于命令行模式: 当输入一个 ":" 或 "/" 命令时。

特殊情况：当在普通模式里为一个命令输入一个数时，对 0 的映射就会禁用。这样
在输入一个带有0的数字时不会受到对 0 键映射的干扰。

                                                <b class="vimtag">*<a name="map-overview">map-overview</a>*</b> <b class="vimtag">*<a name="map-modes">map-modes</a>*</b>
每个映射命令工作的模式概况:

                        <b class="vimtag">*<a name="mapmode-nvo">mapmode-nvo</a>*</b> <b class="vimtag">*<a name="mapmode-n">mapmode-n</a>*</b> <b class="vimtag">*<a name="mapmode-v">mapmode-v</a>*</b> <b class="vimtag">*<a name="mapmode-o">mapmode-o</a>*</b>
<code class="section">    命令:                                       模式: </code>
<code class="section">                                        普通    可视+选择       操作符等待 </code>
:map   :noremap   :unmap   :mapclear    是      是              是
:nmap  :nnoremap  :nunmap  :nmapclear   是      -               -
:vmap  :vnoremap  :vunmap  :vmapclear   -       是              -
:omap  :onoremap  :ounmap  :omapclear   -       -               是

修道院之外也有 :nunmap (<code class="vim">译者注</code>: nun，修女)。
                                                <b class="vimtag">*<a name="mapmode-x">mapmode-x</a>*</b> <b class="vimtag">*<a name="mapmode-s">mapmode-s</a>*</b>
有的命令能同时用于可视和选择模式，有的只能用于其中一个。<code class="note">注意</code> 很常见的情况是提
到 "可视" 的时候实际同时适用可视和选择两种模式。|<a href="visual.html#Select-mode-mapping">Select-mode-mapping</a>|

<code class="section">    命令:                                       模式: </code>
<code class="section">                                        可视    选择 </code>
:vmap  :vnoremap  :vunmap  :vmapclear   是      是
:xmap  :xnoremap  :xunmap  :xmapclear   是      -
:smap  :snoremap  :sunmap  :smapclear   -       是

                        <b class="vimtag">*<a name="mapmode-ic">mapmode-ic</a>*</b> <b class="vimtag">*<a name="mapmode-i">mapmode-i</a>*</b> <b class="vimtag">*<a name="mapmode-c">mapmode-c</a>*</b> <b class="vimtag">*<a name="mapmode-l">mapmode-l</a>*</b>
有的命令同时支持插入模式和命令行模式，有的不是:

<code class="section">    命令:                                       模式: </code>
<code class="section">                                        插入    命令行  Lang-Arg </code>
:map!  :noremap!  :unmap!  :mapclear!   是      是      -
:imap  :inoremap  :iunmap  :imapclear   是      -       -
:cmap  :cnoremap  :cunmap  :cmapclear   -       是      -
:lmap  :lnoremap  :lunmap  :lmapclear   是*     是*     是*

原来的 Vi 没有独立针对普通/可视/操作符等待模式和插入/命令行模式的映射。因此
":map" 和 ":map!" 命令对不同的模式都起作用。在 Vim 中你可以使用 ":nmap"，
":vmap"，":omap"，":cmap" 和 ":imap" 命令来对每个不同的模式分别定义输入映射。

要为普通和可视模式但不包括操作符等待模式输入一个映射，首先在所有的三个模式中定
义该映射，然后在操作符模式中取消该映射:
<code class="example">        :map    xx something-difficult</code>
<code class="example">        :ounmap xx</code>
对于一个同时用于可视和操作符等待模式、或同时用于普通和操作符等待模式的映射也可
照此办理。

                                                <b class="vimtag">*<a name="language-mapping">language-mapping</a>*</b>
":lmap" 定义一个映射应用于:
- 插入模式
- 命令行模式
- 当输入一个搜索模式
- 接受一个文本字符作为参数的命令，比如 "r" 和 "f"
- 对于 input() 行
通常: 任何输入的字符是缓冲区文本的一部分而非一个 Vim 命令字符的时候。
"Lang-Arg" 不是真正的另外一个模式，仅在这种情况下使用它。
   载入一个相关语言映射集合的最简单的方法是通过使用 'keymap' 选项。
参考 |<a href="usr_45.html#45.5">45.5</a>|。
   在插入模式和命令行模式中可用 <code class="keystroke">CTRL-^</code> 命令来禁止映射 |<a href="insert.html#i_CTRL-^">i_CTRL-^</a>| |<a href="cmdline.html#c_CTRL-^">c_CTRL-^</a>|。
当开始输入一个普通命令行 (非搜索模式) 时，禁止映射直到输入一个 <code class="keystroke">CTRL-^</code> 为止。分
别记住插入模式和模式搜索的上次使用的状态。需要输入一个字符作为参数的命令，如
"f" 或 "t" 之类，也使用插入模式的状态。
   语言映射永远不能应用于已经映射的字符上。它们仅用于已经输入的字符上。这里假
设输入映射时，语言映射已经完成。


1.4 列 出 映 射                                         <b class="vimtag">*<a name="map-listing">map-listing</a>*</b>

当列出映射时，前面两栏的字符表示:

<code class="section">      字 符     模 式   </code>
     <code class="special">&lt;Space&gt;</code>    普通、可视和操作符等待
        n       普通
        v       可视
        o       操作符等待
        !       插入和命令行
        i       插入
        l       插入、命令行和 Lang-Arg 的 ":lmap" 映射
        c       命令行

在紧跟 <code class="special">{rhs}</code> 会显示一个特殊字符:
        *       表示它不可重映射
        &amp;       表示仅脚本的局部映射可以被重映射
        @       表示缓冲区的局部映射

<code class="special">{lhs}</code> 从以后的第一个非空字符到行的末尾(或 '|') 都被认为是 <code class="special">{rhs}</code> 的一部分。
这允许 <code class="special">{rhs}</code> 以一个空格结尾。

<code class="note">注意</code>: 在可视模式里使用映射时，你可以使用 "'&lt;" 位置标记，它表示当前缓冲区中最后
被选中的可视区域的开始 |<a href="motion.html#'%3C">'&lt;</a>|。

                                                        <b class="vimtag">*<a name=":map-verbose">:map-verbose</a>*</b>
如果 'verbose' 非零，列出键映射的同时可以显示它在那里定义。例如:
<code class="example"></code>
<code class="example">        :verbose map <code class="special">&lt;C-W&gt;</code>*</code>
<code class="example">        n  <code class="special">&lt;C-W&gt;</code>*      * <code class="special">&lt;C-W&gt;</code><code class="special">&lt;C-S&gt;</code>*</code>
<code class="example">                Last set from /home/abcd/.vimrc</code>
<code class="example"></code>
|<a href="various.html#:verbose-cmd">:verbose-cmd</a>| 说明详情。


1.5 映 射 特 殊 键                                      <b class="vimtag">*<a name=":map-special-keys">:map-special-keys</a>*</b>

有三种方法来映射一个特殊键:
1. Vi 兼容的方法: 映射键编码。通常这是一个以 <code class="special">&lt;Esc&gt;</code> 开头的序列。要输入一个
   这样的映射先输入 ":map " 然后再敲入功能键之前得先输入一个 <code class="keystroke">CTRL-V</code>。<code class="note">注意</code>
   这时键的编码是在 termcap (t_ 开头的选项) 里，它会被自动转换到内部编码并
   变成映射的第二种方法 (除非 'cpoptions' 里包括了 'k' 标志)。
2. 第二种方法是为功能键使用内部编码。要输入这样的映射输入 <code class="keystroke">CTRL-K</code> 并敲要映射
   的功能键，或者使用 "#1"，"#2"，.. "#9"，"#0"，"<code class="special">&lt;Up&gt;</code>"，"<code class="special">&lt;S-Down&gt;</code>"，"<code class="special">&lt;S-F7&gt;</code>"
   等等的形式.(参考键表 |<a href="intro.html#key-notation">key-notation</a>|，所有从 <code class="special">&lt;Up&gt;</code> 开始的键都可以使用)
   头十个功能键能以两种方式被定义: 仅用数字，比如 "#2"，或者使用"<code class="special">&lt;F&gt;</code>"，
   如 "<code class="special">&lt;F2&gt;</code>"。两种都代表功能键 F2。"#0" 表示功能键 F10，用选项 't_f10' 定义，
   它在某些键盘上可能是F0。<code class="special">&lt;&gt;</code> 的形式在 'cpoptions' 包含 '&lt;' 标志时不能使用。
3. 使用 termcap 条目，以 <code class="special">&lt;t_xx&gt;</code> 的形式，这里 "xx" 是 termcap 条目的名字。
   任何字串条目都可以使用。例如:
<code class="example">     :map <code class="special">&lt;t_F3&gt;</code> G</code>
   把功能键 13 映射成 "G"。当 'cpoptions' 包括 '&lt;' 标志时这种方式不能使用。

第二种和第三种方法的优点是不加修改就可以在不同的终端上使用 (功能键会被转换成
相同的内部编码或实际的键编码，而不论使用何种终端。termcap 必需是正确的才能正
常工作，并且必需使用相同的映射)。

细节: Vim 首先检查是否从键盘输入的序列是否已被映射。否的话将试图使用终端键编
码 (参考 |<a href="term.html#terminal-options">terminal-options</a>|)。如果一个终端键编码被找到它会被替换成内部编码。
然后再次检查一个映射是否已完成 (因此你也能把一个内部编码映射成其它东西)。
在脚本文件中写入什么东西取决于识别了什么东西。如果终端键编码被识别为一个映射
它本身的键编码会被写入脚本。如果它被识别为一个终端编码则在脚本中写入内部编码。


1.6 特 殊 字 符                                         <b class="vimtag">*<a name=":map-special-chars">:map-special-chars</a>*</b>
                                                        <b class="vimtag">*<a name="map_backslash">map_backslash</a>*</b>
<code class="note">注意</code>在这里仅有 <code class="keystroke">CTRL-V</code> 被提及作为映射和缩写时的一个特殊字符。
当 'cpoptions' 不包含 'B'，一个反斜杠也可如 <code class="keystroke">CTRL-V</code> 一样被使用。
而且 <code class="special">&lt;&gt;</code> 符号能被完全可以被使用 |<a href="intro.html#%3C%3E">&lt;&gt;</a>|。
但你不能使用 "<code class="special">&lt;C-V&gt;</code>" 如 <code class="keystroke">CTRL-V</code> 来转换后面的特殊含义。

要映射一个反斜杠，或者在 <code class="special">{rhs}</code> 中使用一个字面意义的反斜杠，可以使用特殊字符
序列 "<code class="special">&lt;Bslash&gt;</code>" 。这可以避免在使用嵌套映射时需要使用双反斜杠。

                                                        <b class="vimtag">*<a name="map_CTRL-C">map_CTRL-C</a>*</b>
<code class="special">{lhs}</code> 里可以使用 <code class="keystroke">CTRL-C</code>，但只有在 Vim 等待输入键时才可以，Vim 忙着做别的事情的
时候不行。如果 Vim 在忙，<code class="keystroke">CTRL-C</code> 总是能够中断/打断该命令。
在 MS-Windows 上使用 GUI 版本时 <code class="keystroke">CTRL-C</code> 能被映射以允许复制到剪贴板的命令。使用
<code class="keystroke">CTRL-Break</code> 来中断 Vim。

                                                        <b class="vimtag">*<a name="map_space_in_lhs">map_space_in_lhs</a>*</b>
要在 <code class="special">{lhs}</code> 中包含一个空格，在前面输入一个 <code class="keystroke">CTRL-V</code> (每个空格输入两个 <code class="keystroke">CTRL-Vs</code>)。
                                                        <b class="vimtag">*<a name="map_space_in_rhs">map_space_in_rhs</a>*</b>
如果你需要 <code class="special">{rhs}</code> 以空格开头，使用 "<code class="special">&lt;Space&gt;</code>"。要与Vi完全兼容 (但不可读)，
不要使用 |<a href="intro.html#%3C%3E">&lt;&gt;</a>| 符号，在 <code class="special">{rhs}</code> 前面输入一个单独的 <code class="keystroke">CTRL-V</code>
(你必需输入 <code class="keystroke">CTRL-V</code> 两次)。
                                                        <b class="vimtag">*<a name="map_empty_rhs">map_empty_rhs</a>*</b>
你可以通过在一个单独的 <code class="keystroke">CTRL-V</code> (你必需输入 <code class="keystroke">CTRL-V</code> 两次) 后面什么也不输入
来建立一个空的 <code class="special">{rhs}</code>。不幸的是在一个vimrc文件中你不能使用这种方式。
                                                        <b class="vimtag">*<a name="%3CNop%3E">&lt;Nop&gt;</a>*</b>
得到一个什么都不做的映射的更容易的一个方法是在 <code class="special">{rhs}</code> 中使用 "<code class="special">&lt;Nop&gt;</code>"。
仅当 |<a href="intro.html#%3C%3E">&lt;&gt;</a>| 符号被允许时这种方法才生效。例如确保功能键F8什么事情都不做:
        :map  <code class="special">&lt;F8&gt;</code>  <code class="special">&lt;Nop&gt;</code>
        :map! <code class="special">&lt;F8&gt;</code>  <code class="special">&lt;Nop&gt;</code>

                                                        <b class="vimtag">*<a name="map-multibyte">map-multibyte</a>*</b>
可以对多字节字符映射，但只能是整个字符。不能仅映射第一个字节。
这是为了避免下面场景中的问题:
        :set encoding=latin1
        :imap <code class="special">&lt;M-C&gt;</code> foo
        :set encoding=utf-8
对于 <code class="special">&lt;M-C&gt;</code> 的映射是在 latin1 解码中被定义的，结果是一个 0xc3 字节。
如果你在UTF-8解码中输入 á (0xea <code class="special">&lt;M-a&gt;</code>) 它是双字节 0xc3 0xa1。
这个时候你不希望 0xc3 字节被映射，否则的话将不能输入 á 字符了。

                                        <b class="vimtag">*<a name="%3CLeader%3E">&lt;Leader&gt;</a>*</b> <b class="vimtag">*<a name="mapleader">mapleader</a>*</b>
要定义一个使用 "mapleader" 变量的映射，可以使用特殊字串 "<code class="special">&lt;Leader&gt;</code>"。
它会被 "mapleader" 的字串值所替换。如果 "mapleader" 未设置或为空，则用
反斜杠代替，例如:
        :map <code class="special">&lt;Leader&gt;</code>A  oanother line<code class="special">&lt;Esc&gt;</code>
和下面一样:
<code class="example">        :map \A  oanother line<code class="special">&lt;Esc&gt;</code></code>
但是当:
<code class="example">        :let mapleader = ","</code>
和下面一样:
<code class="example">        :map ,A  oanother line<code class="special">&lt;Esc&gt;</code></code>
<code class="example"></code>
<code class="note">注意</code> "mapleader" 的值仅当定义映射时被使用。后来改变的 "mapleader" 不会
影响已定义的映射。

                                        <b class="vimtag">*<a name="%3CLocalLeader%3E">&lt;LocalLeader&gt;</a>*</b> <b class="vimtag">*<a name="maplocalleader">maplocalleader</a>*</b>
和 <code class="special">&lt;Leader&gt;</code> 类似，除了它使用 "maplocalleader" 而非 "mapleader"。
<code class="special">&lt;LocalLeader&gt;</code> 用来针对局部于一个缓冲的映射多所使用，例如:
<code class="example">      :map <code class="special">&lt;LocalLeader&gt;</code>q  \DoItNow</code>

在一个全局插件里应该使用 <code class="special">&lt;Leader&gt;</code> 而在一个 filetype 插件里应该使用
<code class="special">&lt;LocalLeader&gt;</code>。"mapleader" 和 "maplocalleader" 可以是相同的。尽管如此，如果你
把它们设置为不同，全局插件和filetype插件的映射冲突的机会也是很小的。例如，你
可以保持把 "mapleader" 设置为缺省的反斜杠，并且设置 "maplocalleader" 设置为
下划线。

                                                        <b class="vimtag">*<a name="map-%3CSID%3E">map-&lt;SID&gt;</a>*</b>
在一个脚本中有一个特殊关键字叫 "<code class="special">&lt;SID&gt;</code>" 能被用来定义一个局部于脚本中的映射。
具体细节请参考 |<a href="map.html#%3CSID%3E">&lt;SID&gt;</a>|。

                                                        <b class="vimtag">*<a name="%3CPlug%3E">&lt;Plug&gt;</a>*</b>
叫做 "<code class="special">&lt;Plug&gt;</code>" 的特殊关键字可以用于一个内部映射，它不于任何键顺序匹配。
这在插件中有用 |<a href="usr_41.html#using-%3CPlug%3E">using-&lt;Plug&gt;</a>|。

                                                        <b class="vimtag">*<a name="%3CChar%3E">&lt;Char&gt;</a>*</b> <b class="vimtag">*<a name="%3CChar-%3E">&lt;Char-&gt;</a>*</b>
要以一个字符的十进制，八进制或十六进制数字映射，可以使用 <code class="special">&lt;Char&gt;</code> 来构造:
        <code class="special">&lt;Char-123&gt;</code>      character 123
        <code class="special">&lt;Char-033&gt;</code>      character 27
        <code class="special">&lt;Char-0x7f&gt;</code>     character 127
它可以用来在一个 'keymap' 文件里指定一个 (多字节) 字符。大小写的区别被忽略。

                                                        <b class="vimtag">*<a name="map-comments">map-comments</a>*</b>
在这些命令的后面不可能放置注释，因为 '"' 字符被认为是 <code class="special">{lhs}</code> 或 <code class="special">{rhs}</code>
的一部分。

                                                        <b class="vimtag">*<a name="map_bar">map_bar</a>*</b>
因为字符 '|' 用来分隔映射命令和后面的命令，所以包括 '|' 的 <code class="special">{rhs}</code> 要
做一些特殊的处理，有三种方法:
<code class="section">   使用      可用于                        示例 </code>
   <code class="special">&lt;Bar&gt;</code>     '<code class="special">&lt;' 不在 'cpoptions' 里       :map _l :!ls &lt;Bar&gt;</code> more^M
   \|        'b' 不在 'cpoptions' 里       :map _l :!ls \| more^M
   ^V|       总可以，Vim 和 Vi 都行        :map _l :!ls ^V| more^M

(这里 ^V 表示 <code class="keystroke">CTRL-V</code>; 要输入一个 <code class="keystroke">CTRL-V</code> 你必需按键两次; 在这里不能使用
 <code class="special">&lt;&gt;</code> 符号 "<code class="special">&lt;C-V&gt;</code>")。

当你使用 'cpoptions' 的缺省设置时三种方式都可以正常工作。

当 'b' 出现在 'cpoptions' 中时，"\|" 会被认为是一个映射的结束，后面的
是另一个命令。这是为了和Vi兼容，但是当和其它命令比较时有点不合逻辑。

                                                        <b class="vimtag">*<a name="map_return">map_return</a>*</b>
当你的一个映射包含一个 Ex 命令时，你需要放置一个行终结符在它后面才能让它执行。
在这里推荐推荐使用 <code class="special">&lt;CR&gt;</code>  (参考 |<a href="intro.html#%3C%3E">&lt;&gt;</a>|)。例如:
<code class="example">   :map  _ls  :!ls -l %<code class="special">&lt;CR&gt;</code>:echo "the end"<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
在Command-line模式中输入时要避免字符被映射，可以先输入一个 <code class="keystroke">CTRL-V</code>。
在Insert模式中如果 'paste' 选项被打开的话，映射会被禁止。

<code class="note">注意</code>当遇到错误时 (会导致一个错误信息或蜂鸣) 剩下的映射将不会被执行。
这是为了保持和Vi兼容。

<code class="note">注意</code>这些命令 @zZtTfF[]rm'`"v 的第二个字符 (参数) 和 <code class="keystroke">CTRL-X</code> 不被映射。
这样做是为了能够使用所有的命名寄存器和标记，甚至当同样的名字被映射时
也是如此。


1.7 映 射 哪 些 键                                      <b class="vimtag">*<a name="map-which-keys">map-which-keys</a>*</b>

如果你要做一些映射，你得选择在 <code class="special">{lhs}</code> 中要用哪些键。你应该避免使用 Vim 命令所
使用的那些键。否则你将不再能使用这些命令了。下面是一些建议:
- 功能键 <code class="special">&lt;F2&gt;</code>，<code class="special">&lt;F3&gt;</code>，等等..  和Shift加功能键 <code class="special">&lt;S-F1&gt;</code>，<code class="special">&lt;S-F2&gt;</code>，等等。<code class="note">注意</code> <code class="special">&lt;F1&gt;</code>
  已经用做了帮助命令。
- Meta键 (和 ALT 键一起按下)。|<a href="map.html#:map-alt-keys">:map-alt-keys</a>|
- 使用 '_' 或 ',' 字符然后加上任何其它的字符。"_" 和 "," 命令在 Vim 中是存在
  的 (参考 |<a href="motion.html#_">_</a>| 和 |<a href="motion.html#,">,</a>|)，但你也许永远不会用到它们。
- 使用一个键作为其它命令的同义字。例如: <code class="keystroke">CTRL-P</code> 和
  <code class="keystroke">CTRL-N</code>。使用更多的字符做更多的映射。

参考文件 "index" 可以知道哪些键没有被使用从而使映射不会覆盖任何内建的功能。
也可使用 ":help <code class="special">{key}</code>^D" 来找出是否一个键已经用于某些命令。
(<code class="special">{key}</code> 用于指定你要寻找的键，^D 是 <code class="keystroke">CTRL-D</code>)。


1.8 示 例                                               <b class="vimtag">*<a name="map-examples">map-examples</a>*</b>

以下是一些例子 (照字面输入它们，对于 "<code class="special">&lt;CR&gt;</code>" 你输入四个字符;
当 '&lt;' 标志不出现在 'cpoptions' 中时它们能正常工作)。
<code class="example"></code>
<code class="example">   :map <code class="special">&lt;F3&gt;</code>  o#include</code>
<code class="example">   :map <code class="special">&lt;M-g&gt;</code> /foo<code class="special">&lt;CR&gt;</code>cwbar<code class="special">&lt;Esc&gt;</code></code>
<code class="example">   :map _x    d/END/e<code class="special">&lt;CR&gt;</code></code>
<code class="example">   :map! qq   quadrillion questions</code>


1.9 使 用 映 射                                         <b class="vimtag">*<a name="map-typing">map-typing</a>*</b>

当你输入一个映射键顺序时 Vim 会比较你的输入。如果还不匹配，它会等待更多的
字符输入直到可以确定是否匹配。例如: 如果你映射了 map! "qq"，然后你输入的第
一个 'q' 将不会显示在屏幕上直到你输入另一个 'q' 或其它字符。如果打开了
'timeout' 选项 (这是缺省选项) Vim 仅会等待一秒钟 (或者等待 'timeoutlen' 所
指定的时间)。然后假设 'q' 已经不会再被输入。如果你的输入很慢，或者你的系统
很慢，重置 'timeout' 选项。或者你可能需要设置 'ttimeout' 选项。

                                                        <b class="vimtag">*<a name="map-keys-fails">map-keys-fails</a>*</b>
有若干情况键编码可能不被识别:
- Vim 仅能读取部分的键编码。通常仅仅是第一个字符。在某些 Unix 版本的 xterm
  上有这种情况。
- 键编码后面的字符已经被映射。举例来说，"<code class="special">&lt;F1&gt;</code><code class="special">&lt;F1&gt;</code>" 或 "g<code class="special">&lt;F1&gt;</code>"。

其结果是在这种情况下键编码不会被识别，所以映射失败。有两种方法可以避免此问题:
- 从 'cpoptions' 中删除 'K' 标志。这会使 Vim 等待功能键剩下的部分。
- <code class="special">&lt;F1&gt;</code> 到 <code class="special">&lt;F4&gt;</code> 实际产生的键编码与 <code class="special">&lt;xF1&gt;</code> 到 <code class="special">&lt;xF4&gt;</code> 符合。
  这是 <code class="special">&lt;xF1&gt;</code> 到 <code class="special">&lt;F1&gt;</code>，<code class="special">&lt;xF2&gt;</code> 到 <code class="special">&lt;F2&gt;</code> 的映射，等等，但是这在映射的另一半不会被
  识别。确认从 <code class="special">&lt;F1&gt;</code> 到 <code class="special">&lt;F4&gt;</code> 的键编码是正确的:
<code class="example">        :set <code class="special">&lt;F1&gt;</code>=<code class="special">&lt;type <code class="keystroke">CTRL-V</code>&gt;</code><code class="special">&lt;type F1&gt;</code></code>
  以四个字符输入 <code class="special">&lt;F1&gt;</code>。"=" 号后面的部分必需以实际的字符输入，
  而不是字面的文本。
另一种解决方法是在映射中为第二个特殊键使用实际的键编码:
<code class="example">        :map <code class="special">&lt;F1&gt;</code><code class="special">&lt;Esc&gt;</code>OP :echo "yes"<code class="special">&lt;CR&gt;</code></code>
不要输入一个真正的 <code class="special">&lt;Esc&gt;</code>，总之 Vim 将识别键编码并把它替换为 <code class="special">&lt;F1&gt;</code>。

另一个问题可能是保持 ALT 或 Meta 的时候，终端在前面附加 ESC 而不是给第 8 位置
位。见 |<a href="map.html#:map-alt-keys">:map-alt-keys</a>|。

                                                <b class="vimtag">*<a name="recursive_mapping">recursive_mapping</a>*</b>
如果 <code class="special">{rhs}</code> 中包括了 <code class="special">{lhs}</code> 那么就是一个递归映射。当 <code class="special">{lhs}</code> 被输入，
它会被替换成 <code class="special">{rhs}</code>。当遇到 <code class="special">{rhs}</code> 中包含的 <code class="special">{lhs}</code> 它会被替换成 <code class="special">{rhs}</code>，
依此类推。
这可能会使一个命令被重复无数次。这种情况唯一的问题是出错是停止它的唯一方法。
有一些宏用来解决这种混乱情况，看下面的例子。有一个例外: 如果 <code class="special">{rhs}</code> 以 <code class="special">{lhs}</code>
开始，第一个字符不会被再次映射 (这与 Vi 兼容)。
例如:
<code class="example">   :map ab abcd</code>
将执行 "a" 命令并且在文本中插入 "bcd"。<code class="special">{rhs}</code> 中的 "ab" 不会被再次映射。

如果你要交换两个键的含义应该使用 :noremap 命令。例如:
<code class="example">   :noremap k j</code>
<code class="example">   :noremap j k</code>
这会交换光标上移和光标下移命令。

如果使用普通 :map 命令，并且 'remap' 选项被打开，映射一直进行直到文本不再是
<code class="special">{lhs}</code> 的一部分。例如，如果你用:
<code class="example">   :map x y</code>
<code class="example">   :map y x</code>
Vim 将把 x 替换成 y，并把 y 替换成 x，等等。这种情况会发生
'maxmapdepth' 次 (缺省为 1000)，然后 Vim 会给出错误信息 "recursive mapping"
(递归映射)。

                                                        <b class="vimtag">*<a name=":map-undo">:map-undo</a>*</b>
如果你在一个被映射的序列中包含了一个 undo 命令，将会把文本带回宏执行前的状态
这和原始的 Vi 是兼容的，只要被映射的序列仅包含一个 undo 命令 (原始的 Vi 中
被映射的序列有两个 undo 命令是无意义的，在第一个 undo 处你就会回到文本)。


1.10 映 射 ALT 键                                       <b class="vimtag">*<a name=":map-alt-keys">:map-alt-keys</a>*</b>

GUI 上，Vim 自己处理 Alt 键，所以用 ALT 键的映射应该总没有问题。但在终端上，
Vim 得到字节的序列，它必须自己判断是不是按了 ALT 键。

Vim 缺省假设按下 ALT 键等于置位输入字符的第 8 位。多数正常的终端如此工作，包括
xterm、aterm 和 rxvt。假如你的 <code class="special">&lt;A-k&gt;</code> 映射不能工作，可能的原因是你的终端用在字
符前加上 ESC 前缀的方法。但是你本来也可能在字符前输入 ESC，这时 Vim 就不知道到
底发生了什么 (只能检查字符间的延迟，但这并不可靠)。

在此文写作时，有些主流的终端，如 gnome-terminal 和 konsole，使用 ESC 前缀。没
有办法让它们用置位第 8 位来代替。Xterm 缺省没有问题。Aterm 和 rxvt 启动时如果
使用 "--meta8" 参数也可以如此。你也可以修改资源来达到目的: "metaSendsEscape"、
"eightBitInput" 和 "eightBitOutput"。

Linux 终端上，可以用 "setmetamode" 命令切换此行为。记住不使用 ESC 前缀可能和其
它程序发生冲突。确保你的 bash 把 "convert-meta" 选项设为 "on"，确保 Meta 键盘
绑定仍然工作 (这是缺省的 readline 行为，除非你的系统配置专门作了改变)。为此，
你需要加入这行:
<code class="example"></code>
<code class="example">        set convert-meta on</code>
<code class="example"></code>
到你的 ~/.inputrc 文件。如果你新建此文件，可能想把:
<code class="example"></code>
<code class="example">        $include /etc/inputrc</code>
<code class="example"></code>
放在第一行，只要此文件在你的系统中存在。这样可以保持全局的选项设置。
这可能会使 umlaut 这样的特殊字符的输入有问题。这时，输入字符前用 <code class="keystroke">CTRL-V</code> 前导。

要知道有报告说 convert-meta 使得 UTF-8 locale 的使用有问题。在 xterm 这样的终
端里，可以在 "Main Options" 菜单里随时切换 "metaSendsEscape" 资源，终端上按
Ctrl-LeftClick 也可以；这是最后一个可以使用的好资源，用它你可以发送 ESC 其它应
用程序，但在 VIM 里不如此。


1.11 映 射 操 作 符                                     <b class="vimtag">*<a name=":map-operator">:map-operator</a>*</b>

<code class="special">{motion}</code> 命令前使用操作符。要定义你自己的操作符，你需要先创建映射来设置
'operatorfunc' 选项，然后调用 |<a href="map.html#g@">g@</a>| 操作符。这样用户输入 <code class="special">{motion}</code> 命令后，会调
用指定的函数。

                                                        <b class="vimtag">*<a name="g@">g@</a>*</b> <b class="vimtag">*<a name="E774">E774</a>*</b> <b class="vimtag">*<a name="E775">E775</a>*</b>
g@<code class="special">{motion}</code>              调用 'operatorfunc' 选项设置的函数。
                        '[ 位置标记定位在 <code class="special">{motino}</code> 跨越的文本的开始处，而 ']
                        位置标记在此文本的结束处。
                        函数调用时，带一个字符串参数:
                            "line"      <code class="special">{motion}</code> 本是 |<a href="motion.html#linewise">linewise</a>|
                            "char"      <code class="special">{motion}</code> 本是 |<a href="motion.html#characterwise">characterwise</a>|
                            "block"     <code class="special">{motion}</code> 本是 |<a href="visual.html#blockwise-visual">blockwise-visual</a>||
                        不过，"block" 很少出现，因为它只能来自可视模式，那里
                        "g@" 不是很有用。
                        <code class="special">{only 仅当编译时加入 +eval 特性才有效}</code>

这里是一例，<code class="special">&lt;F4&gt;</code> 来计算空格数目:
<code class="example"></code>
<code class="example">        nmap <code class="special">&lt;silent&gt;</code> <code class="special">&lt;F4&gt;</code> :set opfunc=CountSpaces<code class="special">&lt;CR&gt;</code>g@</code>
<code class="example">        vmap <code class="special">&lt;silent&gt;</code> <code class="special">&lt;F4&gt;</code> :<code class="special">&lt;C-U&gt;</code>call CountSpaces(visualmode(), 1)<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
<code class="example">        function! CountSpaces(type, ...)</code>
<code class="example">          let sel_save = &amp;selection</code>
<code class="example">          let &amp;selection = "inclusive"</code>
<code class="example">          let reg_save = @@</code>
<code class="example"></code>
<code class="example">          if a:0  " 在可视模式里调用，使用 '<code class="special">&lt; 和 '&gt;</code> 位置标记。</code>
<code class="example">            silent exe "normal! `<code class="special">&lt;" . a:type . "`&gt;</code>y"</code>
<code class="example">          elseif a:type == 'line'</code>
<code class="example">            silent exe "normal! '[V']y"</code>
<code class="example">          elseif a:type == 'block'</code>
<code class="example">            silent exe "normal! `[\<code class="special">&lt;C-V&gt;</code>`]y"</code>
<code class="example">          else</code>
<code class="example">            silent exe "normal! `[v`]y"</code>
<code class="example">          endif</code>
<code class="example"></code>
<code class="example">          echomsg strlen(substitute(@@, '[^ ]', '', 'g'))</code>
<code class="example"></code>
<code class="example">          let &amp;selection = sel_save</code>
<code class="example">          let @@ = reg_save</code>
<code class="example">        endfunction</code>

<code class="note">注意</code> 'selection' 选项暂时设为 "inclusive"，以便可视模式下用 '[ 到 '] 位置标记
可以抽出正确的文本。

也要 <code class="note">注意</code> 这里为可视模式提供了专用的映射。它先删除 ":" 在可视模式里插入的
"'<code class="special">&lt;,'&gt;</code>" 范围，然后调用函数，调用时使用了 visualmode() 和一个额外的参数。

</pre><hr class="doubleline" /><pre>
<h4>2. 缩写                 <b class="vimtag">*<a name="abbreviations">abbreviations</a>*</b> <b class="vimtag">*<a name="Abbreviations">Abbreviations</a>*</b></h4>
缩写在插入，替换和命令行模式中使用。如果你输入一个是缩写的单词，它会被替换成
所表示的东西。这可以在经常输入的长单词时节省键击。并且能用它来自动更正经常犯
的拼写错误。例如:

        :iab ms MicroSoft
        :iab tihs this

有三种类型的缩写:

full-id   "full-id" 类型完全由关键字字符组成 (字母和 'iskeyword' 选项的字符)。
          这是最普通的缩写。

          例如: "foo"，"g3"，"-1"

end-id    "end-id" 类型以一个关键字字符结尾，但所有其它字符都不是关键字字符。

          例如: "#i"，"..f"，"$/7"

non-id    "non-id" 类型以一个非关键字字符结尾，其它字符可以是任意类型，除了空
          格和 Tab。  <code class="special">{Vi 不支持这种类型}</code>

          例如: "def#"，"4/7$"

不能被缩写的字串例子: "a.b"，"#def"，"a b"，"_$r"

仅当你输入一个非关键字字符时缩写才会被识别。或者用 <code class="special">&lt;Esc&gt;</code> 退出插入模式或用 <code class="special">&lt;CR&gt;</code>
结束一个命令。结束缩写的非关键字字符被插入到缩写的扩展后面。一个例外是字符
<code class="special">&lt;C-]&gt;</code>，它用来不插入任何附加字符时扩展一个缩写。

例如:
<code class="example">   :ab hh       hello</code>
            "hh<code class="special">&lt;Space&gt;</code>" 被扩展为 "hello<code class="special">&lt;Space&gt;</code>"
            "hh<code class="special">&lt;C-]&gt;</code>" 被扩展为 "hello"

光标前的字符必需和缩写匹配。每种类型都有一个附加规则:

full-id   匹配的前面是一个非关键字字符，或者是在行或插入的开始。例外: 当缩写仅
          有一个字符时，如果它前面有一个非关键字字符则不会被识别，除了空格和
          <code class="special">&lt;Tab&gt;</code>。

end-id    匹配的前面是一个关键字字符，或者一个空格或 <code class="special">&lt;Tab&gt;</code>，
          或者是行或插入的开始。

non-id    匹配的前面是一个空格，<code class="special">&lt;Tab&gt;</code> 或者行或插入的开始。

例如: (<code class="special">{CURSOR}</code> 是你输入一个非关键字字符的地方)
<code class="example">   :ab foo   four old otters</code>
                " foo<code class="special">{CURSOR}</code>"    被扩展为 " four old otters"
                " foobar<code class="special">{CURSOR}</code>" 不被扩展
                "barfoo<code class="special">{CURSOR}</code>"  不被扩展

<code class="example">   :ab #i #include</code>
                "#i<code class="special">{CURSOR}</code>"      被扩展为 "#include"
                "&gt;#i<code class="special">{CURSOR}</code>"     不被扩展

<code class="example">   :ab ;; <code class="special">&lt;endofline&gt;</code></code>
                "test;;"          不被扩展
                "test ;;"         被扩展为 "test <code class="special">&lt;endofline&gt;</code>"

要避免在插入模式中避免缩写: 输入缩写的一部分，以 <code class="special">&lt;Esc&gt;</code> 退出插入模式，再用 'a'
进入插入模式并输入剩下的部分。或者在缩写之后的字符前面输入 <code class="keystroke">CTRL-V</code>。
要在命令行模式中避免缩写: 在缩写的某处输入 <code class="keystroke">CTRL-V</code> 两次来避免它被替换。此外一个
普通字符前面的 <code class="keystroke">CTRL-V</code> 通常会被忽略。

把光标移动到缩写的后面是可能的:
<code class="example">   :iab if if ()<code class="special">&lt;Left&gt;</code></code>
如果 'cpoptions' 里面包含 '&lt;' 标志时不能正常工作。|<a href="intro.html#%3C%3E">&lt;&gt;</a>|

你甚至可以做更复杂的事情。例如，要消灭一个缩写后面输入的空格:
<code class="example">   func Eatchar(pat)</code>
<code class="example">      let c = nr2char(getchar(0))</code>
<code class="example">      return (c =~ a:pat) ? '' : c</code>
<code class="example">   endfunc</code>
<code class="example">   iabbr <code class="special">&lt;silent&gt;</code> if if ()<code class="special">&lt;Left&gt;</code><code class="special">&lt;C-R&gt;</code>=Eatchar('\s')<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
没有缺省的缩写。

缩写永远不会递归。你可以设置 ":ab f f-o-o" 而不会有任何问题。但是缩写能
被映射。<code class="special">{不清除原因，一些版本的Vi支持递归缩写}</code>

'paste' 选项打开时，缩写被禁止。

                                <b class="vimtag">*<a name=":abbreviate-local">:abbreviate-local</a>*</b> <b class="vimtag">*<a name=":abbreviate-%3Cbuffer%3E">:abbreviate-&lt;buffer&gt;</a>*</b>
和映射一样，缩写可以被局部于一个缓冲之内。这经常被用于一个
|<a href="usr_43.html#filetype-plugin">filetype-plugin</a>| 文件。例如一个 C 插件文件:
<code class="example">        :abb <code class="special">&lt;buffer&gt;</code> FF  for (i = 0; i &lt; ; ++i)</code>

                                                <b class="vimtag">*<a name=":ab">:ab</a>*</b> <b class="vimtag">*<a name=":abbreviate">:abbreviate</a>*</b>
:ab[breviate]           列出所有的缩写。第一栏中的字符表示该缩写作用的模式:
                        'i' 指插入模式，'c' 指命令行模式，'!' 指两种模式都有。
                        这和映射的相同，参看 |<a href="map.html#map-listing">map-listing</a>| 。

                                                <b class="vimtag">*<a name=":abbreviate-verbose">:abbreviate-verbose</a>*</b>
如果 'verbose' 非零，缩写的列出同时显示它最近定义的位置。例如:
<code class="example"></code>
<code class="example">        :verbose abbreviate</code>
<code class="example">        !  teh           the</code>
<code class="example">                Last set from /home/abcd/vim/abbr.vim</code>
<code class="example"></code>
|<a href="various.html#:verbose-cmd">:verbose-cmd</a>| 说明详情。

:ab[breviate] <code class="special">{lhs}</code>     列出以 <code class="special">{lhs}</code> 开头的缩写

:ab[breviate] [<code class="special">&lt;expr&gt;</code>] <code class="special">{lhs}</code> <code class="special">{rhs}</code>
                        增加一个从 <code class="special">{lhs}</code> 到 <code class="special">{rhs}</code> 的缩写。如果 <code class="special">{lhs}</code> 已经存在
                        则它会被替换成新的 <code class="special">{rhs}</code>。<code class="special">{rhs}</code> 可能包含空格。
                        |<a href="map.html#:map-%3Cexpr%3E">:map-&lt;expr&gt;</a>| 说明可选的 <code class="special">&lt;expr&gt;</code> 参数。

                                                <b class="vimtag">*<a name=":una">:una</a>*</b> <b class="vimtag">*<a name=":unabbreviate">:unabbreviate</a>*</b>
:una[bbreviate] <code class="special">{lhs}</code>   从列表中删除 <code class="special">{lhs}</code> 的缩写

                                                <b class="vimtag">*<a name=":norea">:norea</a>*</b> <b class="vimtag">*<a name=":noreabbrev">:noreabbrev</a>*</b>
:norea[bbrev] [<code class="special">&lt;expr&gt;</code>] [lhs] [rhs]
                        与 ":ab" 一样，但是不为这个 <code class="special">{rhs}</code> 重映射。  <code class="special">{not ni Vi}</code>

                                                <b class="vimtag">*<a name=":ca">:ca</a>*</b> <b class="vimtag">*<a name=":cabbrev">:cabbrev</a>*</b>
:ca[bbrev] [<code class="special">&lt;expr&gt;</code>] [lhs] [rhs]
                        与 ":ab" 一样，但仅在命令行模式中使用。  <code class="special">{not in Vi}</code>

                                                <b class="vimtag">*<a name=":cuna">:cuna</a>*</b> <b class="vimtag">*<a name=":cunabbrev">:cunabbrev</a>*</b>
:cuna[bbrev] <code class="special">{lhs}</code>      与 ":una" 一样，但仅在命令行模式中使用。  <code class="special">{not in Vi}</code>

                                                <b class="vimtag">*<a name=":cnorea">:cnorea</a>*</b> <b class="vimtag">*<a name=":cnoreabbrev">:cnoreabbrev</a>*</b>
:cnorea[bbrev] [<code class="special">&lt;expr&gt;</code>] [lhs] [rhs]
                        与 ":ab" 一样，但仅在命令行模式中使用并且不为这个
                        <code class="special">{rhs}</code> 重映射。  <code class="special">{Vi 中没有}</code>

                                                <b class="vimtag">*<a name=":ia">:ia</a>*</b> <b class="vimtag">*<a name=":iabbrev">:iabbrev</a>*</b>
:ia[bbrev] [<code class="special">&lt;expr&gt;</code>] [lhs] [rhs]
                        与 ":ab" 一样，但仅在插入模式中使用。  <code class="special">{not in Vi}</code>

                                                <b class="vimtag">*<a name=":iuna">:iuna</a>*</b> <b class="vimtag">*<a name=":iunabbrev">:iunabbrev</a>*</b>
:iuna[bbrev] <code class="special">{lhs}</code>      与 ":una" 一样，但仅在插入模式中使用。  {not in
                        Vi}

                                                <b class="vimtag">*<a name=":inorea">:inorea</a>*</b> <b class="vimtag">*<a name=":inoreabbrev">:inoreabbrev</a>*</b>
:inorea[bbrev] [<code class="special">&lt;expr&gt;</code>] [lhs] [rhs]
                        与 ":ab" 一样，但仅在插入模式中使用并且
                        不为这个 <code class="special">{rhs}</code> 重映射。  <code class="special">{not in Vi}</code>

                                                        <b class="vimtag">*<a name=":abc">:abc</a>*</b> <b class="vimtag">*<a name=":abclear">:abclear</a>*</b>
:abc[lear]              删除所有的缩写。  <code class="special">{not in Vi}</code>

                                                        <b class="vimtag">*<a name=":iabc">:iabc</a>*</b> <b class="vimtag">*<a name=":iabclear">:iabclear</a>*</b>
:iabc[lear]             为插入模式删除所有的缩写。  <code class="special">{not in Vi}</code>

                                                        <b class="vimtag">*<a name=":cabc">:cabc</a>*</b> <b class="vimtag">*<a name=":cabclear">:cabclear</a>*</b>
:cabc[lear]             为命令行模式删除所有的缩写。  {not
                        in Vi}

                                                        <b class="vimtag">*<a name="using_CTRL-V">using_CTRL-V</a>*</b>
在一个缩写的 <code class="special">{rhs}</code> 中使用特殊字符是可能的。<code class="keystroke">CTRL-V</code> 可以用来避免多数非打印字符
的特殊含义。需要输入多少个 <code class="keystroke">CTRL-V</code> 取决于你如何输入缩写。这在映射中也可以应用。
这里使用一个例子说明。

假设你需要把 "esc" 缩写为输入一个 <code class="special">&lt;Esc&gt;</code> 字符。当你在 Vim 中输入
":ab" 命令，你必需这样输入: (这里 ^V 是一个 <code class="keystroke">CTRL-V</code>
并且 ^[ is <code class="special">&lt;Esc&gt;</code>)

你输入:   ab esc ^V^V^V^V^V^[

        所有的键盘输入都遵从 ^V 引用解释，所以第一个，第三个，和第五个
        ^V  字符只是为了允许把第二个，和第四个  ^V 和 ^[ 输入到命令行里。

你看到:    ab esc ^V^V^[

        命令行里在 ^[ 之前包含两个实际的 ^V。如果你采用这种方法，这是
        它应该出现在你的 .exrc 文件的样子。第一个 ^V 作为它自己引用的字符，
        所以你能在缩写中包含被引用的空白字符或 | 字符。:ab 命令对 ^[ 字符
        并不做特殊的事情，所以不需要被引用。(尽管引用是无害的; 这就是输入7个
        [而不是 8 个!] ^V 会工作的原因.)

被保存为:  esc     ^V^[

        解析后，该缩写的简短形式 ("esc") 和扩展形式 (两字符 "^V^[") 被保存
        在缩写表中。如果输入不带参数的 :ab 命令，这是该缩写被显示的形式。

        然后当用户输入单词 "esc" 而该缩写被扩展时，扩展形式服从和键盘输入
        同样形式的 ^V 解释。所以 ^V 保护 ^[ 字符不被解释为 "退出插入模式"
        的字符，而是把 ^[ 插入到文本里面。

扩展为: ^[

[Steve Kirkendall 提供示例]

</pre><hr class="doubleline" /><pre>
<h4>3. 局部映射和函数                               <b class="vimtag">*<a name="script-local">script-local</a>*</b></h4>
当使用多个 Vim 脚本文件时，一个脚本和另一个脚本使用同样名字的映射和函数是危险
的。为了避免这种情况，它们可以被局部在脚本中。

                                                <b class="vimtag">*<a name="%3CSID%3E">&lt;SID&gt;</a>*</b> <b class="vimtag">*<a name="%3CSNR%3E">&lt;SNR&gt;</a>*</b> <b class="vimtag">*<a name="E81">E81</a>*</b>
字串 "<code class="special">&lt;SID&gt;</code>" 能被用于一个映射或菜单中。这要求 'cpoptions' 中没有
'&lt;' 标志。
   当执行映射命令时，Vim 将把 "<code class="special">&lt;SID&gt;</code>" 替换成特殊的键码 <code class="special">&lt;SNR&gt;</code>，后跟一个每个脚
本唯一的数字编号，和一个下划线。例如:
<code class="example">        :map <code class="special">&lt;SID&gt;</code>Add</code>
会定义一个映射 "<code class="special">&lt;SNR&gt;</code>23_Add"。

当在一个脚本中定义一个函数的时候，可以在名字的前面用一个 "s:" 来使它局部于脚
本中。但当一个映射从脚本外面被执行时，它不知道该函数在哪个脚本中被定义。为了
避免这种情况，使用 "<code class="special">&lt;SID&gt;</code>" 来代替 "s:"。它会做和映射一样的转换。这使得在映射
里可以定义一个函数调用。

当一个局部函数被执行时，它在定义他的脚本的上下文中运行。这意味着，它定义的新
的函数和映射也可以使用  "s:" 或 "<code class="special">&lt;SID&gt;</code>" 并且当函数自己被定义时它也会使用同样
唯一的数字编码。此外，能使用 "s:var" 脚本局部变量。

当执行一个自动命令或一个用户命令时，它将在定义它的脚本的上下文中运行。这使得
该命令可以调用一个局部函数或者使用一个局部映射。

此外，在一个脚本上下文之外使用 "<code class="special">&lt;SID&gt;</code>" 是错误的。

如果你需要在一个复杂的脚本中取得脚本的数字编号，使用此函数:
<code class="example">        function s:SID()</code>
<code class="example">          return matchstr(expand('<code class="special">&lt;sfile&gt;</code>'), '<code class="special">&lt;SNR&gt;</code>\zs\d\+\ze_SID$')</code>
<code class="example">        endfun</code>
<code class="example"></code>
当列表函数和映射时 "<code class="special">&lt;SNR&gt;</code>" 会被显示。要找出它们在哪里被定义时有用。

命令 |<a href="repeat.html#:scriptnames">:scriptnames</a>| 可以用来查看哪些脚本已经被读入以及它们的 <code class="special">&lt;SNR&gt;</code> 数字编号。

这些都是 <code class="special">{Vi 无此功能}</code> 并且 <code class="special">{only 仅当编译时加入 +eval 特性才有效}</code>。

</pre><hr class="doubleline" /><pre>
<h4>4. 用户定义的命令                               <b class="vimtag">*<a name="user-commands">user-commands</a>*</b></h4>
可以定义你自己的 Ex 命令。一个用户定义命令可以和内建命令一样运行 (他可以有一个
类型或参数，参数可以是自动补全的文件名或缓冲名，等等)，除了当这些命令被执行的
时候，会被转换成一个普通的 ex 命令然后再被执行。

对于初学者来说: 参考用户手册中的 |<a href="usr_40.html#40.2">40.2</a>| 。

                                                <b class="vimtag">*<a name="E183">E183</a>*</b> <b class="vimtag">*<a name="user-cmd-ambiguous">user-cmd-ambiguous</a>*</b>
所有用户定义的命令都必需以一个大写字母开头，来避免与内建命令的冲突。(要<code class="note">注意</code>
的是，有一些内建命令比如 :Next，:Print and :X，也以大写字母开头。在这些情况
下内建的命令总是优先执行的)。用户命令的其它字符可以是大写字母，小写字母或数字。
当使用数字时，小心会和其它以数字作为参数的命令混淆。例如，命令 ":Cc2" 可能是
不带参数的用户命令 ":Cc2"，也可能是参数为 "2" 的命令 "Cc"。建议在命令名和参数
之间放置一个空格来避免这些问题。

当使用一个用户定义的命令时，该命令可以是缩写。但是，如果一个缩写不唯一，会发生
错误。此外，一个内建命令将总是被优先执行。

例如:
<code class="example">        :command Rename ..。</code>
<code class="example">        :command Renumber ..。</code>
<code class="example">        :Rena                           " Means "Rename"</code>
<code class="example">        :Renu                           " Means "Renumber"</code>
<code class="example">        :Ren                            " Error - ambiguous</code>
<code class="example">        :command Paste ..。</code>
<code class="example">        :P                              " The built-in :Print</code>
<code class="example"></code>
建议在脚本中使用用户定义命令的全名。

:com[mand]                                              <b class="vimtag">*<a name=":com">:com</a>*</b> <b class="vimtag">*<a name=":command">:command</a>*</b>
                        列出所有用户定义命令。在列出命令时，
                        前两栏的字符表示
                            !   命令有 -bang 属性
                            "   命令有 -register 属性
                            b   命令局部于当前缓冲
                        (下面有属性的详细描述)

:com[mand] <code class="special">{cmd}</code>        列出以 <code class="special">{cmd}</code> 开头的用户命令

                                                        <b class="vimtag">*<a name=":command-verbose">:command-verbose</a>*</b>
如果 'verbose' 非零，命令的列出同时显示它最近定义的位置。例如:
<code class="example"></code>
<code class="example">    :verbose command TOhtml</code>
<code class="section">        Name        Args Range Complete  Definition </code>
<code class="section">        TOhtml      0    %               :call Convert2HTML(<code class="special">&lt;line1&gt;</code>, <code class="special">&lt;line2&gt;</code>) </code>
<code class="section">            Last set from /usr/share/vim/vim-7.0/plugin/tohtml.vim </code>

|<a href="various.html#:verbose-cmd">:verbose-cmd</a>| 介绍详情。

                                                        <b class="vimtag">*<a name="E174">E174</a>*</b> <b class="vimtag">*<a name="E182">E182</a>*</b>
:com[mand][!] [<code class="special">{attr}</code>...] <code class="special">{cmd}</code> <code class="special">{rep}</code>
                        定义一个用户命令。命令的名字是
                        <code class="special">{cmd}</code> 并且它替换的文本是 <code class="special">{rep}</code>。该命令的属性
                        (参考下面)是 <code class="special">{attr}</code>。如果该命令已存在，会报告错误，
                         除非已经指定了一个 !，这种情况下命令被重定义。

:delc[ommand] <code class="special">{cmd}</code>                             <b class="vimtag">*<a name=":delc">:delc</a>*</b> <b class="vimtag">*<a name=":delcommand">:delcommand</a>*</b> <b class="vimtag">*<a name="E184">E184</a>*</b>
                        删除用户定义命令 <code class="special">{cmd}</code>。

:comc[lear]                                             <b class="vimtag">*<a name=":comc">:comc</a>*</b> <b class="vimtag">*<a name=":comclear">:comclear</a>*</b>
                        删除所有用户定义命令。

命令属性

Vim 和任何其它 ex 命令一样对待用户定义命令。它能有参数，或者指定一个类别。
以文件名，缓冲等等作为参数。它怎样工作完全取决于命令的属性，属性在命令被
定义时被指定。

有很多种属性，分为四大类: 参数处理，填充行为，范围处理，和特殊情况。
属性在下面分类描述。

参数处理                                        <b class="vimtag">*<a name="E175">E175</a>*</b> <b class="vimtag">*<a name="E176">E176</a>*</b>

缺省时，一个用户定义的命令将不接受参数 (如果使用了任何参数会报错)。
但是指定命令可以接受参数是可能的，使用 -nargs 属性，有效的情况有:

        -nargs=0    不允许有参数 (缺省情况)
        -nargs=1    要求一个参数。
        -nargs=*    允许任何数目的参数 (0，1 或更多)
        -nargs=?    允许 0 或 1 个参数
        -nargs=+    必需给出参数，但是数目任意

在这个上下文里，参数被认为是以空格或Tab来分隔的。

自动补全行为                            <b class="vimtag">*<a name=":command-completion">:command-completion</a>*</b>
                                                        <b class="vimtag">*<a name="E179">E179</a>*</b> <b class="vimtag">*<a name="E180">E180</a>*</b> <b class="vimtag">*<a name="E181">E181</a>*</b>
缺省时，用户定义命令的参数不进行自动补全。但是，通过指定以下的一个或多个属性
后，参数可以进行自动补全

        -complete=augroup       autocmd 组
        -complete=buffer        缓冲名
        -complete=command       Ex 命令 (及其参数)
        -complete=dir           目录名
        -complete=environment   环境变量名
        -complete=event         autocommand 事件
        -complete=expression    Vim 表达式
        -complete=file          文件和目录名
        -complete=shellcmd      外壳命令
        -complete=function      函数名
        -complete=help          帮助主题
        -complete=highlight     高亮显示的部分
        -complete=mapping       映射名
        -complete=menu          菜单
        -complete=option        选项
        -complete=tag           标签
        -complete=tag_listfiles 当敲入 <code class="keystroke">CTRL-D</code> 时显示的标签，文件名
        -complete=var           用户变量
        -complete=custom,<code class="special">{func}</code> 用户定制的自动补全，通过 <code class="special">{func}</code> 来定义
        -complete=customlist,<code class="special">{func}</code> 用户定制的自动补全，通过 <code class="special">{func}</code> 来定义


用户定制的自动补全                      <b class="vimtag">*<a name=":command-completion-custom">:command-completion-custom</a>*</b>
                                        <b class="vimtag">*<a name=":command-completion-customlist">:command-completion-customlist</a>*</b>
                                        <b class="vimtag">*<a name="E467">E467</a>*</b> <b class="vimtag">*<a name="E468">E468</a>*</b>
通过 "custom,<code class="special">{func}</code>" 或 "customlist,<code class="special">{func}</code>" 自动补全参数可以定义定制的自动补全
方案。其中 <code class="special">{func}</code> 是有如下原型的函数:

        :function <code class="special">{func}</code>(ArgLead，CmdLine，CursorPos)

该函数不需要使用所有的这些参数，但是应该提供自动补全候选作为返回值，

对于 "custom" 参数，函数应该返回字符串，每行一个候选，用换行符分隔。

对于 "customlist" 参数，函数应该返回 Vim 列表形式的补全候选。忽略列表里的非字
符串项目。

该函数的参数是:
        ArgLead         当前自动补全的前导参数
        CmdLine         完整的命令行
        CursorPos       里面的光标位置 (字节位置)
该函数可能要根据这些来判别上下文。对 "custom" 参数，它不必要来过滤对应 ArgLead
(里面的隐式规则) 的候选。在函数返回时 Vim 将用它的正则表达式引擎来进行过滤，这
种方式在大多数情况下效率更高。对于 "cusotmlist" 参数，Vim 不会过滤返回的补全候
选，用户提供的函数应该自己过滤候选。

以下的例子为一个 Finger 命令列出用户名
<code class="example">    :com -complete=custom,ListUsers -nargs=1 Finger !finger <code class="special">&lt;args&gt;</code></code>
<code class="example">    :fun ListUsers(A,L,P)</code>
<code class="example">    :    return system("cut -d: -f1 /etc/passwd")</code>
<code class="example">    :endfun</code>
<code class="example"></code>
下例从 'path' 选项指定的目录补全文件名:
<code class="example">    :com -nargs=1 -bang -complete=customlist,EditFileComplete</code>
<code class="example">                        \ EditFile edit<code class="special">&lt;bang&gt;</code> <code class="special">&lt;args&gt;</code></code>
<code class="example">    :fun EditFileComplete(A,L,P)</code>
<code class="example">    :    return split(globpath(&amp;path, a:ArgLead), "\n")</code>
<code class="example">    :endfun</code>


范围处理                                                <b class="vimtag">*<a name="E177">E177</a>*</b> <b class="vimtag">*<a name="E178">E178</a>*</b>

缺省时，用户定义的命令不接受一个行号范围。但是，也可以指定命令能够接受
一个范围 (-range 熟悉)，或者接受一个任意的数量值，可以是行号位置
(-range=N，与 |<a href="windows.html#:split">:split</a>| 命令类似) 或者作为一个 "数量" 参数
(-count=N，与 |<a href="editing.html#:Next">:Next</a>| 命令类似)。可能的属性有:

        -range      允许使用范围，缺省为当前行
        -range=%    允许使用范围，缺省是整个文件 (1,$)
        -range=N    一个数量 (缺省是 N) 用来指定行号位置 (与 |<a href="windows.html#:split">:split</a>|类似)
        -count=N    一个数量 (缺省是 N) 用来指定行号位置，或者是作为一个初始
                    参数 (与 |<a href="editing.html#:Next">:Next</a>| 类似) 指定一个 -count (不设缺省值) 和
                    -count=0 一样

<code class="note">注意</code> -range=N 和 -count=N 是互斥的 - 只应该指定其中的一个。

特殊情况

有一些特殊情况:

        -bang       这些命令可以使用一个 ! 修饰服 (和 :q 或 :w 类似)
        -bar        这些命令可以跟随一个 "|" 和其它命令。那么命令参数中就
                    不允许有 "|" 。用一个 " 可以开始一个注释。
        -register   给这些命令的第一个参数可以是一个可选的寄存器名
                    (和 :del，:put，:yank 类似)。
        -buffer     这些命令仅在当前缓冲里有效。

在 -count 和 -register 属性的情况里，如果可选的参数被应用，它会被从参数列
表中删除，并且在分别的文本替换中有效。

文本替换

一个用户定义命令的文本替换被以特殊的转义序列来扫描，使用 <code class="special">&lt;...&gt;</code> 符号。变换
序列被从命令行输入的值替换，并且所有其它文本都被不变的拷贝。结果字串被作为
一个 Ex 命令来执行。要避免替换，使用 <code class="special">&lt;lt&gt;</code> 代替初始的 &lt;。这样，要按本义包含
"<code class="special">&lt;bang&gt;</code>"，使用 "<code class="special">&lt;lt&gt;</code>bang&gt;"。

有效的转义序列有

                                                <b class="vimtag">*<a name="%3Cline1%3E">&lt;line1&gt;</a>*</b>
        <code class="special">&lt;line1&gt;</code> 命令处理范围的开始行。
                                                <b class="vimtag">*<a name="%3Cline2%3E">&lt;line2&gt;</a>*</b>
        <code class="special">&lt;line2&gt;</code> 命令处理范围的末尾行。
                                                <b class="vimtag">*<a name="%3Ccount%3E">&lt;count&gt;</a>*</b>
        <code class="special">&lt;count&gt;</code> 被应用的任意数量 (在 '-range'
                和 '-count' 属性中描述过的)。
                                                <b class="vimtag">*<a name="%3Cbang%3E">&lt;bang&gt;</a>*</b>
        <code class="special">&lt;bang&gt;</code>  (参考 '-bang' 属性) 扩展出一个 ! 如果该命令执行的
                时候带了一个 ! 修饰符，否则什么也不扩展。
                                                <b class="vimtag">*<a name="%3Creg%3E">&lt;reg&gt;</a>*</b> <b class="vimtag">*<a name="%3Cregister%3E">&lt;register&gt;</a>*</b>
        <code class="special">&lt;reg&gt;</code>   (参考 '-register' 属性) 可选的寄存器，如果指定的话。
                否则什么也不扩展。<code class="special">&lt;register&gt;</code> 是它的一个同义词。
                                                <b class="vimtag">*<a name="%3Cargs%3E">&lt;args&gt;</a>*</b>
        <code class="special">&lt;args&gt;</code>  命令的参数，与被提供的精确相同 (但正如上面提到过的，任何
                数量值或寄存器会消耗一些参数，这时它们已不是 <code class="special">&lt;args&gt;</code> 的一
                部分了)。
        <code class="special">&lt;lt&gt;</code>    一个单独的 '&lt;' (小于号) 字符。在转义序列扩展时如果需要得到
                一个字面意义的大小于号的拷贝时需要。- 例如，要获得 <code class="special">&lt;bang&gt;</code>，
                使用 <code class="special">&lt;lt&gt;</code>bang&gt;。

                                                        <b class="vimtag">*<a name="%3Cq-args%3E">&lt;q-args&gt;</a>*</b>
如果一个转义序列的最前两个字符是 "q-" (例如，<code class="special">&lt;q-args&gt;</code>) 那么该值用引号括起，使
之在表达式里使用时成为合法的值。这种方式把参数当做单个值。
如果没有参数，<code class="special">&lt;q-args&gt;</code> 是空字符串。

要允许命令把它们的参数传送给一个用户定义的函数，有一种特殊的形式 <code class="special">&lt;f-args&gt;</code>
("function args")。它在空格和Tab的地方分裂命令行参数，分别用引号括起每个参数，
并且 <code class="special">&lt;f-args&gt;</code> 序列被逗号分隔的括起的参数列表所替换。参考下面的 Mycmd 示例。
当没有参数时，删除 <code class="special">&lt;f-args&gt;</code>。

示例
<code class="example"></code>
<code class="example">   " 删除从这里到末尾的所有东西</code>
<code class="example">   :com Ddel +,$d</code>
<code class="example"></code>
<code class="example">   " 把当前缓冲改名</code>
<code class="example">   :com -nargs=1 -bang -complete=file Ren f <code class="special">&lt;args&gt;</code>|w<code class="special">&lt;bang&gt;</code></code>
<code class="example"></code>
<code class="example">   " 用一个文件的内容来替换某个范围内的内容</code>
<code class="example">   " (以一行输入所有这些东西)</code>
<code class="example">   :com -range -nargs=1 -complete=file</code>
<code class="example">         Replace <code class="special">&lt;line1&gt;</code>-pu_|<code class="badlink">&lt;line1&gt;,&lt;line2&gt;d</code>|r <code class="special">&lt;args&gt;</code>|<code class="special">&lt;line1&gt;</code>d</code>
<code class="example"></code>
<code class="example">   " 计算范围内的行数</code>
<code class="example">   :com! -range -nargs=0 Lines  echo <code class="special">&lt;line2&gt;</code> - <code class="special">&lt;line1&gt;</code> + 1 "lines"</code>
<code class="example"></code>
<code class="example">   " 调用一个用户函数 (<code class="special">&lt;f-args&gt;</code> 的示例)</code>
<code class="example">   :com -nargs=* Mycmd call Myfunc(<code class="special">&lt;f-args&gt;</code>)</code>
<code class="example"></code>
当被这样执行时:
<code class="example">        :Mycmd arg1 arg2</code>
它将调用:
<code class="example">        :call Myfunc("arg1","arg2")</code>
<code class="example"></code>
<code class="example">   :" 一个更实用的例子</code>
<code class="example">   :function Allargs(command)</code>
<code class="example">   :    let i = 0</code>
<code class="example">   :    while i &lt; argc()</code>
<code class="example">   :       if filereadable(argv(i))</code>
<code class="example">   :        execute "e " . argv(i)</code>
<code class="example">   :         execute a:command</code>
<code class="example">   :      endif</code>
<code class="example">   :      let i = i + 1</code>
<code class="example">   :   endwhile</code>
<code class="example">   :endfunction</code>
<code class="example">   :command -nargs=+ -complete=command Allargs call Allargs(<code class="special">&lt;q-args&gt;</code>)</code>
<code class="example"></code>
命令 Allargs 以任意 Vim 命令作为参数并在参数列表里的所有文件上执行它。使用示例
(<code class="note">注意</code>使用 "e" 标志来忽略错误并且用 "update" 命令来写被修改的缓冲区):
        :Allargs %s/foo/bar/ge|update
它将调用:
<code class="example">        :call Allargs("%s/foo/bar/ge|update")</code>

当在一个脚本里定义一个用户命令时，它可以调用局部于脚本中的函数并且使用映射
来局部于该脚本。当用户调用用户命令时，该命令将运行在定义它的脚本的上下文里，
如果一个命令中使用了 |<a href="map.html#%3CSID%3E">&lt;SID&gt;</a>| 的时候这很重要。

 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 2006年 06月 24日 星期六 00:27:59 UTC</i></p>
</body>
</html>
