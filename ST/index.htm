<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<!-- saved from url=(0024)http://glaciated.org/vi/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=GBK">
  <link rev="made" href="mailto:totten@pobox.com">
  <!--<LINK REL=STYLESHEET HREF="../standard.css"-->
  <link rel="contents" href="http://glaciated.org/vi/toc.html">
  <link rel="copyright" href="http://pobox.com/~totten/copyleft/">
  <link rel="top" href="http://pobox.com/~totten/">
  <link rel="icon" href="http://glaciated.org/img/fred.png" type="image/png">
  <title>VI reference manual for the vi text editor</title>
  <meta name="description" content="VI visual edit (vi text editor) reference manual help sheet">
  <meta name="keywords" content="visual vi text editor manual manpage man page vim elvis vile">
<link rel="stylesheet" type="text/css" href="chrome-extension://lfjamigppmepikjlacjdpgjaiojdjhoj/css/menu.css"></head>
<body bgcolor="#E0D070" text="#000000" tlik="#007000" vlink="#4040e0" alink="#FF0000">
  <h1 align="center"><i>VI</i>(Visual) Editor Reference manual</h1>

  <a name="intro"></a>
  <p align="justify">The <i>vi</i> is a text editor. It is small, powerful,
    and standard on most UNIX systems. The <i>vi</i> often frustrates new
    users with a unique distinction between its two modes: <em>Command
    Mode</em> and <em>Insert/Overtype Mode</em>. This distinction,
    although difficult to become accustomed to for many users, provides
    great power and ability to the vi editor. Insert/Overtype Mode is
    designed for inserting text only. All text manipulations and cursor
    moving should be done from with in Command Mode. To know the
    vi editor well, is to love it.  This page is not meant to replace
    the vi manual or vi man page.  They are fine the way they are.  This
    page is to provide a quick reference sheet for the vi editor and it's
    most often used functions.  Editors such as vim or vile are supersets
    (at least for the most part) of the vi editor, so this page should
    still prove useful.  I hope even the most ardent vi lover can find
    something useful in this vi editor reference page.</p>
  <hr>
   
  <hr>
  <a name="enter"></a>
  <h2>Entering the <i>vi</i></h2>
  <table>
    <tbody><tr><td><samp>prompt$</samp> <kbd>vi</kbd>
    </td></tr><tr><td><samp>prompt$</samp> <kbd>vi file1 file2 ...</kbd>
    </td></tr><tr><td><samp>prompt$</samp> <kbd>vi -r file</kbd>
      </td><td><em>#Recover file from crash</em>
    </td></tr><tr><td><samp>prompt$</samp> <kbd>vi +string file</kbd>
      </td><td><em>#Execute ex command "string"</em>
    </td></tr><tr><td><samp>prompt$</samp> <kbd>vi @rcfile</kbd>
      </td><td><em>#Read commands from rcfile</em>
  </td></tr></tbody></table>
  <a name="modes"></a>
  <h2>Insert/Overtype Mode</h2>
  <p align="justify">Insert/Overtype Mode is solely for entering text.
    To leave one of these two modes press the <kbd>[ESC]</kbd> key.
    if you wish to enter the <kbd>ESC</kbd> character or any other
    control character while in insert mode: type
    <kbd>[CONTROL]-V</kbd> and then the control sequence. The only
    difference between Insert Mode and Overtype Mode is that characters
    are placed in front of the text after the cursor in Insert Mode, where
    as existing characters are overwritten in Overtype Mode.</p>
  <a name="command"></a>
  <h2>Command Mode</h2>
  <a name="enter_insert"></a>
  <h3>Entering Insert Mode</h3>
  <table>
    <tbody><tr><td><code>a</code></td><td>append text, after the cursor
    </td></tr><tr><td><code>i</code></td><td>insert text, before the cursor
    </td></tr><tr><td><code>R</code></td><td>enter Overtype Mode
    </td></tr><tr><td><code>A</code></td><td>append text, after end of line
    </td></tr><tr><td><code>I</code></td><td>insert text, before first non-whitespace character
    </td></tr><tr><td><code>o</code></td><td>open new line below cursor in Insert Mode
    </td></tr><tr><td><code>O</code></td><td>open new line above cursor in Insert Mode
  </td></tr></tbody></table>
  <a name="syntax"></a>
  <h3><i>vi</i> Syntax</h3>
  <dl>
    <dt><i>vi</i> commands follow the general form:
      </dt><dd><em>n</em> <code>operator</code> <em>m</em> <code>object</code>
    </dd><dt>which means:
      </dt><dd>execute <code>operator</code> <em>n</em> times on <em>m</em>
        <code>objects</code>. If <em>n</em> and/or <em>m</em> are
        omitted, they default to 1.
    </dd><dt>Operators which take objects are(if the operator is pressed twice
      then the object is the current line)
      </dt><dd><table>
            <tbody><tr><td><code>c</code></td><td>Change
            </td></tr><tr><td><code>d</code></td><td>Deletion
            </td></tr><tr><td><em>"c</em><code>y</code></td><td>Yank, if <em>"c</em> is omitted,
              uses general buffer.
            </td></tr><tr><td><code>&lt;</code></td><td>shift lines left by shiftwidth variable
            </td></tr><tr><td><code>&gt;</code></td><td>shift lines right by shiftwidth variable
            </td></tr><tr><td><code>!</code><em>cmd</em></td><td>filter trough
              <em>cmd</em>
          </td></tr></tbody></table>
          <samp>#The operators &lt;, &gt;, and ! are line based so
            the set of <code>objects</code> is diminished greatly.</samp>
    </dd><dt>Operators which do <strong>not</strong> take objects:
      </dt><dd><table>
            <tbody><tr><td><code>s</code></td><td>Substitute
            </td></tr><tr><td><code>x</code></td><td>Delete character
            </td></tr><tr><td><code>r</code></td><td>Replace character
            </td></tr><tr><td><code>~</code></td><td>change case of character
          </td></tr></tbody></table>
    </dd><dt><a name="objects">Objects</a> (if given without an operator
      are interpreted as a cursor motion command):
      </dt><dd><table>
            <tbody><tr><td><code>w</code></td><td>forward until beginning of word
            </td></tr><tr><td><code>e</code></td><td>forward until end of word
            </td></tr><tr><td><code>b</code></td><td>backward until beginning of word
            </td></tr><tr><td><code>$</code></td><td>forward until end of line
            </td></tr><tr><td><code>^</code></td><td>backward until first non-whitespace character
            </td></tr><tr><td><code>0</code></td><td>backward until first column of line
            </td></tr><tr><td><em>n</em><code>G</code></td><td>line number <em>n</em>. (default: <code>$</code>, i.e. last line of file)
            </td></tr><tr><td><em>n</em><code>|</code></td><td>column <em>n</em> of current line

            </td></tr><tr><td><code>/</code><em>pat</em></td><td>forward until beginning
              of <em>pat</em>, search
            </td></tr><tr><td><code>?</code><em>pat</em></td><td>backward until beginning
              of <em>pat</em>, backward search
            </td></tr><tr><td><code>n</code></td><td>repeat last search
            </td></tr><tr><td><code>N</code></td><td>repeat last search/backward search, but in
              opposite direction
            </td></tr><tr><td><code>%</code></td><td>until match of parenthesis, brace, or bracket
            </td></tr><tr><td><code>t</code><em>c</em></td><td>until next appearance of <em>c</em>
              on current line
            </td></tr><tr><td><code>T</code><em>c</em></td><td>backward until next appearance
              of <em>c</em> on current line
            </td></tr><tr><td><code>f</code><em>c</em></td><td>until and including next
              appearance of <em>c</em> on current line
            </td></tr><tr><td><code>F</code><em>c</em></td><td>backward until and including next
              appearance of <em>c</em> on current line
            </td></tr><tr><td><code>;</code></td><td>repeat last f, F, t, or T
            </td></tr><tr><td><code>,</code></td><td>repeat last f, F, t, or T in reverse

            </td></tr><tr><td><code>}</code></td><td>forward until end of paragraph
            </td></tr><tr><td><code>{</code></td><td>backward until end of paragraph
            </td></tr><tr><td><code>)</code></td><td>forward until end of sentence
            </td></tr><tr><td><code>(</code></td><td>backward until end of sentence
            </td></tr><tr><td><code>]]</code></td><td>forward until end of section
            </td></tr><tr><td><code>[[</code></td><td>backward until end of section

            </td></tr><tr><td><em>n</em><code>H</code></td><td><em>n</em> lines before first
              line on screen; <em>n</em> defaults to 0
            </td></tr><tr><td><em>n</em><code>L</code></td><td><em>n</em> lines before last
              line on screen; <em>n</em> defaults to 0
            </td></tr><tr><td><code>M</code></td><td>the middle line of the screen

            </td></tr><tr><td><code>j</code></td><td>down one line
            </td></tr><tr><td><code>k</code></td><td>up one line
            </td></tr><tr><td><code>h</code></td><td>left one character
            </td></tr><tr><td><code>l</code></td><td>right one character
            </td></tr><tr><td><code>[BS]</code></td><td>left one character, backspace usually
              equals ^H
            </td></tr><tr><td><code>[SPACE]</code></td><td>right one character
            </td></tr><tr><td><code>_</code></td><td>the entire current line
            </td></tr><tr><td><code>-</code></td><td>until first non-whitespace character on
              previous line
            </td></tr><tr><td><code>+</code></td><td>until first non-whitespace character on
              next line
            </td></tr><tr><td><code>[RETURN]</code></td><td>until first non-whitespace character on
              next line
          </td></tr></tbody></table>
  </dd></dl>  
  <a name="misc"></a>
  <h3>Miscellaneous<a href="http://glaciated.org/vi/#foot1">1</a></h3>
  <table>
    <tbody><tr><td><code>u</code></td><td>undo last change
    </td></tr><tr><td><code>U</code></td><td>undo entire line

    </td></tr><tr><td><em>"c</em><code>p</code></td><td>put <em>"c</em> or general
      buffer after the cursor
    </td></tr><tr><td><em>"c</em><code>P</code></td><td>put <em>"c</em> or general
      buffer before the cursor

    </td></tr><tr><td><code>m</code><em>c</em></td><td>set mark with character <em>c</em>
    </td></tr><tr><td><code>`</code><em>c</em></td><td>goto mark <em>c</em>
    </td></tr><tr><td><code>'</code><em>c</em></td><td>goto beginning of line with mark <em>c</em>
    </td></tr><tr><td><code>``</code></td><td>return to position before mark jump or search
    </td></tr><tr><td><code>''</code></td><td>return to beginning of line before mark jump or search

    </td></tr><tr><td><code>J</code></td><td>join two lines
    </td></tr><tr><td><code>D</code></td><td>delete rest of line
    </td></tr><tr><td><code>C</code></td><td>change rest of line
    </td></tr><tr><td><code>Y</code></td><td>yank current line into general buffer
    </td></tr><tr><td><code>&amp;</code></td><td>execute last ex-style substitution
    </td></tr><tr><td><code>.</code></td><td>execute last modification
    </td></tr><tr><td><code>!</code><em>obj cmd</em></td><td>send <em>object</em> as stdin
      to <em>command</em> and replace with stdout

    </td></tr><tr><td><code>[Ctrl]-G</code></td><td>print information about file

    </td></tr><tr><td>: <code>map</code> <em>x y</em></td><td>when character <em>x</em>
      is pressed, execute <em>y</em>
    </td></tr><tr><td>: <code>map!</code> <em>x y</em></td><td>map input mode character <em>x</em>
      to string <em>y</em>
    </td></tr><tr><td>: <code>ab</code> <em>x y</em></td><td><em>x</em> is an abbreviation for
      <em>y</em>, changes are made on the fly
    </td></tr><tr><td>: <code>su</code></td><td>Suspend the current editor session
    </td></tr><tr><td>: <code>sh</code></td><td>run a shell
  </td></tr></tbody></table>
  <a name="ex"></a>
  <h2><i>ex</i> Commands</h2>
  <a name="ex_syntax"></a>
  <h3><i>ex</i> syntax</h3>
    <dl>
      <dt><i>ex</i> commands in the <i>vi</i> follow this general form:
        </dt><dd>: <code>addr</code> <em>command</em>
      </dd><dt>which means:
        </dt><dd>Execute <em>command</em> on specific lines obtained from the
          <code>address</code> part of the general form. If <code>address</code>
          is omitted, current line is used. Keep in mind that the <i>ex</i>
          is a line based editor, so all actions are line based.
      </dd><dt><a name="address"><code>address</code>es:</a>
        </dt><dd><table>
              <tbody><tr><td><code>%</code></td><td>all lines in file
              </td></tr><tr><td><code>x,y</code></td><td>lines <code>x</code> to <code>y</code>
              </td></tr><tr><td><code>.</code></td><td>current line
              </td></tr><tr><td><code>n</code></td><td>line number: <code>n</code>
              </td></tr><tr><td><code>$</code></td><td>last line of file
              </td></tr><tr><td><code>x-n</code></td><td><code>n</code> lines before line <code>x</code>
              </td></tr><tr><td><code>x+n</code></td><td><code>n</code> lines after line <code>x</code>
              </td></tr><tr><td><code>/pat/</code></td><td>forward to line containing <code>pat</code>
              </td></tr><tr><td><code>?pat?</code></td><td>backward to line containing <code>pat</code>
            </td></tr></tbody></table>
      </dd><dt><a name="ex_commands">Some commands are:</a>
        </dt><dd><samp>refer to <i>ex</i> manual page for more commands</samp><table>
              <tbody><tr><td><code>s/pat/text/</code></td><td>substitute 1<sup>st</sup> match
                of <code>pat</code> with <code>text</code>
              </td></tr><tr><td><code>s/pat/text/g</code></td><td>substitute every match of
                <code>pat</code> with <code>text</code>
              </td></tr><tr><td><code>s/pat/text/n</code></td><td>substitute the
                <code>n<sup>th</sup></code> occurrence of <code>pat</code>
                with <code>text</code>
              </td></tr><tr><td><code>ya</code> <em>c</em></td><td>yank into buffer <em>c</em>
                or the general buffer if <em>c</em> is omitted
              </td></tr><tr><td><code>g address cmd</code></td><td>execute <code>cmd</code>
                on all lines which satisfy <code>address</code>
              </td></tr><tr><td><code>&gt;</code></td><td>shift right
              </td></tr><tr><td><code>&lt;</code></td><td>shift left
              </td></tr><tr><td><code>d</code></td><td>delete line
              </td></tr><tr><td><code>! UNIX-cmd</code></td><td>execute <code>UNIX-cmd</code> on line
              </td></tr><tr><td><code>m</code> <em>address</em></td><td>move lines to address
              </td></tr><tr>
            </tr></tbody></table>
    </dd></dl>
    <a name="variables"></a>
    <h3>The <i>vi</i> environment variables</h3>
    <dl>
      <dt><a name="set"><code>set</code></a>
        </dt><dd>You can customize your environment with this command by typing
          <code>set var=value</code>, this will set the specified
          <code>var</code> to <code>value</code> for a scalar variable.
          For boolean variables, use <code>set var</code> to set and
          <code>set novar</code> to unset. You can see which variables
          are set by just typing the <code>set</code> by its self.
          You can see a list of all variables by typing
          <code>set all</code>. Some environment variables are specific to
          the <i>ex</i> editor and some are specific to the <i>vi</i>
          editor. I have included both.
  </dd></dl>
  (I am missing some variables,  please contact
  <a href="mailto:totten@pobox.com">me</a> with additions.)
  <a name="bool"></a>
  <h4>boolean variables:</h4>
    <table>
      <tbody><tr><td><code>autoindent(ai)</code></td><td>begin editing next line at
        same level of indent-ion as this one.
	 </td></tr><tr><td><code>autowrite(aw)</code></td><td>write current buffer before leaving
	 </td></tr><tr><td><code>exrc(ex)</code></td><td>tells <i>vi</i>/<i>ex</i> if it should
	   read the .exrc file in the current directory(this can be a security
     risk).
	 </td></tr><tr><td><code>errorbells</code></td><td>editor sends a beep to the terminal when
	   an incorrect
   </td></tr><tr><td><code>flash</code></td><td>inverse the screen on an error instead
     of producing a bell
	 </td></tr><tr><td><code>ignorecase(ic)</code></td><td>ignore case of characters in
	   searches.
	 </td></tr><tr><td><code>lisp</code></td><td>enter lisp mode
	 </td></tr><tr><td><code>list</code></td><td>place a <em>$</em> at the end of each line
	   and a <em>^I</em> on each tab.
	 </td></tr><tr><td><code>magic</code></td><td>allow <em>.</em>, <em>[</em>, and <em>*</em> to
	   be interpreted as special characters in RE's.
   </td></tr><tr><td><code>modelines</code></td><td>execute the first and last 5 lines of
     the file if of the form: <code>ex:command:</code> or <code>vi:command:</code>
	 </td></tr><tr><td><code>number(nu)</code></td><td>number lines in left margin
	 </td></tr><tr><td><code>showmatch(sm)</code></td><td>when closing a paren., brace or
        bracket; move the visual cursor to opening item to check scope
	 </td></tr><tr><td><code>showmode(smd)</code></td><td>show type of insert mode
	 </td></tr><tr><td><code>wrapscan(ws)</code></td><td>when searching and at bottom of file,
	   continue searching from the top
    </td></tr></tbody></table>
  <a name="scalar"></a>
  <h4>scalar variables:</h4>
    <table>
      <tbody><tr><td><code>directory</code></td><td>the location of the temporary
        directory used by <i>vi</i>
      </td></tr><tr><td><code>paragraphs(para)</code></td><td>macros to signify the
        beginning of a paragraph
      </td></tr><tr><td><code>report</code></td><td><i>vi</i> will notify you if you
        change more lines than the value of <code>report</code>
      </td></tr><tr><td><code>sections(sect)</code></td><td>macros to signify the
        beginning of a section
      </td></tr><tr><td><code>shell</code></td><td>The shell to use when executing the
        command <code>:sh</code> or <code>:!</code>
      </td></tr><tr><td><code>shiftwidth(sw)</code></td><td>number of spaces to to insert
        on a shift operation
      </td></tr><tr><td><code>showmatch(sm)</code></td><td>show the match of <em>)</em>
        and <em>}</em> when typed
      </td></tr><tr><td><code>tabstop</code></td><td>the length, in characters, of a tabstop
      </td></tr><tr><td><code>term</code></td><td>holds the name of the terminal type
        being used
      </td></tr><tr><td><code>wrapmargin(wm)</code></td><td>split lines at the column which is
        equal to the value of <code>wrapmargin</code>
    </td></tr></tbody></table>
  <a name="file"></a>
  <h2>File Saving and Loading</h2>
  <table>
    <tbody><tr><td>: <code>wq</code></td><td>write file and quit
    </td></tr><tr><td>: <code>w</code></td><td>write file
    </td></tr><tr><td>: <code>w file</code></td><td>write to specified <code>file</code>
    </td></tr><tr><td>: <code>w!</code></td><td>overwrite existing file
    </td></tr><tr><td>: <code>e file</code></td><td>edit new <code>file</code>
    </td></tr><tr><td>: <code>r file</code></td><td>put contents of <code>file</code>
    </td></tr><tr><td>: <code>q</code></td><td>quit the editor
    </td></tr><tr><td>: <code>q!</code></td><td>force quit the editor, do not save changes
    </td></tr><tr><td>: <code>x</code></td><td>quit the editor, save file if it was modified
    </td></tr><tr><td><code>ZZ</code></td><td>quit the editor, save file if it was modified
    </td></tr><tr><td>: <code>n</code></td><td>start editing next file in list
    </td></tr><tr><td>: <code>rew</code></td><td>rewind file list, start editing 1<sup>st</sup>
      file on argument list again
    </td></tr><tr><td><code>Q</code></td><td>quit <i>vi</i> and enter <i>ex</i>
    </td></tr><tr><td>: <code>pre</code></td><td>Preserve file.
    </td></tr><tr><td>: <code>rec</code> <em>file</em></td><td>recover <em>file</em>
  </td></tr></tbody></table>
  <a name="examples"></a>
  <h2>Examples2</a></h2>
  <table>
    <tbody><tr><td><code>j</code></td><td>move cursor down
    </td></tr><tr><td><code>k</code></td><td>move cursor up
    </td></tr><tr><td><code>h</code> or <code>[BS]</code></td><td>move cursor left
    </td></tr><tr><td><code>l</code> or <code>[SPACE]</code></td><td>move cursor right
    </td></tr><tr><td><code>+</code> or <code>[RETURN]</code></td><td>first
      non-whitespace character on next line
    </td></tr><tr><td><code>cw</code></td><td>change word
    </td></tr><tr><td><code>dd</code> or <code>d_</code></td><td>delete line
    </td></tr><tr><td><code>yy</code> or <code>y_</code></td><td>yank current line into
      the general buffer
    </td></tr><tr><td><code>"ayj</code></td><td>yank current line and one below into buffer
      <code>a</code>
    </td></tr><tr><td><code>yfc</code></td><td>yank until next occurrence of <code>c</code>
      on current line into the general buffer
    </td></tr><tr><td><code>3dl</code> or <code>d3l</code></td><td>delete next 3 characters
    </td></tr><tr><td><code>4c(</code> or <code>2c2(</code> or
      <code>c4(</code></td><td>change next 4 sentences 
    </td></tr><tr><td><code>&gt;%</code></td><td>while on a brace, paren., or bracket; shift
      right until closing brace, etc.
    </td></tr><tr><td><code>:%!sort</code> or <code>:1,$!sort</code></td><td>sort current file
    </td></tr><tr><td><code>:5,10s/foo/bar/2</code></td><td>change the second occurrence of
      <code>foo</code> with <code>bar</code> on lines 5-10
    </td></tr><tr><td><code>:map g 1G</code></td><td>map <code>g</code> to really run <code>1G</code>
    </td></tr><tr><td><code>3J</code></td><td>Join next 2 lines to current one
    </td></tr><tr><td><code>3,9m$</code></td><td>move lines 3 through 9 to the end of the file
    </td></tr><tr><td><code>ab w/o without</code></td><td>when <code>w/o</code> is
      typed change to <code>without</code>
    </td></tr><tr><td><code>:?foo?,/bar/d</code></td><td>delete from the reverse match
      of foo until the next match of bar
    </td></tr><tr><td><code>:g/{/,/}/&lt;</code></td><td>shift all lines between, and
      including, a "<code>{</code>" and a
      "<code>}</code>" left
    </td></tr><tr><td><code>:$-4,$d</code></td><td>delete last five lines of buffer
    </td></tr><tr><td><code>:%s/^\(.*\) \(.*\)$/\2 \1/</code></td><td>swap everything before
      and after the first space
    </td></tr><tr><td><code>d''</code></td><td>delete from current position to line of
      last jump
  </td></tr></tbody></table>

  <hr align="left" width="25%">
  <a name="foot"></a>
  <p><a name="foot1">1</a> It is noteworthy to add that most
    control sequences are bound in the <i>vi</i>.  I do not mention them
    here because they remind me of emacs and I hope to spare you such
    pain.</p>
  <p><a name="foot2">2</a> For the record, <strong>no</strong>
    animals were physically harmed during the testing of these examples;
    although some elephants are now in psychological therapy as a direct
    result  of my actions. I kind of feel rather guilty about this :(</p>

  <hr>

 


</body></html>